/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./app/armor.ts":
/*!**********************!*\
  !*** ./app/armor.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allArmors: () => (/* binding */ allArmors),\n/* harmony export */   armorTypeLabels: () => (/* binding */ armorTypeLabels),\n/* harmony export */   armorTypes: () => (/* binding */ armorTypes),\n/* harmony export */   armorsByType: () => (/* binding */ armorsByType),\n/* harmony export */   heavyArmors: () => (/* binding */ heavyArmors),\n/* harmony export */   lightArmors: () => (/* binding */ lightArmors),\n/* harmony export */   mediumArmors: () => (/* binding */ mediumArmors)\n/* harmony export */ });\nfunction createLightArmor(level, name) {\r\n    return {\r\n        type: 'armor',\r\n        armorType: 'lightArmor',\r\n        level: Math.floor(level),\r\n        name,\r\n        life: level * 10,\r\n        armor: level,\r\n        speedFactor: 1.2,\r\n        enchantmentSlots: [],\r\n    };\r\n}\r\nconst lightArmors = [\r\n    createLightArmor(1, 'Wool Shirt'),\r\n    createLightArmor(2, 'Hemp Frock'),\r\n    createLightArmor(7, 'Linen Frock'),\r\n    createLightArmor(11, 'Cotton Frock'),\r\n    createLightArmor(17, 'Fur Coat'),\r\n    createLightArmor(24, 'Cashmere Robe'),\r\n    createLightArmor(32, 'Silk Robe'),\r\n    createLightArmor(41, 'Angora Robe'),\r\n    createLightArmor(51, 'Velvet Robe'),\r\n    createLightArmor(62, 'Embroidered Robe'),\r\n    createLightArmor(74, 'Sorcerous Vestment'),\r\n    createLightArmor(87, 'Blessed Vestment'),\r\n    createLightArmor(95, 'Divine Vestment'),\r\n];\r\nfunction createMediumArmor(level, name) {\r\n    return {\r\n        type: 'armor',\r\n        armorType: 'mediumArmor',\r\n        level: Math.floor(level),\r\n        name,\r\n        life: level * 15,\r\n        armor: Math.ceil(level * 1.5),\r\n        speedFactor: 1,\r\n        enchantmentSlots: [],\r\n    };\r\n}\r\nconst mediumArmors = [\r\n    createMediumArmor(1, 'Cloth Tunic'),\r\n    createMediumArmor(3, 'Leather Tunic'),\r\n    createMediumArmor(8, 'Hide Tunic'),\r\n    createMediumArmor(13, 'Leather Armor'),\r\n    createMediumArmor(19, 'Studded Armor'),\r\n    createMediumArmor(26, 'Hide Armor'),\r\n    createMediumArmor(34, 'Carapace Armor'),\r\n    createMediumArmor(43, 'Treated Armor'),\r\n    createMediumArmor(53, 'Splint Armor'),\r\n    createMediumArmor(64, 'Scale Armor'),\r\n    createMediumArmor(76, 'Composite Armor'),\r\n    createMediumArmor(89, 'Runed Armor'),\r\n    createMediumArmor(95, 'Dragon Armor'),\r\n];\r\nfunction createHeavyArmor(level, name) {\r\n    return {\r\n        type: 'armor',\r\n        armorType: 'heavyArmor',\r\n        level: Math.floor(level),\r\n        name,\r\n        life: level * 20,\r\n        armor: Math.ceil(level * 2),\r\n        speedFactor: 0.8,\r\n        enchantmentSlots: [],\r\n    };\r\n}\r\nconst heavyArmors = [\r\n    createHeavyArmor(1, 'Lamellar'),\r\n    createHeavyArmor(5, 'Bamboo Armor'),\r\n    createHeavyArmor(10, 'Panoply'),\r\n    createHeavyArmor(15, 'Plated Coat'),\r\n    createHeavyArmor(21, 'Brigandine'),\r\n    createHeavyArmor(28, 'Cuirass'),\r\n    createHeavyArmor(36, 'Chainmail'),\r\n    createHeavyArmor(45, 'Scalemail'),\r\n    createHeavyArmor(55, 'Platemail'),\r\n    createHeavyArmor(66, 'Half Plate'),\r\n    createHeavyArmor(78, 'Full Plate'),\r\n    createHeavyArmor(91, 'Adamantium Plate'),\r\n    createHeavyArmor(95, 'Orichalcum Plate'),\r\n];\r\nconst armorTypes = ['lightArmor', 'mediumArmor', 'heavyArmor'];\r\nconst armorsByType = {\r\n    lightArmor: lightArmors,\r\n    mediumArmor: mediumArmors,\r\n    heavyArmor: heavyArmors,\r\n};\r\nconst allArmors = Object.values(armorsByType);\r\nconst armorTypeLabels = {\r\n    lightArmor: 'Light Armor',\r\n    mediumArmor: 'Armor',\r\n    heavyArmor: 'Heavy Armor',\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/armor.ts?");

/***/ }),

/***/ "./app/bosses/guardian.ts":
/*!********************************!*\
  !*** ./app/bosses/guardian.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   guardian: () => (/* binding */ guardian)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst guardian = {\r\n    name: 'Guardian',\r\n    statFactors: {\r\n        maxLife: 5,\r\n        damage: 1,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 1,\r\n    experienceFactor: 20,\r\n    radius: 40,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        if (!enemy.minions.length && enemy.life <= enemy.maxLife / 2) {\r\n            for (let i = 0; i < 3; i++) {\r\n                const theta = i * 2 * Math.PI / 3;\r\n                const minion = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(enemy.disc.x + (enemy.disc.radius - 30) * Math.cos(theta), enemy.disc.y + (enemy.disc.radius - 30) * Math.sin(theta), guardianTurret, enemy.level, enemy.disc);\r\n                minion.theta = theta;\r\n                enemy.minions.push(minion);\r\n                minion.master = enemy;\r\n            }\r\n        }\r\n        if (enemy.mode === 'choose') {\r\n            enemy.speed = app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.chaseTarget)(state, enemy, state.hero);\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_5__[\"default\"].element(['moveToEdge', 'moveToEdge', 'moveToCenter', 'chase']));\r\n                //enemy.setMode(Random.element(['moveToCenter']));\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveToEdge') {\r\n            enemy.speed = 1.2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            let { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy.disc, enemy);\r\n            if (distance2 >= (enemy.disc.radius * 0.8) ** 2) {\r\n                enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_5__[\"default\"].element(['shoot', 'shoot', 'circle']));\r\n            }\r\n            else {\r\n                enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyInDirection)(state, enemy);\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveToCenter') {\r\n            enemy.speed = 1.2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyToTarget)(state, enemy, enemy.disc)) {\r\n                enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_5__[\"default\"].element(['chasingSpirals', 'crossingSpirals']));\r\n                //enemy.setMode(Random.element(['chasingSpirals']));\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'chasingSpirals') {\r\n            enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.turnTowardsAngle)(enemy.theta, 0.2, -Math.PI / 2);\r\n            if (enemy.modeTime < 400) {\r\n                return;\r\n            }\r\n            if (enemy.modeTime % 200 === 0) {\r\n                const expirationTime = state.fieldTime + 2000;\r\n                for (let i = 0; i < 2; i++) {\r\n                    const thetaIndex = (enemy.modeTime - 400) / 200 + i;\r\n                    const theta = -Math.PI / 2 + (i + 1) * thetaIndex * Math.PI / 12;\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootEnemyBullet)(state, enemy, 100 * Math.cos(theta), 100 * Math.sin(theta), { expirationTime });\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootEnemyBullet)(state, enemy, 100 * Math.cos(theta + Math.PI), 100 * Math.sin(theta + Math.PI), { expirationTime });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= 4000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'crossingSpirals') {\r\n            enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.turnTowardsAngle)(enemy.theta, 0.2, Math.PI / 2);\r\n            if (enemy.modeTime < 400) {\r\n                return;\r\n            }\r\n            if (enemy.modeTime % 200 === 0) {\r\n                const expirationTime = state.fieldTime + 2000;\r\n                for (let i = 0; i < 2; i++) {\r\n                    const thetaIndex = (enemy.modeTime - 400) / 200;\r\n                    const theta = Math.PI / 2 + thetaIndex * Math.PI / 6 * (i ? -1 : 1);\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootEnemyBullet)(state, enemy, 100 * Math.cos(theta), 100 * Math.sin(theta), { expirationTime });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= 4000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'shoot') {\r\n            if (enemy.modeTime < 600) {\r\n                const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, state.hero);\r\n                enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n            }\r\n            if (enemy.modeTime === 1000) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootEnemyBullet)(state, enemy, 200 * Math.cos(enemy.theta), 200 * Math.sin(enemy.theta), {\r\n                    expirationTime: state.fieldTime + 2000,\r\n                    damage: enemy.damage * 5,\r\n                    radius: 3 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS,\r\n                });\r\n            }\r\n            if (enemy.modeTime >= 1500) {\r\n                enemy.setMode('charge');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'charge') {\r\n            enemy.speed = 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyInDirection)(state, enemy);\r\n            if (enemy.modeTime % 200 === 0) {\r\n                const vx = 120 * Math.cos(enemy.theta + Math.PI / 2);\r\n                const vy = 120 * Math.sin(enemy.theta + Math.PI / 2);\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootEnemyBullet)(state, enemy, vx, vy, { expirationTime: state.fieldTime + 3000 });\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootEnemyBullet)(state, enemy, -vx, -vy, { expirationTime: state.fieldTime + 3000 });\r\n            }\r\n            if (enemy.modeTime >= 3000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            // Stop earlier if it hits the outside of the ring.\r\n            if (enemy.modeTime >= 1000) {\r\n                let { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy.disc, enemy);\r\n                if (distance2 >= (enemy.disc.radius * 0.9) ** 2) {\r\n                    enemy.setMode('choose');\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'chase') {\r\n            enemy.speed = app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.chaseTarget)(state, enemy, state.hero);\r\n            if (enemy.modeTime % 800 === 0) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletArc)(state, enemy, enemy.theta, Math.PI / 6, 3, 200);\r\n            }\r\n            if (enemy.modeTime >= 4000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'circle') {\r\n            enemy.speed = 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            let { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, enemy.disc);\r\n            enemy.theta = Math.atan2(y, x);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyInDirection)(state, enemy, enemy.theta + Math.PI / 2);\r\n            if (enemy.modeTime % 600 === 0) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletArc)(state, enemy, enemy.theta, Math.PI / 6, 3, 200);\r\n            }\r\n            if (enemy.modeTime >= 6000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, {\r\n            x: enemy.x + 30 * Math.cos(enemy.theta + Math.PI / 6),\r\n            y: enemy.y + 30 * Math.sin(enemy.theta + Math.PI / 6),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, {\r\n            x: enemy.x + 30 * Math.cos(enemy.theta),\r\n            y: enemy.y + 30 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, {\r\n            x: enemy.x + 30 * Math.cos(enemy.theta - Math.PI / 6),\r\n            y: enemy.y + 30 * Math.sin(enemy.theta - Math.PI / 6),\r\n            radius: 5,\r\n        }, 'black');\r\n    },\r\n    getEnchantment(state, enemy) {\r\n        return (0,app_enchantments__WEBPACK_IMPORTED_MODULE_1__.getVigorEnchantment)(enemy.level);\r\n    },\r\n};\r\nconst guardianTurret = {\r\n    name: 'Turret',\r\n    statFactors: {\r\n        maxLife: 2,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n        armor: 2,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 0,\r\n    experienceFactor: 2,\r\n    radius: 20,\r\n    isInvulnerable: true,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, enemy.disc);\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.turnTowardsAngle)(enemy.theta, 0.1, Math.atan2(y, x));\r\n        if (enemy.modeTime > 1000 && enemy.modeTime % 400 === 0) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletArc)(state, enemy, enemy.theta, 2 * Math.PI / 3, 2, 150);\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, enemy, 'yellow');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, {\r\n            x: enemy.x + 20 * Math.cos(enemy.theta + Math.PI / 3),\r\n            y: enemy.y + 20 * Math.sin(enemy.theta + Math.PI / 3),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, {\r\n            x: enemy.x + 20 * Math.cos(enemy.theta - Math.PI / 3),\r\n            y: enemy.y + 20 * Math.sin(enemy.theta - Math.PI / 3),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/bosses/guardian.ts?");

/***/ }),

/***/ "./app/client.ts":
/*!***********************!*\
  !*** ./app/client.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var app_contextMenu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/contextMenu */ \"./app/contextMenu.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_inventory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/inventory */ \"./app/inventory.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_combat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/combat */ \"./app/utils/combat.ts\");\n/* harmony import */ var app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/dungeon */ \"./app/utils/dungeon.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n/* harmony import */ var app_armor__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/armor */ \"./app/armor.ts\");\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_initialize__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/initialize */ \"./app/initialize.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet state = {\r\n    fieldTime: 0,\r\n    hero: {\r\n        level: 1,\r\n        experience: 0,\r\n        speed: 100,\r\n        x: app_constants__WEBPACK_IMPORTED_MODULE_13__.CELL_SIZE / 2,\r\n        y: -app_constants__WEBPACK_IMPORTED_MODULE_13__.CELL_SIZE / 2,\r\n        overworldX: app_constants__WEBPACK_IMPORTED_MODULE_13__.CELL_SIZE / 2,\r\n        overworldY: -app_constants__WEBPACK_IMPORTED_MODULE_13__.CELL_SIZE / 2,\r\n        radius: 15,\r\n        theta: 0,\r\n        damageHistory: [],\r\n        recentDamageTaken: 0,\r\n        equipment: {\r\n            weapon: app_utils_Random__WEBPACK_IMPORTED_MODULE_11__[\"default\"].element(app_weapons__WEBPACK_IMPORTED_MODULE_15__.allWeapons.filter(arr => arr.length))[0],\r\n            armor: app_armor__WEBPACK_IMPORTED_MODULE_12__.mediumArmors[0],\r\n        },\r\n        weapons: [],\r\n        weaponProficiency: {},\r\n        armors: [],\r\n        enchantments: [],\r\n        // Derived stats will get set later.\r\n        life: 10,\r\n        maxLife: 10,\r\n        baseArmor: 0,\r\n        armor: 0,\r\n        damage: 0,\r\n        attacksPerSecond: 0,\r\n        attackCooldown: 0,\r\n        chargingLevel: 1,\r\n        attackChargeLevel: 1,\r\n        attackChargeDuration: 0,\r\n        potions: app_constants__WEBPACK_IMPORTED_MODULE_13__.BASE_MAX_POTIONS,\r\n        isShooting: false,\r\n        // Base crit damage/chance is on weapons, this just stores\r\n        // bonuses from enchantments+weapon proficiencies.\r\n        critChance: 0,\r\n        critDamage: 0,\r\n        chargeDamage: 0,\r\n        armorShredEffect: 0,\r\n        potionEffect: 1,\r\n    },\r\n    heroBullets: [],\r\n    enemies: [],\r\n    loot: [],\r\n    portals: [],\r\n    enemyBullets: [],\r\n    fieldText: [],\r\n    worldSeed: Math.random(),\r\n    activeCells: [],\r\n    recentCells: [],\r\n    cellMap: new Map(),\r\n    activeDiscs: [],\r\n    visibleDiscs: [],\r\n    gameHasBeenInitialized: false,\r\n    paused: false,\r\n    mouse: {\r\n        x: app_constants__WEBPACK_IMPORTED_MODULE_13__.CANVAS_WIDTH / 2,\r\n        y: app_constants__WEBPACK_IMPORTED_MODULE_13__.CANVAS_HEIGHT / 2,\r\n        isDown: false,\r\n        wasPressed: false,\r\n    },\r\n    keyboard: {\r\n        gameKeyValues: [],\r\n        gameKeysDown: new Set(),\r\n        gameKeysPressed: new Set(),\r\n        mostRecentKeysPressed: new Set(),\r\n        gameKeysReleased: new Set(),\r\n    },\r\n    menuRow: 0,\r\n    menuColumn: 0,\r\n    menuEquipmentSelected: false,\r\n};\r\n// @ts-ignore\r\nwindow['state'] = state;\r\nfunction getState() {\r\n    return state;\r\n}\r\nfunction update() {\r\n    const state = getState();\r\n    if (!state.gameHasBeenInitialized) {\r\n        (0,app_initialize__WEBPACK_IMPORTED_MODULE_14__.initializeGame)(state);\r\n        (0,app_contextMenu__WEBPACK_IMPORTED_MODULE_0__.addContextMenuListeners)(state);\r\n        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.setDerivedHeroStats)(state);\r\n        (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__.clearNearbyEnemies)(state);\r\n        // startDungeon(state, createTreeDungeon(Math.random(), 2000, 1));\r\n    }\r\n    (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.updateKeyboardState)(state);\r\n    if (state.isUsingXbox) {\r\n        const [dx, dy] = (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.getRightAnalogDeltas)(state);\r\n        state.hero.theta = Math.atan2(dy, dx);\r\n        state.hero.isShooting = (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.SHOOT);\r\n    }\r\n    else {\r\n        const [x, y] = (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_9__.getMousePosition)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_4__.mainCanvas, app_constants__WEBPACK_IMPORTED_MODULE_13__.CANVAS_SCALE);\r\n        let aimDx = x - app_constants__WEBPACK_IMPORTED_MODULE_13__.FIELD_CENTER.x, aimDy = y - app_constants__WEBPACK_IMPORTED_MODULE_13__.FIELD_CENTER.y;\r\n        state.hero.theta = Math.atan2(aimDy, aimDx);\r\n        state.mouse.x = x;\r\n        state.mouse.y = y;\r\n        if ((0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_9__.isMouseDown)()) {\r\n            state.mouse.wasPressed = !state.mouse.isDown;\r\n            state.mouse.isDown = true;\r\n        }\r\n        else {\r\n            state.mouse.wasPressed = false;\r\n            state.mouse.isDown = false;\r\n            state.hero.isShooting = false;\r\n        }\r\n        if (state.mouse.wasPressed) {\r\n            state.hero.isShooting = true;\r\n        }\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.MENU)) {\r\n        state.paused = !state.paused;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.KEY.SHIFT) && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.KEY.B)) {\r\n        const bossDisc = state.activeDiscs.find(d => d.boss);\r\n        if (bossDisc) {\r\n            state.hero.x = bossDisc.x;\r\n            state.hero.y = bossDisc.y;\r\n        }\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.KEY.SHIFT) && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.KEY.K)) {\r\n        for (const enemy of state.enemies) {\r\n            if (enemy.disc === state.hero.disc) {\r\n                defeatEnemy(state, enemy);\r\n            }\r\n        }\r\n        state.enemies = state.enemies.filter(e => e.life > 0);\r\n    }\r\n    (0,app_inventory__WEBPACK_IMPORTED_MODULE_2__.updateInventory)(state);\r\n    if (state.paused) {\r\n        return;\r\n    }\r\n    state.fieldTime += app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n    if (state.hero.life <= 0) {\r\n        return;\r\n    }\r\n    (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__.updateActiveCells)(state);\r\n    updateHero(state);\r\n    updateEnemies(state);\r\n    updateHeroBullets(state);\r\n    updateEnemyBullets(state);\r\n    state.fieldText = state.fieldText.filter(t => t.expirationTime > state.fieldTime);\r\n    for (const fieldText of state.fieldText) {\r\n        fieldText.x += fieldText.vx;\r\n        fieldText.y += fieldText.vy;\r\n        fieldText.time += app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n    }\r\n    const hoverSlot = (0,app_inventory__WEBPACK_IMPORTED_MODULE_2__.getHoverInventorySlot)(state);\r\n    if (!hoverSlot) {\r\n        state.activeLoot = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_7__.getClosestElement)(state.hero, state.loot);\r\n    }\r\n    else {\r\n        delete state.activeLoot;\r\n    }\r\n    if (state.activeLoot && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_7__.getTargetVector)(state.hero, state.activeLoot).distance2 >= (state.activeLoot.radius + state.hero.radius + 10) ** 2) {\r\n        delete state.activeLoot;\r\n    }\r\n    if (state.activeLoot && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.ACTIVATE)) {\r\n        state.activeLoot.activate(state);\r\n        state.activeLoot.disc.loot.splice(state.activeLoot.disc.loot.indexOf(state.activeLoot), 1);\r\n        delete state.activeLoot;\r\n    }\r\n    else if (state.activeLoot && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.SELL)) {\r\n        state.activeLoot.sell();\r\n        state.activeLoot.disc.loot.splice(state.activeLoot.disc.loot.indexOf(state.activeLoot), 1);\r\n        delete state.activeLoot;\r\n    }\r\n}\r\nfunction updateHero(state) {\r\n    var _a, _b;\r\n    const hero = state.hero;\r\n    // Hero damage frames\r\n    hero.damageHistory.unshift(0);\r\n    if (hero.damageHistory.length > app_constants__WEBPACK_IMPORTED_MODULE_13__.HERO_DAMAGE_FRAME_COUNT) {\r\n        const oldDamage = hero.damageHistory.pop();\r\n        hero.recentDamageTaken -= oldDamage;\r\n    }\r\n    // Hero movement\r\n    let dx = 0, dy = 0;\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.UP)) {\r\n        dy--;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.DOWN)) {\r\n        dy++;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.LEFT)) {\r\n        dx--;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.RIGHT)) {\r\n        dx++;\r\n    }\r\n    const m = Math.sqrt(dx * dx + dy * dy);\r\n    if (m > 1) {\r\n        dx /= m;\r\n        dy /= m;\r\n    }\r\n    // Currently walking is always disabled, but we can add a key for it later if we want.\r\n    const isWalking = false;\r\n    const speed = isWalking ? hero.speed : 1.5 * hero.speed;\r\n    hero.x += dx * speed / app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n    hero.y += dy * speed / app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n    // Hero attack\r\n    const weapon = hero.equipment.weapon;\r\n    const attacksPerSecond = weapon.attacksPerSecond * hero.attacksPerSecond;\r\n    // chargingLevel increases as long as the hero\r\n    // Default charge speed is 1 charge per 20 seconds.\r\n    gainAttackCharge(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH / 20000);\r\n    if (state.hero.attackChargeLevel > 1) {\r\n        state.hero.attackChargeDuration -= app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n        if (state.hero.attackChargeDuration <= 0) {\r\n            state.hero.attackChargeLevel = 1;\r\n        }\r\n    }\r\n    else if (state.hero.chargingLevel >= 2 &&\r\n        ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.SPECIAL_ATTACK)\r\n            || (state.isUsingKeyboard && (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_9__.isRightMouseDown)()))) {\r\n        // Charge duration is 2 seconds by default.\r\n        state.hero.attackChargeDuration = 2000;\r\n        state.hero.attackChargeLevel = state.hero.chargingLevel;\r\n        state.hero.chargingLevel = 1;\r\n        // Restart attack pattern when triggering charged attacks.\r\n        hero.attackCooldown = state.fieldTime;\r\n    }\r\n    if (state.hero.isShooting) {\r\n        const attackCooldownDuration = 1000 / attacksPerSecond;\r\n        if (hero.attackCooldown <= state.fieldTime) {\r\n            hero.attackCooldown = state.fieldTime + attackCooldownDuration;\r\n        }\r\n        const attackTime = attackCooldownDuration - (hero.attackCooldown - state.fieldTime);\r\n        for (const shot of weapon.shots) {\r\n            const shotTime = attackCooldownDuration * ((_a = shot.timingOffset) !== null && _a !== void 0 ? _a : 0);\r\n            if (shotTime >= attackTime - app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH / 2 && shotTime < attackTime + app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH / 2) {\r\n                state.heroBullets.push(shot.generateBullet(state, hero, weapon));\r\n            }\r\n        }\r\n    }\r\n    if ((0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_9__.isMiddleMouseDown)() && state.dungeon) {\r\n        (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__.returnToOverworld)(state);\r\n    }\r\n    if (!((_b = state.hero.disc) === null || _b === void 0 ? void 0 : _b.boss)) {\r\n        assignToDisc(state.hero, state.activeDiscs);\r\n    }\r\n    constrainToDisc(state.hero, state.hero.disc);\r\n    for (const portal of state.portals) {\r\n        const isActive = !state.activeLoot && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_7__.doCirclesIntersect)(state.hero, portal);\r\n        if (isActive && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.ACTIVATE)) {\r\n            portal.activate(state);\r\n            break;\r\n        }\r\n    }\r\n    if (hero.potions > 0 && hero.life < hero.maxLife && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_10__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.POTION)) {\r\n        hero.life = Math.min(hero.maxLife, Math.ceil(hero.life + hero.maxLife * 0.2 * hero.potionEffect));\r\n        hero.potions--;\r\n    }\r\n}\r\nfunction gainAttackCharge(state, amount) {\r\n    // Cannot gain charge while using a charged attack.\r\n    if (state.hero.attackChargeLevel > 1) {\r\n        return;\r\n    }\r\n    state.hero.chargingLevel = Math.min(state.hero.equipment.weapon.chargeLevel, state.hero.chargingLevel + amount);\r\n}\r\nfunction updateEnemies(state) {\r\n    var _a, _b, _c;\r\n    const boss = (_a = state.hero.disc) === null || _a === void 0 ? void 0 : _a.boss;\r\n    for (const enemy of state.enemies) {\r\n        // Freeze enemies outside of the boss fight.\r\n        if (boss && ((_b = enemy.disc) === null || _b === void 0 ? void 0 : _b.boss) !== boss) {\r\n            continue;\r\n        }\r\n        // Freeze bosses that are not activated.\r\n        if (!boss && ((_c = enemy.disc) === null || _c === void 0 ? void 0 : _c.boss) === enemy) {\r\n            continue;\r\n        }\r\n        enemy.modeTime += app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n        enemy.definition.update(state, enemy);\r\n        // No changing discs during boss fights.\r\n        if (!boss) {\r\n            assignToDisc(enemy, state.activeDiscs);\r\n        }\r\n        constrainToDisc(enemy, enemy.disc);\r\n    }\r\n}\r\nfunction updateHeroBullets(state) {\r\n    var _a, _b, _c, _d, _e;\r\n    const activeBullets = state.heroBullets.filter(b => b.expirationTime >= state.fieldTime);\r\n    state.heroBullets = [];\r\n    const boss = (_a = state.hero.disc) === null || _a === void 0 ? void 0 : _a.boss;\r\n    for (const bullet of activeBullets) {\r\n        bullet.time += app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n        bullet.x += bullet.vx / app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n        bullet.y += bullet.vy / app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n        let bulletAbsorbed = false;\r\n        for (const enemy of state.enemies) {\r\n            if (enemy.isInvulnerable) {\r\n                continue;\r\n            }\r\n            if (enemy.life <= 0) {\r\n                continue;\r\n            }\r\n            // Freeze enemies outside of the boss fight.\r\n            if (boss && ((_b = enemy.disc) === null || _b === void 0 ? void 0 : _b.boss) !== boss) {\r\n                continue;\r\n            }\r\n            // Freeze bosses that are not activated.\r\n            if (!boss && ((_c = enemy.disc) === null || _c === void 0 ? void 0 : _c.boss) === enemy) {\r\n                continue;\r\n            }\r\n            if (bullet.hitTargets.has(enemy)) {\r\n                continue;\r\n            }\r\n            if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_7__.doCirclesIntersect)(enemy, bullet)) {\r\n                bullet.hitTargets.add(enemy);\r\n                const damage = (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_5__.applyArmorToDamage)(state, bullet.damage, enemy.armor);\r\n                if (bullet.chargeGain) {\r\n                    gainAttackCharge(state, bullet.chargeGain);\r\n                    // A bullet grants less charge for each additional enemy it hits.\r\n                    bullet.chargeGain /= 2;\r\n                }\r\n                enemy.life -= damage;\r\n                let armorShred = bullet.armorShred;\r\n                if (enemy.armor <= enemy.baseArmor / 2) {\r\n                    armorShred /= 2;\r\n                }\r\n                if (enemy.armor <= enemy.baseArmor / 4) {\r\n                    armorShred /= 2;\r\n                }\r\n                enemy.armor = Math.max(enemy.baseArmor / 10, enemy.armor * (1 - armorShred));\r\n                (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_5__.addDamageNumber)(state, enemy, damage, bullet.isCrit);\r\n                if (enemy.life <= 0) {\r\n                    defeatEnemy(state, enemy);\r\n                }\r\n                else {\r\n                    // Shots are not absorbed by defeated enemies.\r\n                    bulletAbsorbed = !bullet.isEnemyPiercing;\r\n                    (_e = (_d = enemy.definition).onHit) === null || _e === void 0 ? void 0 : _e.call(_d, state, enemy, bullet);\r\n                }\r\n            }\r\n        }\r\n        if (!bulletAbsorbed) {\r\n            state.heroBullets.push(bullet);\r\n        }\r\n    }\r\n}\r\nfunction defeatEnemy(state, enemy) {\r\n    var _a, _b, _c, _d, _e, _f, _g;\r\n    enemy.life = 0;\r\n    (_b = (_a = enemy.definition).onDeath) === null || _b === void 0 ? void 0 : _b.call(_a, state, enemy);\r\n    const experiencePenalty = Math.min(1, Math.max(0, (state.hero.level - enemy.level) * 0.1));\r\n    const experience = app_constants__WEBPACK_IMPORTED_MODULE_13__.BASE_XP * Math.pow(1.2, enemy.level) * ((_c = enemy.definition.experienceFactor) !== null && _c !== void 0 ? _c : 1);\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.gainExperience)(state, Math.ceil(experience * (1 - experiencePenalty)));\r\n    const weapon = state.hero.equipment.weapon;\r\n    // Gain more weapon experience when using higher level weapons.\r\n    let weaponXpFactor = 1;\r\n    if (weapon.level > (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.getWeaponProficiency)(state, weapon.weaponType).level) {\r\n        weaponXpFactor = 2;\r\n    }\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.gainWeaponExperience)(state, state.hero.equipment.weapon.weaponType, enemy.level, weaponXpFactor * experience);\r\n    (0,app_loot__WEBPACK_IMPORTED_MODULE_1__.checkToDropBasicLoot)(state, enemy);\r\n    if (enemy.disc && enemy.definition.portalDungeonType && Math.random() <= ((_d = enemy.definition.portalChance) !== null && _d !== void 0 ? _d : 0)) {\r\n        (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__.addDungeonPortalToDisc)(enemy, enemy.definition.portalDungeonType, enemy.level, Math.random(), enemy.disc);\r\n    }\r\n    if (((_e = enemy.disc) === null || _e === void 0 ? void 0 : _e.boss) === enemy) {\r\n        delete enemy.disc.boss;\r\n        (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__.addOverworldPortalToDisc)(enemy.disc, enemy.disc);\r\n        // Destroy all boss minions when it is defeated. They will not grant experience as they are not\r\n        // killed by taking shot damage.\r\n        for (const minion of enemy.minions) {\r\n            minion.life = 0;\r\n        }\r\n        const enchantment = (_g = (_f = enemy.definition).getEnchantment) === null || _g === void 0 ? void 0 : _g.call(_f, state, enemy);\r\n        if (enchantment) {\r\n            (0,app_loot__WEBPACK_IMPORTED_MODULE_1__.dropEnchantmentLoot)(state, enemy.disc, {\r\n                x: enemy.disc.x,\r\n                y: enemy.disc.y + 100,\r\n            }, enchantment);\r\n        }\r\n    }\r\n}\r\nfunction updateEnemyBullets(state) {\r\n    const activeBullets = state.enemyBullets.filter(b => b.expirationTime >= state.fieldTime);\r\n    state.enemyBullets = [];\r\n    for (const bullet of activeBullets) {\r\n        bullet.time += app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n        bullet.update(state, bullet);\r\n        let hitTarget = false;\r\n        if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_7__.doCirclesIntersect)(state.hero, bullet)) {\r\n            hitTarget = true;\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.damageHero)(state, bullet.damage);\r\n        }\r\n        if (!hitTarget) {\r\n            state.enemyBullets.push(bullet);\r\n        }\r\n    }\r\n    state.enemies = state.enemies.filter(e => e.life > 0);\r\n}\r\nfunction assignToDisc(geometry, discs) {\r\n    geometry.disc = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_7__.findClosestDisc)(geometry, discs);\r\n}\r\nfunction constrainToDisc(geometry, disc) {\r\n    if (!disc) {\r\n        return;\r\n    }\r\n    const dx = geometry.x - disc.x, dy = geometry.y - disc.y;\r\n    const distance2 = dx * dx + dy * dy;\r\n    if (distance2 > disc.radius * disc.radius) {\r\n        const m = Math.sqrt(distance2);\r\n        geometry.x = disc.x + disc.radius * dx / m;\r\n        geometry.y = disc.y + disc.radius * dy / m;\r\n    }\r\n}\r\nfunction renderLoop() {\r\n    try {\r\n        window.requestAnimationFrame(renderLoop);\r\n        const state = getState();\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_3__.render)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_4__.mainContext, state);\r\n    }\r\n    catch (e) {\r\n        console.log(e);\r\n        debugger;\r\n    }\r\n}\r\nrenderLoop();\r\nsetInterval(update, app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH);\r\n\n\n//# sourceURL=webpack://alttp/./app/client.ts?");

/***/ }),

/***/ "./app/constants.ts":
/*!**************************!*\
  !*** ./app/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_ATTACKS_PER_SECOND: () => (/* binding */ BASE_ATTACKS_PER_SECOND),\n/* harmony export */   BASE_BULLET_DURATION: () => (/* binding */ BASE_BULLET_DURATION),\n/* harmony export */   BASE_BULLET_RADIUS: () => (/* binding */ BASE_BULLET_RADIUS),\n/* harmony export */   BASE_BULLET_SPEED: () => (/* binding */ BASE_BULLET_SPEED),\n/* harmony export */   BASE_DROP_CHANCE: () => (/* binding */ BASE_DROP_CHANCE),\n/* harmony export */   BASE_ENEMY_BULLET_DURATION: () => (/* binding */ BASE_ENEMY_BULLET_DURATION),\n/* harmony export */   BASE_ENEMY_BULLET_RADIUS: () => (/* binding */ BASE_ENEMY_BULLET_RADIUS),\n/* harmony export */   BASE_ENEMY_SPEED: () => (/* binding */ BASE_ENEMY_SPEED),\n/* harmony export */   BASE_MAX_POTIONS: () => (/* binding */ BASE_MAX_POTIONS),\n/* harmony export */   BASE_WEAPON_DPS_PER_LEVEL: () => (/* binding */ BASE_WEAPON_DPS_PER_LEVEL),\n/* harmony export */   BASE_XP: () => (/* binding */ BASE_XP),\n/* harmony export */   CANVAS_HEIGHT: () => (/* binding */ CANVAS_HEIGHT),\n/* harmony export */   CANVAS_SCALE: () => (/* binding */ CANVAS_SCALE),\n/* harmony export */   CANVAS_WIDTH: () => (/* binding */ CANVAS_WIDTH),\n/* harmony export */   CELL_SIZE: () => (/* binding */ CELL_SIZE),\n/* harmony export */   FIELD_CENTER: () => (/* binding */ FIELD_CENTER),\n/* harmony export */   FRAME_LENGTH: () => (/* binding */ FRAME_LENGTH),\n/* harmony export */   GAME_KEY: () => (/* binding */ GAME_KEY),\n/* harmony export */   HERO_DAMAGE_FRAME_COUNT: () => (/* binding */ HERO_DAMAGE_FRAME_COUNT),\n/* harmony export */   SIGHT_RADIUS: () => (/* binding */ SIGHT_RADIUS),\n/* harmony export */   SLOT_PADDING: () => (/* binding */ SLOT_PADDING),\n/* harmony export */   SLOT_SIZE: () => (/* binding */ SLOT_SIZE)\n/* harmony export */ });\nconst FRAME_LENGTH = 20;\r\nconst CANVAS_WIDTH = 1000;\r\nconst CANVAS_HEIGHT = 800;\r\nconst CANVAS_SCALE = 1;\r\nconst SIGHT_RADIUS = 400;\r\nconst FIELD_CENTER = { x: SIGHT_RADIUS + 40, y: CANVAS_HEIGHT / 2 };\r\nconst SLOT_SIZE = 40;\r\nconst SLOT_PADDING = 10;\r\nconst GAME_KEY = {\r\n    MENU: 0,\r\n    UP: 1,\r\n    DOWN: 2,\r\n    LEFT: 3,\r\n    RIGHT: 4,\r\n    RUN: 5,\r\n    ACTIVATE: 6,\r\n    SELL: 7,\r\n    POTION: 8,\r\n    AIM_UP: 9,\r\n    AIM_DOWN: 10,\r\n    AIM_LEFT: 11,\r\n    AIM_RIGHT: 12,\r\n    SHOOT: 13,\r\n    SPECIAL_ATTACK: 14,\r\n};\r\nconst CELL_SIZE = 3000;\r\nconst BASE_DROP_CHANCE = 0.15;\r\nconst HERO_DAMAGE_FRAME_COUNT = 20;\r\nconst BASE_MAX_POTIONS = 5;\r\nconst BASE_XP = 10;\r\nconst BASE_ATTACKS_PER_SECOND = 2;\r\nconst BASE_WEAPON_DPS_PER_LEVEL = 40;\r\nconst BASE_BULLET_SPEED = 200;\r\nconst BASE_BULLET_RADIUS = 5;\r\nconst BASE_BULLET_DURATION = 1000;\r\nconst BASE_ENEMY_SPEED = 80;\r\nconst BASE_ENEMY_BULLET_RADIUS = 5;\r\nconst BASE_ENEMY_BULLET_DURATION = 1000;\r\n\n\n//# sourceURL=webpack://alttp/./app/constants.ts?");

/***/ }),

/***/ "./app/contextMenu.ts":
/*!****************************!*\
  !*** ./app/contextMenu.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextMenu: () => (/* binding */ ContextMenu),\n/* harmony export */   addContextMenuListeners: () => (/* binding */ addContextMenuListeners),\n/* harmony export */   getContextMenu: () => (/* binding */ getContextMenu),\n/* harmony export */   hideContextMenu: () => (/* binding */ hideContextMenu),\n/* harmony export */   showContextMenu: () => (/* binding */ showContextMenu)\n/* harmony export */ });\n/* harmony import */ var app_armor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/armor */ \"./app/armor.ts\");\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_utils_dungeon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/dungeon */ \"./app/utils/dungeon.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ContextMenu {\r\n    constructor(menuOptions) {\r\n        this.menuOptions = menuOptions;\r\n    }\r\n    /**\r\n        <div class=\"contextMenu\">\r\n            <div class=\"contextOption\">\r\n                Option 1\r\n            </div>\r\n            <div class=\"contextOption\">\r\n                Option 2\r\n            </div>\r\n        </div>\r\n    */\r\n    render(container, x, y) {\r\n        //this.domElement = createContextMenuElement(this.menuOptions);\r\n        this.container = container;\r\n        this.domElement = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_6__.tagElement)('div', 'contextMenu');\r\n        for (const option of this.menuOptions) {\r\n            const label = option.getLabel ? option.getLabel() : (option.label || ' ');\r\n            const optionElement = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_6__.tagElement)('div', 'contextOption', label);\r\n            if (option.onSelect) {\r\n                optionElement.onclick = function () {\r\n                    var _a;\r\n                    (_a = option.onSelect) === null || _a === void 0 ? void 0 : _a.call(option);\r\n                    hideContextMenu();\r\n                };\r\n            }\r\n            optionElement.addEventListener('mouseover', event => {\r\n                // Do nothing if this is the last element we hovered over.\r\n                if (this.hoveredOptionElement === optionElement) {\r\n                    return;\r\n                }\r\n                if (this.hoveredOptionElement) {\r\n                    this.hoveredOptionElement.classList.remove('open');\r\n                }\r\n                this.hoveredOptionElement = optionElement;\r\n                // If another child menu is being displayed, remove it when we hover\r\n                // over a new element at this level.\r\n                if (this.displayedChildMenu) {\r\n                    this.displayedChildMenu.remove();\r\n                }\r\n                const children = option.getChildren ? option.getChildren() : [];\r\n                if (children.length) {\r\n                    this.hoveredOptionElement.classList.add('open');\r\n                    this.displayedChildMenu = new ContextMenu(children);\r\n                    const limits = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_6__.getElementRect)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_5__.mainCanvas, this.container);\r\n                    const r = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_6__.getElementRect)(optionElement, this.container);\r\n                    this.displayedChildMenu.render(this.container, r.x + r.w, r.y);\r\n                    if (!this.displayedChildMenu.domElement) {\r\n                        return;\r\n                    }\r\n                    const r2 = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_6__.getElementRect)(this.displayedChildMenu.domElement, this.container);\r\n                    // If the menu is too low, move it up.\r\n                    const bottom = limits.y + limits.h;\r\n                    if (r2.y + r2.h > bottom) {\r\n                        this.displayedChildMenu.domElement.style.top = `${bottom - r2.h}px`;\r\n                    }\r\n                    // If the menu is too far to the right, display it entirely to the left\r\n                    // of the parent element.\r\n                    if (r2.x + r2.w > limits.x + limits.w) {\r\n                        this.displayedChildMenu.domElement.style.left = `${r.x - r2.w}px`;\r\n                    }\r\n                }\r\n            });\r\n            this.domElement.append(optionElement);\r\n        }\r\n        this.container.append(this.domElement);\r\n        this.domElement.style.left = `${x}px`;\r\n        this.domElement.style.top = `${y}px`;\r\n    }\r\n    remove() {\r\n        if (this.domElement) {\r\n            this.domElement.remove();\r\n            delete this.domElement;\r\n            if (this.displayedChildMenu) {\r\n                this.displayedChildMenu.remove();\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction getContextMenu(state) {\r\n    const options = [\r\n        {\r\n            label: 'Full Life',\r\n            onSelect() {\r\n                (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_7__.refillAllPotions)(state);\r\n            }\r\n        },\r\n        {\r\n            label: 'Set Hero Level',\r\n            getChildren() {\r\n                return [5, 10, 20, 30, 40, 50, 60, 70, 80, 90].map(level => ({\r\n                    label: `Lvl ${level}`,\r\n                    onSelect() {\r\n                        state.hero.level = level;\r\n                        state.hero.equipment.weapon = (0,app_loot__WEBPACK_IMPORTED_MODULE_3__.generateWeapon)(state.hero.equipment.weapon.weaponType, level);\r\n                        state.hero.equipment.armor = (0,app_loot__WEBPACK_IMPORTED_MODULE_3__.generateArmor)(state.hero.equipment.armor.armorType, level);\r\n                        for (const weaponType of app_weapons__WEBPACK_IMPORTED_MODULE_9__.weaponTypes) {\r\n                            const proficiency = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_7__.getWeaponProficiency)(state, weaponType);\r\n                            proficiency.level = level;\r\n                        }\r\n                        // Move hero to corresponding overworld area.\r\n                        if (level === 5) {\r\n                            state.hero.overworldY = -app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE * 3;\r\n                        }\r\n                        else {\r\n                            state.hero.overworldY = -app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE * (3 + 2 * Math.floor(level / 10));\r\n                        }\r\n                        if (!state.dungeon) {\r\n                            state.hero.y = state.hero.overworldY;\r\n                        }\r\n                        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_7__.setDerivedHeroStats)(state);\r\n                    }\r\n                }));\r\n            },\r\n        },\r\n        {\r\n            label: 'Test Dungeon',\r\n            getChildren() {\r\n                return app_utils_dungeon__WEBPACK_IMPORTED_MODULE_2__.dungeonTypes.map(dungeonType => ({\r\n                    label: dungeonType,\r\n                    onSelect() {\r\n                        const dungeon = (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_2__.createDungeon)(dungeonType, state.hero.level);\r\n                        (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_2__.startDungeon)(state, dungeon);\r\n                    }\r\n                }));\r\n            },\r\n        },\r\n        {\r\n            label: 'Set Weapon',\r\n            getChildren() {\r\n                return app_weapons__WEBPACK_IMPORTED_MODULE_9__.weaponTypes.map(weaponType => ({\r\n                    label: weaponType,\r\n                    onSelect() {\r\n                        state.hero.equipment.weapon = (0,app_loot__WEBPACK_IMPORTED_MODULE_3__.generateWeapon)(weaponType, state.hero.level);\r\n                        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_7__.setDerivedHeroStats)(state);\r\n                    }\r\n                }));\r\n            },\r\n        },\r\n        {\r\n            label: 'Set Armor',\r\n            getChildren() {\r\n                return app_armor__WEBPACK_IMPORTED_MODULE_0__.armorTypes.map(armorType => ({\r\n                    label: armorType,\r\n                    onSelect() {\r\n                        state.hero.equipment.armor = (0,app_loot__WEBPACK_IMPORTED_MODULE_3__.generateArmor)(armorType, state.hero.level);\r\n                        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_7__.setDerivedHeroStats)(state);\r\n                    }\r\n                }));\r\n            },\r\n        },\r\n    ];\r\n    return options;\r\n}\r\nconst contextMenuState = {\r\n    contextMenu: undefined\r\n};\r\nfunction showContextMenu(menu, x, y) {\r\n    hideContextMenu();\r\n    const container = document.body;\r\n    contextMenuState.contextMenu = new ContextMenu(menu);\r\n    contextMenuState.contextMenu.render(container, x, y);\r\n    if (!contextMenuState.contextMenu.domElement) {\r\n        return;\r\n    }\r\n    const limits = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_6__.getElementRect)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_5__.mainCanvas, container);\r\n    const r = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_6__.getElementRect)(contextMenuState.contextMenu.domElement, container);\r\n    const bottom = limits.y + limits.h;\r\n    const right = limits.x + limits.w;\r\n    if (r.y + r.h > bottom) {\r\n        contextMenuState.contextMenu.domElement.style.top = `${bottom - r.h}px`;\r\n    }\r\n    // If the menu is too far to the right, display it entirely to the left\r\n    // of the parent element.\r\n    if (r.x + r.w > right) {\r\n        contextMenuState.contextMenu.domElement.style.left = `${right - r.w}px`;\r\n    }\r\n}\r\nfunction hideContextMenu() {\r\n    if (contextMenuState.contextMenu) {\r\n        contextMenuState.contextMenu.remove();\r\n        delete contextMenuState.contextMenu;\r\n    }\r\n}\r\nfunction addContextMenuListeners(state) {\r\n    document.addEventListener('mouseup', function (event) {\r\n        if (event.which !== 1) {\r\n            return;\r\n        }\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.KEY.CONTROL)) {\r\n            event.preventDefault();\r\n            const [x, y] = (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_8__.getMousePosition)();\r\n            (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_8__.getMousePosition)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_5__.mainCanvas, app_constants__WEBPACK_IMPORTED_MODULE_1__.CANVAS_SCALE);\r\n            const menu = getContextMenu(state);\r\n            showContextMenu(menu, x, y);\r\n        }\r\n        else if (!event.target.closest('.contextMenu')) {\r\n            hideContextMenu();\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/contextMenu.ts?");

/***/ }),

/***/ "./app/enchantments.ts":
/*!*****************************!*\
  !*** ./app/enchantments.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyEnchantmentToEquipment: () => (/* binding */ applyEnchantmentToEquipment),\n/* harmony export */   applyEnchantmentToStats: () => (/* binding */ applyEnchantmentToStats),\n/* harmony export */   applyEnchantmentsToStats: () => (/* binding */ applyEnchantmentsToStats),\n/* harmony export */   enchantmentStatLabels: () => (/* binding */ enchantmentStatLabels),\n/* harmony export */   enchantmentStatScale: () => (/* binding */ enchantmentStatScale),\n/* harmony export */   enchantmentStrengthLabels: () => (/* binding */ enchantmentStrengthLabels),\n/* harmony export */   getEnchantmentBonusText: () => (/* binding */ getEnchantmentBonusText),\n/* harmony export */   getEnchantmentPercentValue: () => (/* binding */ getEnchantmentPercentValue),\n/* harmony export */   getInsightEnchantment: () => (/* binding */ getInsightEnchantment),\n/* harmony export */   getPowerEnchantment: () => (/* binding */ getPowerEnchantment),\n/* harmony export */   getSpeedEnchantment: () => (/* binding */ getSpeedEnchantment),\n/* harmony export */   getVigorEnchantment: () => (/* binding */ getVigorEnchantment)\n/* harmony export */ });\nconst enchantmentStrengthLabels = [\r\n    'Failed',\r\n    'Weak',\r\n    'Minor',\r\n    'Major',\r\n    'Great',\r\n    'Perfect',\r\n];\r\nconst enchantmentStatLabels = {\r\n    'attackSpeed': 'Attack Speed',\r\n    'critChance': 'Critical Strike Chance',\r\n    'critDamage': 'Critical Strike Damage',\r\n    'damage': 'Damage',\r\n    'speed': 'Movement Speed',\r\n    'life': 'Life',\r\n    'armor': 'Armor',\r\n    'potionEffect': 'Effect of Potions',\r\n};\r\nconst enchantmentStatScale = {\r\n    'attackSpeed': 0.5,\r\n    'critChance': 0.2,\r\n    'critDamage': 1.0,\r\n    'damage': 1.0,\r\n    'speed': 0.3,\r\n    'life': 0.5,\r\n    'armor': 0.5,\r\n    'potionEffect': 1,\r\n};\r\nfunction getEnchantmentStrength(level) {\r\n    if (level >= 80) {\r\n        return 5;\r\n    }\r\n    if (level >= 50) {\r\n        return 4;\r\n    }\r\n    if (level >= 30) {\r\n        return 3;\r\n    }\r\n    if (level >= 15) {\r\n        return 2;\r\n    }\r\n    return 1;\r\n}\r\nfunction applyEnchantmentsToStats(state) {\r\n    var _a, _b;\r\n    for (const enchantment of state.hero.equipment.weapon.enchantmentSlots) {\r\n        applyEnchantmentToStats(state, enchantment);\r\n    }\r\n    for (const enchantment of ((_b = (_a = state.hero.equipment.armor) === null || _a === void 0 ? void 0 : _a.enchantmentSlots) !== null && _b !== void 0 ? _b : [])) {\r\n        applyEnchantmentToStats(state, enchantment);\r\n    }\r\n}\r\nfunction applyEnchantmentToStats(state, enchantment) {\r\n    if (enchantment.enchantmentType === 'empty') {\r\n        return;\r\n    }\r\n    const effect = enchantment.value * enchantmentStatScale[enchantment.enchantmentType] / 100;\r\n    switch (enchantment.enchantmentType) {\r\n        case 'attackSpeed':\r\n            state.hero.attacksPerSecond *= (1 + effect);\r\n            return;\r\n        case 'damage':\r\n            state.hero.damage *= (1 + effect);\r\n            return;\r\n        case 'critChance':\r\n            state.hero.critChance += effect;\r\n            return;\r\n        case 'critDamage':\r\n            state.hero.critDamage += effect;\r\n            return;\r\n        case 'life':\r\n            state.hero.maxLife = Math.round(state.hero.maxLife * (1 + effect));\r\n            return;\r\n        case 'armor':\r\n            state.hero.armor = Math.round(state.hero.armor * (1 + effect));\r\n            return;\r\n        case 'speed':\r\n            state.hero.speed *= (1 + effect);\r\n            return;\r\n        case 'potionEffect':\r\n            state.hero.potionEffect *= (1 + effect);\r\n            return;\r\n    }\r\n}\r\nfunction getEnchantmentPercentValue(enchantmentType, value) {\r\n    return Math.floor(value * enchantmentStatScale[enchantmentType]) + '%';\r\n}\r\nfunction getEnchantmentBonusText(enchantmentType, value, value2) {\r\n    let text = getEnchantmentPercentValue(enchantmentType, value);\r\n    if (value2) {\r\n        text += ' to ' + getEnchantmentPercentValue(enchantmentType, value2);\r\n    }\r\n    text += ' increased ' + enchantmentStatLabels[enchantmentType];\r\n    return text;\r\n}\r\nfunction applyEnchantmentToEquipment(enchantment, item) {\r\n    const enchantmentType = item.type === 'weapon'\r\n        ? enchantment.weaponEnchantmentType\r\n        : enchantment.armorEnchantmentType;\r\n    for (const slot of item.enchantmentSlots) {\r\n        if (slot.enchantmentType === 'empty') {\r\n            slot.enchantmentType = enchantmentType;\r\n            slot.value = 10 * enchantment.strength;\r\n            return true;\r\n        }\r\n        if (slot.enchantmentType === enchantmentType) {\r\n            if (slot.value < 10 * enchantment.strength) {\r\n                slot.value = 10 * enchantment.strength;\r\n                return true;\r\n            }\r\n            else if (slot.value < 20 * enchantment.strength) {\r\n                slot.value = Math.min(slot.value + enchantment.strength, 20 * enchantment.strength);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction getSpeedEnchantment(level) {\r\n    return {\r\n        type: 'enchantment',\r\n        name: 'Speed',\r\n        level,\r\n        weaponEnchantmentType: 'attackSpeed',\r\n        armorEnchantmentType: 'speed',\r\n        strength: getEnchantmentStrength(level),\r\n    };\r\n}\r\nfunction getPowerEnchantment(level) {\r\n    return {\r\n        type: 'enchantment',\r\n        name: 'Power',\r\n        level,\r\n        weaponEnchantmentType: 'damage',\r\n        armorEnchantmentType: 'armor',\r\n        strength: getEnchantmentStrength(level),\r\n    };\r\n}\r\nfunction getVigorEnchantment(level) {\r\n    return {\r\n        type: 'enchantment',\r\n        name: 'Vigor',\r\n        level,\r\n        weaponEnchantmentType: 'critDamage',\r\n        armorEnchantmentType: 'life',\r\n        strength: getEnchantmentStrength(level),\r\n    };\r\n}\r\nfunction getInsightEnchantment(level) {\r\n    return {\r\n        type: 'enchantment',\r\n        name: 'Insight',\r\n        level,\r\n        weaponEnchantmentType: 'critChance',\r\n        armorEnchantmentType: 'potionEffect',\r\n        strength: getEnchantmentStrength(level),\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/enchantments.ts?");

/***/ }),

/***/ "./app/enemies/bat.ts":
/*!****************************!*\
  !*** ./app/enemies/bat.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bat: () => (/* binding */ bat)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n\r\n\r\n\r\n\r\nfunction updateSonarBullet(state, bullet) {\r\n    const amplitude = Math.min(50, bullet.time / 30);\r\n    if (bullet.amplitude < 0) {\r\n        bullet.amplitude = -amplitude;\r\n    }\r\n    else {\r\n        bullet.amplitude = amplitude;\r\n    }\r\n    (0,app_weapons__WEBPACK_IMPORTED_MODULE_3__.updateSimpleBullet)(state, bullet);\r\n}\r\nconst bat = {\r\n    name: 'Bat',\r\n    statFactors: {\r\n        armor: 2,\r\n        damage: 0.75,\r\n        speed: 0.3,\r\n    },\r\n    initialParams: {},\r\n    radius: 20,\r\n    portalChance: 0.05,\r\n    portalDungeonType: 'cave',\r\n    update(state, enemy) {\r\n        const aggroRadius = 300;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        const isAggro = distance2 <= aggroRadius * aggroRadius;\r\n        if (isAggro) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.turnTowardsTarget)(state, enemy, state.hero);\r\n            // Try to stay a certain distance from the player.\r\n            if (distance2 <= 190 * 190) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInDirection)(state, enemy, Math.atan2(y, x));\r\n            }\r\n            else if (distance2 >= 210 * 210) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInDirection)(state, enemy, Math.atan2(y, x) + Math.PI);\r\n            }\r\n        }\r\n        else {\r\n            if (enemy.mode === 'choose') {\r\n                if (enemy.modeTime >= 200) {\r\n                    enemy.theta = Math.random() * 2 * Math.PI;\r\n                    enemy.setMode('move');\r\n                }\r\n            }\r\n            else if (enemy.mode === 'move') {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInDirection)(state, enemy);\r\n                if (enemy.modeTime >= 600) {\r\n                    enemy.setMode('choose');\r\n                }\r\n            }\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            if (isAggro) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootEnemyBullet)(state, enemy, 60 * Math.cos(enemy.theta), 60 * Math.sin(enemy.theta), {\r\n                    expirationTime: state.fieldTime + 2000, amplitude: 10, frequency: 6,\r\n                    update: updateSonarBullet,\r\n                });\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootEnemyBullet)(state, enemy, 60 * Math.cos(enemy.theta), 60 * Math.sin(enemy.theta), {\r\n                    expirationTime: state.fieldTime + 2000, amplitude: -10, frequency: 6,\r\n                    update: updateSonarBullet,\r\n                });\r\n            }\r\n            else {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletAtHero)(state, enemy, 120, { amplitude: 20, frequency: 5 });\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletAtHero)(state, enemy, 120, { amplitude: -20, frequency: 5 });\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x + 0.25 * enemy.radius * Math.cos(enemy.theta),\r\n            y: enemy.y + 0.25 * enemy.radius * Math.sin(enemy.theta),\r\n            radius: enemy.radius / 5,\r\n        }, enemy.baseColor);\r\n        context.save();\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.translate(enemy.x, enemy.y);\r\n        context.rotate(enemy.theta);\r\n        // left wing\r\n        context.moveTo(enemy.radius / 4, 0);\r\n        context.arcTo(enemy.radius / 4, enemy.radius, enemy.radius * Math.cos(Math.PI / 6), enemy.radius * Math.sin(Math.PI / 6), enemy.radius / 2);\r\n        context.arc(0, 0, enemy.radius, Math.PI / 6, 2 * Math.PI / 3);\r\n        //context.lineTo(enemy.radius * Math.cos(4 * Math.PI / 3), enemy.radius * Math.sin(4 * Math.PI / 3))\r\n        // Bottom arcs\r\n        context.lineTo(-enemy.radius / 4, enemy.radius / 2);\r\n        context.lineTo(enemy.radius / 2 * Math.cos(5 * Math.PI / 6), enemy.radius / 2 * Math.sin(5 * Math.PI / 6));\r\n        context.lineTo(-enemy.radius / 4, 0);\r\n        context.lineTo(enemy.radius / 2 * Math.cos(7 * Math.PI / 6), enemy.radius / 2 * Math.sin(7 * Math.PI / 6));\r\n        context.lineTo(-enemy.radius / 4, -enemy.radius / 2);\r\n        context.lineTo(enemy.radius / 2 * Math.cos(4 * Math.PI / 3), enemy.radius / 2 * Math.sin(4 * Math.PI / 3));\r\n        // This seems like it should work, but it looks terrible for some reason\r\n        /*context.arcTo(\r\n            -enemy.radius / 4, enemy.radius / 2,\r\n            enemy.radius / 2 * Math.cos(5 * Math.PI / 6), enemy.radius / 2 * Math.sin(5 * Math.PI / 6),\r\n            enemy.radius / 6\r\n        );\r\n        context.arcTo(\r\n            -enemy.radius / 4, 0,\r\n            enemy.radius / 2 * Math.cos(7 * Math.PI / 6), enemy.radius / 2 * Math.sin(7 * Math.PI / 6),\r\n            enemy.radius / 6\r\n        );\r\n        context.arcTo(\r\n            -enemy.radius / 4, -enemy.radius / 2,\r\n            enemy.radius / 2 * Math.cos(4 * Math.PI / 3), enemy.radius / 2 * Math.sin(4 * Math.PI / 3),\r\n            enemy.radius / 6\r\n        );*/\r\n        // right wing\r\n        context.arc(0, 0, enemy.radius, 4 * Math.PI / 3, 11 * Math.PI / 6);\r\n        context.arcTo(enemy.radius / 4, -enemy.radius, enemy.radius / 4, 0, enemy.radius / 2);\r\n        context.fill();\r\n        context.restore();\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/bat.ts?");

/***/ }),

/***/ "./app/enemies/chaser.ts":
/*!*******************************!*\
  !*** ./app/enemies/chaser.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chaser: () => (/* binding */ chaser)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst chaser = {\r\n    name: 'Chaser',\r\n    statFactors: {\r\n        maxLife: 1,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n    },\r\n    initialParams: {},\r\n    radius: 20,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const aggroRadius = 600;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        enemy.x += enemy.speed * Math.cos(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.y += enemy.speed * Math.sin(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta), 100 * Math.sin(enemy.theta));\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/chaser.ts?");

/***/ }),

/***/ "./app/enemies/chest.ts":
/*!******************************!*\
  !*** ./app/enemies/chest.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chest: () => (/* binding */ chest)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n\r\nconst chest = {\r\n    name: 'Chest',\r\n    statFactors: {},\r\n    initialParams: {},\r\n    dropChance: 1,\r\n    experienceFactor: 0,\r\n    radius: 25,\r\n    update(state, enemy) {\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { ...enemy, radius: 20 }, 'pink');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { ...enemy, radius: 6 }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/chest.ts?");

/***/ }),

/***/ "./app/enemies/circler.ts":
/*!********************************!*\
  !*** ./app/enemies/circler.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circler: () => (/* binding */ circler)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst circler = {\r\n    name: 'Circler',\r\n    statFactors: {\r\n        maxLife: 1,\r\n        damage: 1,\r\n        armor: 0,\r\n        attacksPerSecond: 2,\r\n        speed: 0.6,\r\n    },\r\n    initialParams: {},\r\n    radius: 20,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const aggroRadius = 200;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        let targetTheta = enemy.theta;\r\n        if (distance2 < aggroRadius * aggroRadius) {\r\n            // Face the player, to shoot at them and circle them.\r\n            targetTheta = Math.atan2(y, x);\r\n            if (distance2 > 100 * 100) {\r\n                targetTheta -= Math.PI / 12;\r\n            }\r\n        }\r\n        else {\r\n            // Face the disc to shoot around it and circle it.\r\n            const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n            targetTheta = Math.atan2(y, x);\r\n            // Curve towards the center of the disc when too far out.\r\n            if (distance2 > enemy.disc.radius * enemy.disc.radius / 4) {\r\n                targetTheta -= Math.PI / 12;\r\n            }\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, targetTheta);\r\n        // Note this enemy moves sideways.\r\n        enemy.x += enemy.speed * Math.cos(enemy.theta + Math.PI / 2) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.y += enemy.speed * Math.sin(enemy.theta + Math.PI / 2) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta), 100 * Math.sin(enemy.theta));\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta + Math.PI), 100 * Math.sin(enemy.theta + Math.PI));\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 10 * Math.cos(enemy.theta),\r\n            y: enemy.y + 10 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 10 * Math.cos(enemy.theta + Math.PI),\r\n            y: enemy.y + 10 * Math.sin(enemy.theta + Math.PI),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/circler.ts?");

/***/ }),

/***/ "./app/enemies/clam.ts":
/*!*****************************!*\
  !*** ./app/enemies/clam.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clam: () => (/* binding */ clam),\n/* harmony export */   giantClam: () => (/* binding */ giantClam)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n\r\n\r\n\r\n\r\nconst clam = {\r\n    name: 'Clam',\r\n    statFactors: {\r\n        attacksPerSecond: 2,\r\n        maxLife: 2,\r\n        armor: 5,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE,\r\n    experienceFactor: 2,\r\n    radius: 30,\r\n    portalChance: 0.2,\r\n    portalDungeonType: 'reef',\r\n    update(state, enemy) {\r\n        if (enemy.mode === 'closed' || enemy.mode === 'choose') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.turnTowardsTarget)(state, enemy, state.hero);\r\n            enemy.mode = 'closed';\r\n            enemy.armor = enemy.baseArmor * 10;\r\n            return;\r\n        }\r\n        else {\r\n            enemy.armor = enemy.baseArmor / 10;\r\n        }\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.turnTowardsTarget)(state, enemy, state.hero, 0.1);\r\n        if (enemy.mode === 'opening') {\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, 120, { radius: 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS });\r\n            }\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('open');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'closing') {\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('closed');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletArc)(state, enemy, enemy.theta, Math.PI, 7, 100);\r\n        }\r\n        if (enemy.modeTime >= 2000) {\r\n            enemy.setMode('closing');\r\n        }\r\n    },\r\n    onHit(state, enemy) {\r\n        if (enemy.mode === 'closed' && enemy.modeTime >= 500) {\r\n            enemy.setMode('opening');\r\n        }\r\n    },\r\n    render: renderClam,\r\n};\r\nconst giantClam = {\r\n    ...clam,\r\n    name: 'Giant Clam',\r\n    statFactors: {\r\n        attacksPerSecond: 2,\r\n        maxLife: 5,\r\n        armor: 5,\r\n    },\r\n    dropChance: 1,\r\n    experienceFactor: 20,\r\n    radius: 50,\r\n    portalChance: 0,\r\n    update(state, enemy) {\r\n        // Constantly shoots small novas to hurt players that get too close.\r\n        if (state.fieldTime % 200 === 0) {\r\n            const healthPercentage = (enemy.maxLife - enemy.life) / enemy.maxLife;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootCirclingBullet)(state, enemy, 0, enemy.radius + 5 * Math.floor(healthPercentage * 10));\r\n            //const even = (state.fieldTime % 1000) === 0;\r\n            //shootBulletCircle(state, enemy, even ? 0 : Math.PI / 20, 20, 40, {expirationTime: state.fieldTime + 600});\r\n        }\r\n        if (enemy.mode === 'closed' || enemy.mode === 'choose') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.turnTowardsTarget)(state, enemy, state.hero);\r\n            enemy.mode = 'closed';\r\n            enemy.armor = enemy.baseArmor * 10;\r\n            return;\r\n        }\r\n        else {\r\n            enemy.armor = enemy.baseArmor / 10;\r\n        }\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.turnTowardsTarget)(state, enemy, state.hero, 0.1);\r\n        if (enemy.mode === 'opening') {\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletArc)(state, enemy, enemy.theta, Math.PI / 3, 3, 120, { radius: 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS, damage: 2 * enemy.damage });\r\n            }\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('open');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'closing') {\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('closed');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.life <= enemy.maxLife / 2) {\r\n            if (state.fieldTime % 200 === 0) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, 120, { radius: 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS });\r\n            }\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletArc)(state, enemy, enemy.theta, Math.PI, 7, 100, { expirationTime: state.fieldTime + 2000 });\r\n        }\r\n        if (enemy.modeTime >= 2000) {\r\n            enemy.setMode('closing');\r\n        }\r\n    },\r\n    getEnchantment(state, enemy) {\r\n        return (0,app_enchantments__WEBPACK_IMPORTED_MODULE_1__.getPowerEnchantment)(enemy.level);\r\n    },\r\n};\r\nfunction renderClam(context, state, enemy) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, enemy, 'black');\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, { ...enemy, radius: 5 }, enemy.baseColor);\r\n    context.save();\r\n    context.translate(enemy.x, enemy.y);\r\n    context.rotate(enemy.theta);\r\n    context.fillStyle = enemy.baseColor;\r\n    if (enemy.mode === 'opening' || enemy.mode === 'closing') {\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.arc(0, 0, enemy.radius, Math.PI / 2, 3 * Math.PI / 2);\r\n        if ((enemy.modeTime >= 200 && enemy.mode === 'closing') || (enemy.modeTime <= 200 && enemy.mode === 'opening')) {\r\n            context.arc(-enemy.radius, 0, Math.sqrt(2) * enemy.radius, 5 * Math.PI / 3, 1 * Math.PI / 3, false);\r\n        }\r\n        else {\r\n            context.lineTo(0, -enemy.radius);\r\n        }\r\n        context.fill();\r\n    }\r\n    else if (enemy.mode === 'open') {\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.arc(0, 0, enemy.radius, Math.PI / 2, 3 * Math.PI / 2);\r\n        context.arc(enemy.radius, 0, Math.sqrt(2) * enemy.radius, 4 * Math.PI / 3, 2 * Math.PI / 3, true);\r\n        context.fill();\r\n    }\r\n    else {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, { ...enemy, x: 0, y: 0 }, enemy.baseColor);\r\n    }\r\n    /*let p = 1\r\n    if (enemy.mode === 'opening') {\r\n        p = Math.max(0.2, 1 - enemy.modeTime / 1000);\r\n    } else if (enemy.mode === 'closing') {\r\n        p = Math.min(1, 0.2 + enemy.modeTime / 1000);\r\n    } else if (enemy.mode === 'open') {\r\n        p = 0.2;\r\n    }\r\n    const drawArc = (p: number) => {\r\n        if (p === 0.5) {\r\n            context.lineTo(0, -enemy.radius);\r\n        } else if (p < 0.5) {\r\n            const x =\r\n        }\r\n    }\r\n    // Fill in the shell cover\r\n    context.fillStyle = enemy.baseColor;\r\n    context.beginPath();\r\n    context.arc(0, 0, enemy.radius, Math.PI / 2,  3 * Math.PI / 2);\r\n    drawArc(p);\r\n    context.fill();\r\n    // Draw lines across the shell\r\n    */\r\n    context.restore();\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/clam.ts?");

/***/ }),

/***/ "./app/enemies/crab.ts":
/*!*****************************!*\
  !*** ./app/enemies/crab.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crab: () => (/* binding */ crab)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n\r\n\r\n\r\n\r\n\r\nconst crab = {\r\n    name: 'Crab',\r\n    statFactors: {\r\n        attacksPerSecond: 1,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE,\r\n    experienceFactor: 2,\r\n    radius: 25,\r\n    update(state, enemy) {\r\n        const aggroRadius = 400;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        const isAggro = distance2 <= aggroRadius * aggroRadius;\r\n        if (enemy.mode === 'choose') {\r\n            enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_4__[\"default\"].element(['moveLeft', 'moveRight', 'pause', 'pause']));\r\n            /*if (isAggro) {\r\n                if (y < 30) {\r\n                    enemy.setMode('moveUp');\r\n                } else {\r\n                    enemy.setMode(Random.element(['moveLeft', 'moveRight', 'pause']));\r\n                }\r\n            } else {\r\n                enemy.setMode(Random.element(['moveUp', 'moveDown', 'moveLeft', 'moveRight', 'pause', 'pause']));\r\n            }*/\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveUp') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, -Math.PI / 2, enemy.speed / 2);\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('choose');\r\n            }\r\n            if (isAggro && enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 100, { radius: 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS, damage: 2 * enemy.damage });\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveDown') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, Math.PI / 2, enemy.speed / 2);\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveLeft') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, Math.PI, 1.1 * enemy.speed);\r\n            if (enemy.x < enemy.disc.x && (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.isEnemyOffDisc)(state, enemy)) {\r\n                enemy.mode = 'moveRight';\r\n            }\r\n        }\r\n        if (enemy.mode === 'moveRight') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, 0, 1.1 * enemy.speed);\r\n            if (enemy.x > enemy.disc.x && (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.isEnemyOffDisc)(state, enemy)) {\r\n                enemy.mode = 'moveLeft';\r\n            }\r\n        }\r\n        if (enemy.mode === 'pause') {\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n        if (enemy.modeTime % 500 === 0) {\r\n            const expirationTime = state.fieldTime + 500;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, 0, Math.PI / 8, 3, enemy.mode === 'moveRight' ? 150 : 100, { expirationTime });\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, Math.PI, Math.PI / 8, 3, enemy.mode === 'moveLeft' ? 150 : 100, { expirationTime });\r\n        }\r\n        if (isAggro && enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            //shootEnemyBullet(state, enemy, 100, 0);\r\n            //shootEnemyBullet(state, enemy, -100, 0);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 100, { radius: 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS, damage: 2 * enemy.damage });\r\n        }\r\n        if (enemy.modeTime >= 1000) {\r\n            enemy.setMode('choose');\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, enemy.baseColor);\r\n        /*fillCircle(context, {\r\n            x: enemy.x + 16 * Math.cos(Math.PI / 2),\r\n            y: enemy.y + 16 * Math.sin(Math.PI / 2),\r\n            radius: 3,\r\n        }, 'black');\r\n        fillCircle(context, {\r\n            x: enemy.x + 16 * Math.cos(Math.PI / 6),\r\n            y: enemy.y + 16 * Math.sin(Math.PI / 6),\r\n            radius: 3,\r\n        }, 'black');\r\n        fillCircle(context, {\r\n            x: enemy.x + 16 * Math.cos(5 * Math.PI / 6),\r\n            y: enemy.y + 16 * Math.sin(5 * Math.PI / 6),\r\n            radius: 3,\r\n        }, 'black');*/\r\n        context.strokeStyle = 'black';\r\n        context.beginPath();\r\n        context.lineWidth = 2;\r\n        for (let i = 0; i < 2; i++) {\r\n            const theta = Math.PI * i;\r\n            const dx = Math.cos(theta), dy = Math.sin(theta);\r\n            context.moveTo(enemy.x + 5 * dx, enemy.y + 5 * dy - 4);\r\n            context.lineTo(enemy.x + 23 * dx, enemy.y + 23 * dy - 8);\r\n            context.moveTo(enemy.x + 5 * dx, enemy.y + 5 * dy);\r\n            context.lineTo(enemy.x + 23 * dx, enemy.y + 23 * dy);\r\n            context.moveTo(enemy.x + 5 * dx, enemy.y + 5 * dy + 4);\r\n            context.lineTo(enemy.x + 23 * dx, enemy.y + 23 * dy + 8);\r\n        }\r\n        context.stroke();\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/crab.ts?");

/***/ }),

/***/ "./app/enemies/lord.ts":
/*!*****************************!*\
  !*** ./app/enemies/lord.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lord: () => (/* binding */ lord),\n/* harmony export */   lordsMinion: () => (/* binding */ lordsMinion)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst lord = {\r\n    name: 'Lord',\r\n    statFactors: {\r\n        maxLife: 2.5,\r\n        damage: 1,\r\n        attacksPerSecond: 0.4,\r\n        speed: 0.4,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE,\r\n    experienceFactor: 5,\r\n    radius: 20,\r\n    portalChance: 0.2,\r\n    portalDungeonType: 'tree',\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const aggroRadius = 600;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        enemy.x += enemy.speed * Math.cos(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.y += enemy.speed * Math.sin(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.minions = enemy.minions.filter(m => m.life > 0);\r\n        const maxMinions = Math.min(5, 2 + Math.floor(enemy.level / 3));\r\n        if (enemy.attackCooldown <= state.fieldTime && enemy.minions.length < maxMinions) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            for (const theta of [enemy.theta + Math.PI / 2, enemy.theta - Math.PI / 2]) {\r\n                const minion = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.createEnemy)(enemy.x + enemy.radius * Math.cos(theta), enemy.y + enemy.radius * Math.sin(theta), lordsMinion, enemy.level, enemy.disc);\r\n                minion.theta = theta;\r\n                enemy.minions.push(minion);\r\n                minion.master = enemy;\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\nfunction turnTowardsTarget(state, enemy, target) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, target);\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n}\r\nconst lordsMinion = {\r\n    name: 'Peasant',\r\n    statFactors: {\r\n        maxLife: 0.5,\r\n        armor: 0,\r\n        attacksPerSecond: 0.5,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 0,\r\n    experienceFactor: 0.1,\r\n    radius: 15,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const master = enemy.master && enemy.master.life > 0 ? enemy.master : undefined;\r\n        const aggroRadius = 400;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 <= aggroRadius * aggroRadius) {\r\n            // Leash back to master for a bit after attacking.\r\n            if (master && enemy.attackCooldown - state.fieldTime > 400) {\r\n                // Enemy moves in its current direction unless it gets too far from the master.\r\n                const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, master);\r\n                if (distance2 >= 300 * 300) {\r\n                    turnTowardsTarget(state, enemy, master);\r\n                }\r\n            }\r\n            else {\r\n                // Chase the player when it can attack soon.\r\n                turnTowardsTarget(state, enemy, state.hero);\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInCurrentDirection)(state, enemy);\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta), 100 * Math.sin(enemy.theta));\r\n            }\r\n        }\r\n        else if (master) {\r\n            // Enemy moves in its current direction unless it gets too far from the master.\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, master);\r\n            if (distance2 >= 200 * 200) {\r\n                turnTowardsTarget(state, enemy, master);\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInCurrentDirection)(state, enemy);\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 12 * Math.cos(enemy.theta),\r\n            y: enemy.y + 12 * Math.sin(enemy.theta),\r\n            radius: 2,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 2,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/lord.ts?");

/***/ }),

/***/ "./app/enemies/slime.ts":
/*!******************************!*\
  !*** ./app/enemies/slime.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   greatSlime: () => (/* binding */ greatSlime),\n/* harmony export */   megaSlime: () => (/* binding */ megaSlime),\n/* harmony export */   miniSlime: () => (/* binding */ miniSlime),\n/* harmony export */   slime: () => (/* binding */ slime)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n\r\n\r\n\r\n\r\nconst slime = {\r\n    name: 'Slime',\r\n    statFactors: {\r\n        attacksPerSecond: 0.5,\r\n        maxLife: 1.6,\r\n        armor: 0,\r\n    },\r\n    initialParams: {},\r\n    dropChance: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE,\r\n    experienceFactor: 2,\r\n    radius: 24,\r\n    portalChance: 0.1,\r\n    portalDungeonType: 'cave',\r\n    update(state, enemy) {\r\n        updateSlimeMovement(state, enemy);\r\n    },\r\n    onDeath(state, enemy) {\r\n        const count = Math.round(2 + Math.random());\r\n        for (let i = 0; i < count; i++) {\r\n            const theta = state.fieldTime / 500 + i * 2 * Math.PI / count;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(enemy.x + enemy.radius * Math.cos(theta), enemy.y + enemy.radius * Math.sin(theta), miniSlime, enemy.level, enemy.disc);\r\n        }\r\n    },\r\n    onHit(state, enemy) {\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 12, 120);\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, enemy, 'black');\r\n        const count = Math.max(3, Math.ceil((enemy.radius - 8) / 8));\r\n        for (let i = 0; i < count; i++) {\r\n            const theta = state.fieldTime / 4000 + i * 2 * Math.PI / count;\r\n            const p = (1 + Math.sin(state.fieldTime / 500 + i * 2 * Math.PI / 3)) / 2;\r\n            const maxDistance = enemy.radius / 4;\r\n            const minDistance = enemy.radius / 10;\r\n            const distance = minDistance + p * (maxDistance - minDistance);\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, {\r\n                x: enemy.x + distance * Math.cos(theta),\r\n                y: enemy.y + distance * Math.sin(theta),\r\n                radius: 3 * enemy.radius / 4\r\n            }, enemy.baseColor);\r\n        }\r\n    }\r\n};\r\nfunction updateSlimeMovement(state, enemy) {\r\n    if (enemy.mode === 'choose') {\r\n        if (enemy.modeTime > 400) {\r\n            enemy.theta = Math.random() * 2 * Math.PI;\r\n            enemy.vx = 200 * Math.cos(enemy.theta);\r\n            enemy.vy = 200 * Math.sin(enemy.theta);\r\n            enemy.setMode('dash');\r\n        }\r\n    }\r\n    if (enemy.mode === 'dash') {\r\n        enemy.x += enemy.vx * app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH / 1000;\r\n        enemy.y += enemy.vy * app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH / 1000;\r\n        enemy.vx *= 0.97;\r\n        enemy.vy *= 0.97;\r\n        if (enemy.modeTime >= enemy.radius * 40) {\r\n            enemy.setMode('choose');\r\n        }\r\n    }\r\n}\r\nconst greatSlime = {\r\n    ...slime,\r\n    name: 'Great Slime',\r\n    statFactors: {\r\n        attacksPerSecond: 0.5,\r\n        maxLife: 2.4,\r\n        damage: 1.5,\r\n        armor: 0,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE,\r\n    portalChance: 0,\r\n    experienceFactor: 2,\r\n    radius: 32,\r\n    onDeath(state, enemy) {\r\n        const count = 2;\r\n        for (let i = 0; i < count; i++) {\r\n            const theta = state.fieldTime / 500 + i * 2 * Math.PI / count;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(enemy.x + enemy.radius * Math.cos(theta), enemy.y + enemy.radius * Math.sin(theta), slime, enemy.level, enemy.disc);\r\n        }\r\n    },\r\n    onHit(state, enemy) {\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, 120, { radius: 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS });\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 12, 120);\r\n        }\r\n    },\r\n};\r\nconst megaSlime = {\r\n    ...slime,\r\n    name: 'Mega Slime',\r\n    statFactors: {\r\n        attacksPerSecond: 0.5,\r\n        maxLife: 4.8,\r\n        damage: 1.5,\r\n        armor: 1,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 1,\r\n    portalChance: 0,\r\n    experienceFactor: 5,\r\n    radius: 40,\r\n    getEnchantment(state, enemy) {\r\n        return (0,app_enchantments__WEBPACK_IMPORTED_MODULE_1__.getInsightEnchantment)(enemy.level);\r\n    },\r\n    update(state, enemy) {\r\n        updateSlimeMovement(state, enemy);\r\n        if (enemy.mode === 'dash' && enemy.modeTime === 0) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, 150, { damage: 1.5 * enemy.damage, radius: 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS });\r\n        }\r\n        if (enemy.mode === 'choose' && enemy.modeTime === 0) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 12, 120, { expirationTime: state.fieldTime + 2000 });\r\n        }\r\n    },\r\n    onDeath(state, enemy) {\r\n        const count = 2;\r\n        for (let i = 0; i < count; i++) {\r\n            const theta = state.fieldTime / 500 + i * 2 * Math.PI / count;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(enemy.x + enemy.radius * Math.cos(theta), enemy.y + enemy.radius * Math.sin(theta), greatSlime, enemy.level, enemy.disc);\r\n        }\r\n    },\r\n    onHit(state, enemy) {\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            for (let i = 0; i < 4; i++) {\r\n                const speed = 30 + i * 30;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 10, speed, { expirationTime: state.fieldTime + 2000 });\r\n            }\r\n        }\r\n    },\r\n};\r\nconst miniSlime = {\r\n    ...slime,\r\n    name: 'Mini Slime',\r\n    statFactors: {\r\n        maxLife: 0.8,\r\n        armor: 0,\r\n    },\r\n    initialParams: {},\r\n    portalChance: 0,\r\n    dropChance: 0,\r\n    experienceFactor: 0.1,\r\n    radius: 12,\r\n    onDeath(state, enemy) {\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, 0, 6, 120);\r\n    },\r\n    onHit(state, enemy) {\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, 100);\r\n        }\r\n    },\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/slime.ts?");

/***/ }),

/***/ "./app/enemies/squid.ts":
/*!******************************!*\
  !*** ./app/enemies/squid.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   squid: () => (/* binding */ squid)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst squid = {\r\n    name: 'Squid',\r\n    statFactors: {},\r\n    initialParams: {},\r\n    radius: 25,\r\n    update(state, enemy) {\r\n        enemy.vx = (enemy.vx || 0);\r\n        enemy.vy = (enemy.vy || 0);\r\n        const aggroRadius = 300;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        const isAggro = distance2 <= aggroRadius * aggroRadius;\r\n        if (enemy.mode === 'choose') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.turnTowardsTarget)(state, enemy, isAggro ? state.hero : enemy.disc, 0.1);\r\n            // Slowly \"fall\" forwards wiggling a bit from side to side\r\n            const sideValue = Math.sin(state.fieldTime / 500);\r\n            enemy.vx += 4 * Math.cos(enemy.theta) + 0.2 * sideValue * Math.cos(enemy.theta + Math.PI / 2);\r\n            enemy.vy += 4 * Math.sin(enemy.theta) + 0.2 * sideValue * Math.sin(enemy.theta + Math.PI / 2);\r\n            const mag = Math.sqrt(enemy.vx * enemy.vx + enemy.vy * enemy.vy);\r\n            if (mag > 50) {\r\n                enemy.vx *= 50 / mag;\r\n                enemy.vy *= 50 / mag;\r\n            }\r\n            const delay = isAggro ? 1000 : 2000;\r\n            if (enemy.modeTime >= delay && Math.random() < 0.05) {\r\n                enemy.setMode('burst');\r\n            }\r\n            enemy.x += enemy.vx * app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH / 1000;\r\n            enemy.y += enemy.vy * app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH / 1000;\r\n            return;\r\n        }\r\n        if (enemy.mode === 'burst') {\r\n            for (let i = 0; i < 4; i++) {\r\n                const randomDirection = enemy.theta + (Math.random() - 0.5) * Math.PI / 4;\r\n                const randomSpread = Math.PI / 12 + Math.random() * Math.PI / 3;\r\n                const speed = 80 + i * 20;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, randomDirection, randomSpread, 3, speed);\r\n            }\r\n            // Bursts backwards.\r\n            enemy.vx = -200 * Math.cos(enemy.theta);\r\n            enemy.vy = -200 * Math.sin(enemy.theta);\r\n            enemy.setMode('glide');\r\n            return;\r\n        }\r\n        if (enemy.mode === 'glide') {\r\n            enemy.vx *= 0.98;\r\n            enemy.vy *= 0.98;\r\n            enemy.x += enemy.vx * app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH / 1000;\r\n            enemy.y += enemy.vy * app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH / 1000;\r\n            if (enemy.modeTime >= 500 && Math.random() < 0.05) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n    },\r\n    render: renderSquid,\r\n};\r\nfunction renderSquid(context, state, enemy) {\r\n    const tentacleDirection = ((enemy.modeTime % 800) < 400) ? -1 : 1;\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'black');\r\n    context.save();\r\n    context.translate(enemy.x, enemy.y);\r\n    context.rotate(enemy.theta);\r\n    // \"Body\"\r\n    context.fillStyle = enemy.baseColor;\r\n    context.beginPath();\r\n    context.arc(0, 0, enemy.radius, Math.PI / 2, 3 * Math.PI / 2);\r\n    context.lineTo(0, -enemy.radius);\r\n    context.fill();\r\n    // Tentacles\r\n    context.strokeStyle = enemy.baseColor;\r\n    context.lineWidth = 4;\r\n    context.beginPath();\r\n    // Top tentacle\r\n    context.moveTo(0, -enemy.radius / 2);\r\n    context.arcTo(enemy.radius / 4, -enemy.radius / 2 + tentacleDirection * enemy.radius / 4, enemy.radius / 2, -enemy.radius / 2, enemy.radius / 4);\r\n    // Middle tentacle\r\n    context.moveTo(0, 0);\r\n    context.arcTo(enemy.radius / 4, 0 + tentacleDirection * enemy.radius / 4, enemy.radius / 2, 0, enemy.radius / 4);\r\n    context.arcTo(3 * enemy.radius / 4, 0 - tentacleDirection * enemy.radius / 4, enemy.radius, 0, enemy.radius / 4);\r\n    // Bottom tentacle\r\n    context.moveTo(0, enemy.radius / 2);\r\n    context.arcTo(enemy.radius / 4, enemy.radius / 2 + tentacleDirection * enemy.radius / 4, enemy.radius / 2, enemy.radius / 2, enemy.radius / 4);\r\n    context.stroke();\r\n    context.restore();\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/squid.ts?");

/***/ }),

/***/ "./app/enemies/turret.ts":
/*!*******************************!*\
  !*** ./app/enemies/turret.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   turret: () => (/* binding */ turret)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst turret = {\r\n    name: 'Turret',\r\n    statFactors: {\r\n        maxLife: 2,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n        armor: 2,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE,\r\n    experienceFactor: 2,\r\n    radius: 25,\r\n    update(state, enemy) {\r\n        const aggroRadius = 400;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            enemy.theta += 0.01;\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            for (let i = 0; i < 3; i++) {\r\n                const theta = enemy.theta - Math.PI / 6 + Math.PI / 6 * i;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(theta), 100 * Math.sin(theta), { expirationTime: state.fieldTime + 2000 });\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 20,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 15,\r\n        }, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 20 * Math.cos(enemy.theta),\r\n            y: enemy.y + 20 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/turret.ts?");

/***/ }),

/***/ "./app/enemies/urchin.ts":
/*!*******************************!*\
  !*** ./app/enemies/urchin.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   urchin: () => (/* binding */ urchin)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst urchin = {\r\n    name: 'Urchin',\r\n    statFactors: {\r\n        armor: 2,\r\n        speed: 0.1,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE,\r\n    experienceFactor: 2,\r\n    radius: 25,\r\n    portalChance: 0.2,\r\n    portalDungeonType: 'reef',\r\n    update(state, enemy) {\r\n        const aggroRadius = 400;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        enemy.theta += 0.02;\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInCurrentDirection)(state, enemy);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        if (enemy.modeTime % 100 === 0) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletCircle)(state, enemy, enemy.theta, 3, 100, { expirationTime: state.fieldTime + 1500 });\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 120, { radius: 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS });\r\n        }\r\n    },\r\n    onDeath(state, enemy) {\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletCircle)(state, enemy, enemy.theta, 12, 200, { damage: enemy.damage * 2 });\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta + 2 * Math.PI / 3),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta + 2 * Math.PI / 3),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta - 2 * Math.PI / 3),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta - 2 * Math.PI / 3),\r\n            radius: 5,\r\n        }, 'black');\r\n        context.strokeStyle = 'black';\r\n        context.beginPath();\r\n        context.lineWidth = 2;\r\n        for (let i = 0; i < 12; i++) {\r\n            const theta = 2 * Math.PI * i / 12;\r\n            const dx = Math.cos(theta), dy = Math.sin(theta);\r\n            context.moveTo(enemy.x + 20 * dx, enemy.y + 20 * dy);\r\n            context.lineTo(enemy.x + (26 + i % 2) * dx, enemy.y + (26 + i % 2) * dy);\r\n        }\r\n        context.stroke();\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/urchin.ts?");

/***/ }),

/***/ "./app/initialize.ts":
/*!***************************!*\
  !*** ./app/initialize.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeGame: () => (/* binding */ initializeGame)\n/* harmony export */ });\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n\r\n\r\n\r\nfunction initializeGame(state) {\r\n    (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__.bindMouseListeners)();\r\n    (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__.addContextMenuListeners)();\r\n    (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.addKeyboardListeners)();\r\n    (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-loading').style.display = 'none';\r\n    (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-gameContent').style.display = '';\r\n    state.gameHasBeenInitialized = true;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/initialize.ts?");

/***/ }),

/***/ "./app/inventory.ts":
/*!**************************!*\
  !*** ./app/inventory.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getHoverInventorySlot: () => (/* binding */ getHoverInventorySlot),\n/* harmony export */   getInventorySlots: () => (/* binding */ getInventorySlots),\n/* harmony export */   getSelectedInventorySlot: () => (/* binding */ getSelectedInventorySlot),\n/* harmony export */   getSelectedItem: () => (/* binding */ getSelectedItem),\n/* harmony export */   getSelectedItemArray: () => (/* binding */ getSelectedItemArray),\n/* harmony export */   updateInventory: () => (/* binding */ updateInventory)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n\r\n\r\n\r\n\r\n\r\nconst slotSpacing = app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE + app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_PADDING;\r\nconst weaponSlot = {\r\n    x: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_PADDING,\r\n    y: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - slotSpacing,\r\n    w: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n    h: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n};\r\nconst armorSlot = {\r\n    x: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_PADDING,\r\n    y: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - 2 * slotSpacing,\r\n    w: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n    h: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n};\r\nfunction getInventorySlots(state) {\r\n    const slots = [\r\n        {\r\n            ...weaponSlot,\r\n            item: state.hero.equipment.weapon,\r\n        },\r\n        {\r\n            ...armorSlot,\r\n            item: state.hero.equipment.armor,\r\n        },\r\n    ];\r\n    let slotCount = state.paused ? 10 : 3;\r\n    let y = app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - 2 * slotSpacing;\r\n    for (let i = 0; i < slotCount; i++) {\r\n        const x = app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - (i + 1) * slotSpacing;\r\n        slots.push({\r\n            x,\r\n            y,\r\n            w: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n            h: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n            item: state.hero.weapons[i],\r\n        });\r\n        slots.push({\r\n            x,\r\n            y: y + slotSpacing,\r\n            w: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n            h: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n            item: state.hero.armors[i],\r\n        });\r\n    }\r\n    // Enchantment slots.\r\n    slotCount = state.paused ? 10 : 2;\r\n    y = app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - 3 * slotSpacing;\r\n    for (let i = 0; i < slotCount; i++) {\r\n        const x = app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - (i + 1) * slotSpacing;\r\n        slots.push({\r\n            x,\r\n            y,\r\n            w: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n            h: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n            item: state.hero.enchantments[i],\r\n        });\r\n    }\r\n    return slots;\r\n}\r\nfunction getSelectedItemArray(state) {\r\n    if (state.menuRow === 0) {\r\n        return state.hero.enchantments;\r\n    }\r\n    if (state.menuRow === 1) {\r\n        return state.hero.weapons;\r\n    }\r\n    return state.hero.armors;\r\n}\r\nfunction getSelectedItem(state) {\r\n    if (state.menuEquipmentSelected) {\r\n        if (state.menuRow === 0) {\r\n            return state.hero.equipment.armor;\r\n        }\r\n        return state.hero.equipment.weapon;\r\n    }\r\n    return getSelectedItemArray(state)[getFixedMenuColumn(state)];\r\n}\r\nfunction getSelectedInventorySlot(state) {\r\n    const item = getSelectedItem(state);\r\n    if (item) {\r\n        return getInventorySlots(state).find(s => s.item === item);\r\n    }\r\n    // If not item is selected, return an empty slot that makes sense, either the\r\n    // empty equipment slot, or the right most slot in that inventory row.\r\n    if (state.menuEquipmentSelected) {\r\n        if (state.menuRow === 0) {\r\n            return armorSlot;\r\n        }\r\n        return weaponSlot;\r\n    }\r\n    return {\r\n        x: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - slotSpacing,\r\n        y: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - 3 * slotSpacing + state.menuRow * slotSpacing,\r\n        w: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n        h: app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE,\r\n    };\r\n}\r\nfunction removeEnchantment(state, enchantment) {\r\n    const index = state.hero.enchantments.indexOf(enchantment);\r\n    if (index < 0) {\r\n        return false;\r\n    }\r\n    state.hero.enchantments.splice(index, 1);\r\n    return true;\r\n}\r\nfunction activateItem(state, item) {\r\n    const activeEnchantment = state.hero.activeEnchantment;\r\n    delete state.hero.activeEnchantment;\r\n    if (activeEnchantment) {\r\n        if (item.type !== 'enchantment') {\r\n            if ((0,app_enchantments__WEBPACK_IMPORTED_MODULE_1__.applyEnchantmentToEquipment)(activeEnchantment, item)) {\r\n                removeEnchantment(state, activeEnchantment);\r\n                (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.setDerivedHeroStats)(state);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (item.type === 'weapon') {\r\n        const index = state.hero.weapons.indexOf(item);\r\n        if (index >= 0) {\r\n            state.hero.weapons[index] = state.hero.equipment.weapon;\r\n            state.hero.equipment.weapon = item;\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.setDerivedHeroStats)(state);\r\n        }\r\n    }\r\n    else if (item.type === 'armor') {\r\n        const index = state.hero.armors.indexOf(item);\r\n        if (index >= 0) {\r\n            if (state.hero.equipment.armor) {\r\n                state.hero.armors[index] = state.hero.equipment.armor;\r\n            }\r\n            else {\r\n                state.hero.armors.splice(index, 1);\r\n            }\r\n            state.hero.equipment.armor = item;\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.setDerivedHeroStats)(state);\r\n        }\r\n    }\r\n    else if (item.type === 'enchantment') {\r\n        state.hero.activeEnchantment = item;\r\n    }\r\n}\r\nfunction sellItem(state, item) {\r\n    // cancel enchantment when selling an item.\r\n    delete state.hero.activeEnchantment;\r\n    if (item.type === 'weapon') {\r\n        const index = state.hero.weapons.indexOf(item);\r\n        if (index >= 0) {\r\n            state.hero.weapons.splice(index, 1);\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.gainItemExperience)(state, item);\r\n        }\r\n    }\r\n    else if (item.type === 'armor') {\r\n        const index = state.hero.armors.indexOf(item);\r\n        if (index >= 0) {\r\n            state.hero.armors.splice(index, 1);\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.gainItemExperience)(state, item);\r\n        }\r\n    }\r\n    else if (item.type === 'enchantment') {\r\n        if (removeEnchantment(state, item)) {\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.gainItemExperience)(state, item);\r\n        }\r\n    }\r\n}\r\nfunction getFixedMenuColumn(state) {\r\n    // Keep the column in bounds as the number of items changes.\r\n    const itemArray = getSelectedItemArray(state);\r\n    return Math.max(0, Math.min(itemArray.length - 1, state.menuColumn));\r\n}\r\nfunction getHoverInventorySlot(state) {\r\n    for (const slot of getInventorySlots(state)) {\r\n        if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.isPointInRect)(slot, state.mouse)) {\r\n            return slot;\r\n        }\r\n    }\r\n}\r\nfunction updateInventory(state) {\r\n    var _a;\r\n    if (state.isUsingKeyboard) {\r\n        const hoverItem = (_a = getHoverInventorySlot(state)) === null || _a === void 0 ? void 0 : _a.item;\r\n        if (hoverItem) {\r\n            if (state.mouse.wasPressed) {\r\n                state.hero.isShooting = false;\r\n                activateItem(state, hoverItem);\r\n            }\r\n            else if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL)) {\r\n                sellItem(state, hoverItem);\r\n            }\r\n        }\r\n        else if (state.mouse.wasPressed) {\r\n            // Active enchantment is cleared if the mouse is clicked off an item.\r\n            delete state.hero.activeEnchantment;\r\n        }\r\n    }\r\n    else if (state.isUsingXbox && state.paused) {\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP)) {\r\n            state.menuRow--;\r\n        }\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN)) {\r\n            state.menuRow++;\r\n        }\r\n        if (state.menuEquipmentSelected) {\r\n            state.menuRow = (state.menuRow + 2) % 2;\r\n        }\r\n        else {\r\n            state.menuRow = (state.menuRow + 3) % 3;\r\n        }\r\n        const itemArray = getSelectedItemArray(state);\r\n        if (state.menuEquipmentSelected) {\r\n            if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT)) {\r\n                state.menuEquipmentSelected = false;\r\n                state.menuColumn = 0;\r\n            }\r\n            else if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT)) {\r\n                state.menuEquipmentSelected = false;\r\n                state.menuColumn = Math.min(9, Math.max(0, itemArray.length - 1));\r\n            }\r\n        }\r\n        else {\r\n            if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT)) {\r\n                // Items are displayed right to left, so this is inverted.\r\n                state.menuColumn++;\r\n                if (state.menuColumn >= itemArray.length) {\r\n                    state.menuEquipmentSelected = true;\r\n                    state.menuRow = 0;\r\n                }\r\n            }\r\n            else if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT)) {\r\n                // Items are displayed right to left, so this is inverted.\r\n                state.menuColumn--;\r\n                if (state.menuColumn < 0) {\r\n                    state.menuEquipmentSelected = true;\r\n                    state.menuRow = 0;\r\n                }\r\n            }\r\n            state.menuColumn = getFixedMenuColumn(state);\r\n        }\r\n        const selectedItem = getSelectedItem(state);\r\n        if (!selectedItem) {\r\n            return;\r\n        }\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE)) {\r\n            activateItem(state, selectedItem);\r\n        }\r\n        else if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL)) {\r\n            sellItem(state, selectedItem);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/inventory.ts?");

/***/ }),

/***/ "./app/loot.ts":
/*!*********************!*\
  !*** ./app/loot.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkToDropBasicLoot: () => (/* binding */ checkToDropBasicLoot),\n/* harmony export */   dropArmorLoot: () => (/* binding */ dropArmorLoot),\n/* harmony export */   dropEnchantmentLoot: () => (/* binding */ dropEnchantmentLoot),\n/* harmony export */   dropWeaponLoot: () => (/* binding */ dropWeaponLoot),\n/* harmony export */   generateArmor: () => (/* binding */ generateArmor),\n/* harmony export */   generateWeapon: () => (/* binding */ generateWeapon)\n/* harmony export */ });\n/* harmony import */ var app_armor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/armor */ \"./app/armor.ts\");\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/render/renderInventory */ \"./app/render/renderInventory.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nfunction checkToDropBasicLoot(state, source) {\r\n    var _a;\r\n    if (Math.random() < ((_a = source.definition.dropChance) !== null && _a !== void 0 ? _a : app_constants__WEBPACK_IMPORTED_MODULE_1__.BASE_DROP_CHANCE)) {\r\n        let targetLevel = source.level;\r\n        while (Math.random() < 0.1) {\r\n            targetLevel = Math.min(100, targetLevel + 1);\r\n        }\r\n        if (Math.random() < 0.25) {\r\n            dropArmorLoot(state, source, targetLevel);\r\n        }\r\n        else {\r\n            dropWeaponLoot(state, source, targetLevel);\r\n        }\r\n    }\r\n}\r\nfunction addEnchantmentSlot(item) {\r\n    item.enchantmentSlots.push({ enchantmentType: 'empty', value: 0 });\r\n}\r\nfunction addEnchantmentSlots(item) {\r\n    item.enchantmentSlots = [];\r\n    addEnchantmentSlot(item);\r\n    if (item.level >= 5 && Math.random() < 0.1) {\r\n        addEnchantmentSlot(item);\r\n    }\r\n    if (item.level >= 20 && Math.random() < 0.1) {\r\n        addEnchantmentSlot(item);\r\n    }\r\n    if (item.level >= 50 && Math.random() < 0.1) {\r\n        addEnchantmentSlot(item);\r\n    }\r\n}\r\nfunction generateArmor(armorType, level) {\r\n    const armorArray = app_armor__WEBPACK_IMPORTED_MODULE_0__.armorsByType[armorType];\r\n    let armorIndex = 0;\r\n    for (; armorIndex < armorArray.length - 1; armorIndex++) {\r\n        if (armorArray[armorIndex + 1].level > level) {\r\n            break;\r\n        }\r\n    }\r\n    const armor = { ...armorArray[armorIndex] };\r\n    for (let i = 0; i < 5 && armor.level < level; i++) {\r\n        armor.level++;\r\n        armor.name = armor.name + '+';\r\n        armor.armor = Math.ceil(armor.armor * 1.1);\r\n        armor.life = Math.ceil(armor.life * 1.1);\r\n    }\r\n    addEnchantmentSlots(armor);\r\n    return armor;\r\n}\r\nfunction dropArmorLoot(state, source, level) {\r\n    if (!source.disc) {\r\n        return;\r\n    }\r\n    const armorType = app_utils_Random__WEBPACK_IMPORTED_MODULE_5__[\"default\"].element(app_armor__WEBPACK_IMPORTED_MODULE_0__.armorTypes);\r\n    const armor = generateArmor(armorType, level);\r\n    if (!armor) {\r\n        return;\r\n    }\r\n    source.disc.loot.push({\r\n        type: 'armor',\r\n        x: source.x,\r\n        y: source.y,\r\n        disc: source.disc,\r\n        radius: 12,\r\n        armor,\r\n        activate(state) {\r\n            state.hero.armors.push(this.armor);\r\n        },\r\n        render(context, state) {\r\n            if (this === state.activeLoot) {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__.renderArmorLong)(context, this.x, this.y, this.armor);\r\n            }\r\n            else {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__.renderArmorShort)(context, this.x, this.y, this.armor);\r\n            }\r\n        },\r\n        sell() {\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_2__.gainItemExperience)(state, this.armor);\r\n        }\r\n    });\r\n}\r\nfunction generateWeapon(weaponType, level) {\r\n    const weaponArray = app_weapons__WEBPACK_IMPORTED_MODULE_4__.weaponsByType[weaponType];\r\n    if (!weaponArray.length) {\r\n        return;\r\n    }\r\n    let weaponIndex = 0;\r\n    for (; weaponIndex < weaponArray.length - 1; weaponIndex++) {\r\n        if (weaponArray[weaponIndex + 1].level > level) {\r\n            break;\r\n        }\r\n    }\r\n    const weapon = { ...weaponArray[weaponIndex] };\r\n    for (let i = 0; i < 5 && weapon.level < level; i++) {\r\n        weapon.level++;\r\n        weapon.name = weapon.name + '+';\r\n        weapon.damage = Math.ceil(weapon.damage * 1.1);\r\n    }\r\n    addEnchantmentSlots(weapon);\r\n    return weapon;\r\n}\r\nfunction dropWeaponLoot(state, source, level) {\r\n    if (!source.disc) {\r\n        return;\r\n    }\r\n    const weaponType = app_utils_Random__WEBPACK_IMPORTED_MODULE_5__[\"default\"].element(app_weapons__WEBPACK_IMPORTED_MODULE_4__.weaponTypes);\r\n    const weapon = generateWeapon(weaponType, level);\r\n    if (!weapon) {\r\n        return;\r\n    }\r\n    source.disc.loot.push({\r\n        type: 'weapon',\r\n        x: source.x,\r\n        y: source.y,\r\n        disc: source.disc,\r\n        radius: 12,\r\n        weapon,\r\n        activate(state) {\r\n            state.hero.weapons.push(this.weapon);\r\n        },\r\n        render(context, state) {\r\n            if (this === state.activeLoot) {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__.renderWeaponLong)(context, this.x, this.y, this.weapon);\r\n            }\r\n            else {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__.renderWeaponShort)(context, this.x, this.y, this.weapon);\r\n            }\r\n        },\r\n        sell() {\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_2__.gainItemExperience)(state, this.weapon);\r\n        }\r\n    });\r\n}\r\nfunction dropEnchantmentLoot(state, disc, { x, y }, enchantment) {\r\n    if (!disc) {\r\n        return;\r\n    }\r\n    disc.loot.push({\r\n        type: 'enchantment',\r\n        disc,\r\n        x,\r\n        y,\r\n        radius: 12,\r\n        enchantment,\r\n        activate(state) {\r\n            state.hero.enchantments.push(this.enchantment);\r\n        },\r\n        render(context, state) {\r\n            if (this === state.activeLoot) {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__.renderEnchantmentLong)(context, this.x, this.y, this.enchantment);\r\n            }\r\n            else {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__.renderEnchantmentShort)(context, this.x, this.y, this.enchantment);\r\n            }\r\n        },\r\n        sell() {\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_2__.gainItemExperience)(state, this.enchantment);\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/loot.ts?");

/***/ }),

/***/ "./app/render/renderGame.ts":
/*!**********************************!*\
  !*** ./app/render/renderGame.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   renderMinimap: () => (/* binding */ renderMinimap)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_inventory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/inventory */ \"./app/inventory.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/render/renderInventory */ \"./app/render/renderInventory.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst minimapSize = 500;\r\nconst smallMapRect = { x: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - 160, y: 10, w: 150, h: 150 };\r\nconst largeMapRect = { x: (app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - 400) / 2, y: (app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - 400) / 2, w: 400, h: 400 };\r\nconst [mapCanvas, mapContext] = (0,app_utils_canvas__WEBPACK_IMPORTED_MODULE_5__.createCanvasAndContext)(minimapSize, minimapSize);\r\nconst mapScale = 15;\r\nfunction renderMinimap(state) {\r\n    mapContext.fillStyle = '#000';\r\n    mapContext.fillRect(0, 0, minimapSize, minimapSize);\r\n    mapContext.save();\r\n    mapContext.translate(minimapSize / 2, minimapSize / 2);\r\n    mapContext.scale(1 / mapScale, 1 / mapScale);\r\n    mapContext.translate(-state.hero.x, -state.hero.y);\r\n    for (const disc of state.visibleDiscs) {\r\n        mapContext.fillStyle = disc.boss ? '#FBB' : '#DDD';\r\n        mapContext.beginPath();\r\n        mapContext.arc(disc.x, disc.y, disc.radius, 0, 2 * Math.PI);\r\n        mapContext.fill();\r\n    }\r\n    app_constants__WEBPACK_IMPORTED_MODULE_0__.CELL_SIZE;\r\n    // Debug code to draw world cell boundaries.\r\n    /*mapContext.lineWidth = 4;\r\n    mapContext.strokeStyle = 'red';\r\n    for (const cell of state.activeCells) {\r\n        mapContext.strokeRect(cell.x * CELL_SIZE, (cell.y + 1) * -CELL_SIZE, CELL_SIZE, CELL_SIZE);\r\n    }*/\r\n    mapContext.restore();\r\n}\r\nfunction render(context, state) {\r\n    var _a, _b, _c;\r\n    context.fillStyle = '#000';\r\n    context.fillRect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n    context.save();\r\n    context.translate(app_constants__WEBPACK_IMPORTED_MODULE_0__.FIELD_CENTER.x - state.hero.x, app_constants__WEBPACK_IMPORTED_MODULE_0__.FIELD_CENTER.y - state.hero.y);\r\n    state.visibleDiscs.sort((A, B) => A.y - B.y);\r\n    const normalDiscs = state.visibleDiscs.filter(d => !d.boss);\r\n    const bossDiscs = state.visibleDiscs.filter(d => d.boss);\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDiscEdge1(context, disc);\r\n    }\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDiscEdge2(context, disc);\r\n    }\r\n    for (const disc of normalDiscs) {\r\n        renderDisc(context, disc);\r\n    }\r\n    for (const disc of normalDiscs) {\r\n        renderDiscCenter(context, disc);\r\n    }\r\n    // Render tops of boss discs over other discs to make the arena edge clear.\r\n    for (const disc of bossDiscs) {\r\n        renderDisc(context, disc);\r\n    }\r\n    for (const disc of bossDiscs) {\r\n        renderDiscCenter(context, disc);\r\n    }\r\n    for (const portal of state.portals) {\r\n        renderPortal(context, state, portal);\r\n    }\r\n    if ((_b = (_a = state.hero) === null || _a === void 0 ? void 0 : _a.disc) === null || _b === void 0 ? void 0 : _b.boss) {\r\n        context.save();\r\n        context.translate(-(app_constants__WEBPACK_IMPORTED_MODULE_0__.FIELD_CENTER.x - state.hero.x), -(app_constants__WEBPACK_IMPORTED_MODULE_0__.FIELD_CENTER.y - state.hero.y));\r\n        context.globalAlpha *= 0.6;\r\n        context.fillStyle = '#000';\r\n        context.fillRect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n        context.restore();\r\n        renderDisc(context, state.hero.disc);\r\n        renderDiscCenter(context, state.hero.disc);\r\n    }\r\n    for (const loot of state.loot) {\r\n        if (loot === state.activeLoot) {\r\n            continue;\r\n        }\r\n        loot.render(context, state);\r\n    }\r\n    (_c = state.activeLoot) === null || _c === void 0 ? void 0 : _c.render(context, state);\r\n    for (const enemy of state.enemies) {\r\n        enemy.definition.render(context, state, enemy);\r\n    }\r\n    for (const enemy of state.enemies) {\r\n        renderEnemyLifebar(context, enemy);\r\n    }\r\n    renderHero(context, state, state.hero);\r\n    for (const bullet of state.heroBullets) {\r\n        renderHeroBullet(context, bullet);\r\n    }\r\n    for (const bullet of state.enemyBullets) {\r\n        renderEnemyBullet(context, bullet);\r\n    }\r\n    for (const fieldText of state.fieldText) {\r\n        renderFieldText(context, fieldText);\r\n    }\r\n    context.restore();\r\n    context.beginPath();\r\n    context.rect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n    context.arc(app_constants__WEBPACK_IMPORTED_MODULE_0__.FIELD_CENTER.x, app_constants__WEBPACK_IMPORTED_MODULE_0__.FIELD_CENTER.y, app_constants__WEBPACK_IMPORTED_MODULE_0__.SIGHT_RADIUS, 0, 2 * Math.PI, true);\r\n    context.fillStyle = '#000';\r\n    context.fill();\r\n    if (state.isUsingXbox) {\r\n        const [dx, dy] = (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.getRightAnalogDeltas)(state);\r\n        /*const x = FIELD_CENTER.x + dx * 100, y = FIELD_CENTER.y + dy * 100;\r\n        context.beginPath();\r\n        context.arc(x, y, 15, 0, 2 * Math.PI, true);\r\n        context.strokeStyle = 'blue';\r\n        context.stroke();*/\r\n        /*context.beginPath();\r\n        context.arc(x, y, 2, 0, 2 * Math.PI, true);\r\n        context.fillStyle = 'blue';\r\n        context.fill();*/\r\n        context.save();\r\n        context.beginPath();\r\n        context.setLineDash([10, 15]);\r\n        context.strokeStyle = 'blue';\r\n        context.moveTo(app_constants__WEBPACK_IMPORTED_MODULE_0__.FIELD_CENTER.x, app_constants__WEBPACK_IMPORTED_MODULE_0__.FIELD_CENTER.y);\r\n        context.lineTo(app_constants__WEBPACK_IMPORTED_MODULE_0__.SIGHT_RADIUS * dx + app_constants__WEBPACK_IMPORTED_MODULE_0__.FIELD_CENTER.x, app_constants__WEBPACK_IMPORTED_MODULE_0__.SIGHT_RADIUS * dy + app_constants__WEBPACK_IMPORTED_MODULE_0__.FIELD_CENTER.y);\r\n        context.stroke();\r\n        context.restore();\r\n    }\r\n    renderHUD(context, state);\r\n}\r\nfunction renderHUD(context, state) {\r\n    var _a;\r\n    if (state.paused) {\r\n        context.save();\r\n        context.globalAlpha *= 0.6;\r\n        context.fillStyle = 'black';\r\n        context.fillRect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n        context.restore();\r\n    }\r\n    const minimapRect = state.paused ? largeMapRect : smallMapRect;\r\n    renderMinimap(state);\r\n    context.fillStyle = '#999';\r\n    context.fillRect(minimapRect.x - 2, minimapRect.y - 2, minimapRect.w + 4, minimapRect.h + 4);\r\n    context.fillStyle = 'black';\r\n    context.fillRect(minimapRect.x, minimapRect.y, minimapRect.w, minimapRect.h);\r\n    context.drawImage(mapCanvas, minimapSize / 2 - minimapRect.w / 2, minimapSize / 2 - minimapRect.h / 2, minimapRect.w, minimapRect.h, minimapRect.x, minimapRect.y, minimapRect.w, minimapRect.h);\r\n    context.fillStyle = '#08F';\r\n    context.fillRect(minimapRect.x + minimapRect.w / 2 - 3, minimapRect.y + minimapRect.h / 2 - 3, 6, 6);\r\n    context.fillStyle = 'red';\r\n    for (const enemy of state.enemies) {\r\n        const x = minimapRect.x + minimapRect.w / 2 + (enemy.x - state.hero.x) / mapScale;\r\n        const y = minimapRect.y + minimapRect.w / 2 + (enemy.y - state.hero.y) / mapScale;\r\n        if (x > minimapRect.x + 2 && x < minimapRect.x + minimapRect.w - 2 &&\r\n            y > minimapRect.y + 2 && y < minimapRect.y + minimapRect.h - 2) {\r\n            context.fillRect(x - 2, y - 2, 4, 4);\r\n        }\r\n    }\r\n    if (state.hero.disc) {\r\n        context.fillStyle = 'white';\r\n        context.textBaseline = 'top';\r\n        context.textAlign = 'right';\r\n        context.font = '16px sans-serif';\r\n        context.fillText(state.hero.disc.name, smallMapRect.x + smallMapRect.w, smallMapRect.y + smallMapRect.h + 10);\r\n        context.fillText(`Level ${state.hero.disc.level}`, smallMapRect.x + smallMapRect.w, smallMapRect.y + smallMapRect.h + 26);\r\n    }\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'top';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    context.fillText('Level ' + state.hero.level, 5, 5);\r\n    const lifeRect = { x: 5, y: 30, h: 20, w: 200 };\r\n    renderBar(context, lifeRect, state.hero.life / state.hero.maxLife, 'green', '#888');\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    context.fillText(state.hero.life + ' / ' + state.hero.maxLife, lifeRect.x + 2, lifeRect.y + lifeRect.h / 2 + 2);\r\n    const experienceRect = { x: 5, y: lifeRect.y + lifeRect.h + 5, h: 10, w: 200 };\r\n    const requiredExperience = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.getExperienceForNextLevel)(state.hero.level);\r\n    renderBar(context, experienceRect, state.hero.experience / requiredExperience, 'orange', '#888');\r\n    let y = app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - 25;\r\n    let x = app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE + 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_PADDING;\r\n    const weaponXpRect = { x, y, h: 10, w: 160 };\r\n    const weaponProficiency = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.getWeaponProficiency)(state, state.hero.equipment.weapon.weaponType);\r\n    const requiredWeaponXp = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.getExperienceForNextWeaponLevel)(weaponProficiency.level);\r\n    renderBar(context, weaponXpRect, weaponProficiency.experience / requiredWeaponXp, 'orange', '#888');\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    context.fillText(app_weapons__WEBPACK_IMPORTED_MODULE_7__.weaponTypeLabels[state.hero.equipment.weapon.weaponType] + ' skill ' + weaponProficiency.level, x, y - 8);\r\n    if (state.paused) {\r\n        let y = 200;\r\n        for (const weaponType of app_weapons__WEBPACK_IMPORTED_MODULE_7__.weaponTypes) {\r\n            const weaponXpRect = { x: 5, y, h: 10, w: 160 };\r\n            const weaponProficiency = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.getWeaponProficiency)(state, weaponType);\r\n            const requiredWeaponXp = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.getExperienceForNextWeaponLevel)(weaponProficiency.level);\r\n            renderBar(context, weaponXpRect, weaponProficiency.experience / requiredWeaponXp, 'orange', '#888');\r\n            context.fillStyle = 'white';\r\n            context.textBaseline = 'middle';\r\n            context.textAlign = 'left';\r\n            context.font = '16px sans-serif';\r\n            context.fillText(app_weapons__WEBPACK_IMPORTED_MODULE_7__.weaponTypeLabels[weaponType] + ' skill ' + weaponProficiency.level, 10, y - 8);\r\n            y += 30;\r\n        }\r\n    }\r\n    y -= (app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_SIZE + app_constants__WEBPACK_IMPORTED_MODULE_0__.SLOT_PADDING);\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    context.fillText('Armor ' + state.hero.armor, x, y - 8);\r\n    context.strokeStyle = 'red';\r\n    context.fillStyle = 'red';\r\n    for (let i = 0; i < app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_MAX_POTIONS; i++) {\r\n        if (i < state.hero.potions) {\r\n            context.fillRect(5 + i * 15, experienceRect.y + experienceRect.h + 5, 10, 15);\r\n        }\r\n        context.strokeRect(5 + i * 15, experienceRect.y + experienceRect.h + 5, 10, 15);\r\n    }\r\n    const boss = (_a = state.hero.disc) === null || _a === void 0 ? void 0 : _a.boss;\r\n    if (!state.paused && boss) {\r\n        const lifeRect = { x: 210, y: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - 60, h: 24, w: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - 420 };\r\n        let color = '#0F0';\r\n        if (boss.life <= boss.maxLife / 4) {\r\n            color = '#F00';\r\n        }\r\n        else if (boss.life <= boss.maxLife / 2) {\r\n            color = '#F80';\r\n        }\r\n        renderBar(context, lifeRect, boss.life / boss.maxLife, color, '#444');\r\n        context.fillStyle = 'white';\r\n        context.textBaseline = 'middle';\r\n        context.textAlign = 'left';\r\n        context.font = '20px sans-serif';\r\n        context.fillText(boss.definition.name + ' ' + boss.life + ' / ' + boss.maxLife, lifeRect.x + 2, lifeRect.y + lifeRect.h / 2 + 2);\r\n    }\r\n    let hoverItem = undefined;\r\n    for (const slot of (0,app_inventory__WEBPACK_IMPORTED_MODULE_1__.getInventorySlots)(state)) {\r\n        (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__.renderInventorySlot)(context, state, slot);\r\n        if (state.isUsingKeyboard && slot.item && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_6__.isPointInRect)(slot, state.mouse)) {\r\n            hoverItem = slot.item;\r\n        }\r\n    }\r\n    if (state.paused && state.isUsingXbox) {\r\n        (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__.renderSelectedInventorySlot)(context, state);\r\n        hoverItem = (0,app_inventory__WEBPACK_IMPORTED_MODULE_1__.getSelectedItem)(state);\r\n    }\r\n    if (hoverItem) {\r\n        let equippedItem;\r\n        if (hoverItem.type === 'weapon') {\r\n            equippedItem = state.hero.equipment.weapon;\r\n        }\r\n        if (hoverItem.type === 'armor') {\r\n            equippedItem = state.hero.equipment.armor;\r\n        }\r\n        if (state.isUsingXbox) {\r\n            const slot = (0,app_inventory__WEBPACK_IMPORTED_MODULE_1__.getSelectedInventorySlot)(state);\r\n            if (slot) {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__.renderItemDetails)(context, hoverItem, slot, equippedItem);\r\n            }\r\n        }\r\n        else {\r\n            (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_3__.renderItemDetails)(context, hoverItem, state.mouse, equippedItem);\r\n        }\r\n    }\r\n}\r\nfunction renderBar(context, { x, y, w, h }, p, fillColor, backColor = 'black') {\r\n    context.fillStyle = backColor;\r\n    context.fillRect(x, y, w, h);\r\n    context.fillStyle = fillColor;\r\n    context.fillRect(x, y, w * Math.max(0, Math.min(1, p)), h);\r\n}\r\nfunction renderPortal(context, state, portal) {\r\n    const isActive = !state.activeLoot && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_6__.doCirclesIntersect)(state.hero, portal);\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, portal, isActive ? '#BBB' : '#666');\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, { ...portal, radius: portal.radius * 0.9 }, '#000');\r\n    context.fillStyle = isActive ? '#FFF' : '#88F';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'center';\r\n    context.font = '16px sans-serif';\r\n    if (portal.dungeon) {\r\n        context.fillText(`Level ` + portal.dungeon.level, portal.x, portal.y - 10);\r\n        context.fillText(portal.name, portal.x, portal.y + 10);\r\n    }\r\n    else {\r\n        context.fillText(portal.name, portal.x, portal.y);\r\n    }\r\n}\r\nfunction renderEnemyLifebar(context, enemy) {\r\n    if (enemy.life < enemy.maxLife) {\r\n        let color = '#0F0';\r\n        if (enemy.life <= enemy.maxLife / 4) {\r\n            color = '#F00';\r\n        }\r\n        else if (enemy.life <= enemy.maxLife / 2) {\r\n            color = '#F80';\r\n        }\r\n        renderBar(context, { x: enemy.x - 15, y: enemy.y - enemy.radius - 8, w: 30, h: 6 }, enemy.life / enemy.maxLife, color);\r\n    }\r\n}\r\nfunction renderEnemyBullet(context, bullet) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, bullet, 'red');\r\n}\r\nfunction renderHeroBullet(context, bullet) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, bullet, 'green');\r\n}\r\nfunction renderHero(context, state, hero) {\r\n    if (hero.attackChargeDuration > 0 && hero.attackChargeLevel >= 2) {\r\n        // While charged attack still applies, draw an orange halo.\r\n        context.save();\r\n        context.globalAlpha *= (0.6 + 0.15 * Math.sin(state.fieldTime / 100));\r\n        const chargeRadius = hero.radius * 1.3;\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, { x: hero.x, y: hero.y, radius: chargeRadius }, 'orange');\r\n        context.restore();\r\n    }\r\n    else if (hero.chargingLevel >= 2) {\r\n        context.save();\r\n        const color = hero.chargingLevel >= 2 ? 'red' : 'orange';\r\n        context.globalAlpha *= (0.45 + 0.15 * Math.sin(state.fieldTime / 100));\r\n        const chargeRadius = 2 * Math.floor(hero.chargingLevel);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, { x: hero.x, y: hero.y, radius: hero.radius + chargeRadius }, color);\r\n        context.restore();\r\n    }\r\n    context.save();\r\n    if (hero.life <= 0) {\r\n        context.globalAlpha *= 0.5;\r\n    }\r\n    else if (hero.recentDamageTaken) {\r\n        const fadeAmount = 0.2 + 0.3 * hero.recentDamageTaken / (hero.maxLife / 2);\r\n        //context.globalAlpha *= (1 - fadeAmount / 2 + fadeAmount * Math.sin(state.fieldTime / 80));\r\n        context.globalAlpha *= (1 - fadeAmount);\r\n    }\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, hero, 'blue');\r\n    context.restore();\r\n    // Debug code to render charge level on hero\r\n    /*context.fillStyle = 'white';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'center';\r\n    context.font = '16px sans-serif';\r\n    context.fillText(state.hero.chargingLevel.toFixed(2), hero.x, hero.y);*/\r\n}\r\nfunction renderFieldText(context, fieldText) {\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'center';\r\n    let size = 20;\r\n    if (fieldText.time < 300) {\r\n        size = 50 - 25 * fieldText.time / 300;\r\n    }\r\n    context.font = `${size}px bold sans-serif`;\r\n    if (fieldText.borderColor) {\r\n        context.fillStyle = fieldText.borderColor;\r\n        /*context.fillText(fieldText.text, fieldText.x - 1, fieldText.y - 1);\r\n        context.fillText(fieldText.text, fieldText.x - 1, fieldText.y + 1);\r\n        context.fillText(fieldText.text, fieldText.x + 1, fieldText.y - 1);\r\n        context.fillText(fieldText.text, fieldText.x + 1, fieldText.y + 1);*/\r\n        context.fillText(fieldText.text, fieldText.x - 1, fieldText.y);\r\n        context.fillText(fieldText.text, fieldText.x + 1, fieldText.y);\r\n        context.fillText(fieldText.text, fieldText.x, fieldText.y + 1);\r\n        context.fillText(fieldText.text, fieldText.x, fieldText.y - 1);\r\n    }\r\n    /*if (fieldText.borderColor) {\r\n        context.strokeStyle = fieldText.borderColor;\r\n        context.strokeText(fieldText.text, fieldText.x, fieldText.y);\r\n    }*/\r\n    if (fieldText.color) {\r\n        context.fillStyle = fieldText.color;\r\n        context.fillText(fieldText.text, fieldText.x, fieldText.y);\r\n    }\r\n}\r\nconst discDepth = 40;\r\nfunction renderDiscEdge1(context, disc) {\r\n    context.fillStyle = '#888';\r\n    //context.fillRect(disc.x - disc.radius, disc.y, disc.radius * 2, discDepth);\r\n    context.beginPath();\r\n    //context.moveTo(disc.x - disc.radius, disc.y);\r\n    //context.lineTo(disc.x - disc.radius, disc.y + discDepth);\r\n    context.arc(disc.x, disc.y + discDepth, disc.radius, 0, Math.PI);\r\n    //context.lineTo(disc.x + disc.radius, disc.y);\r\n    context.fill();\r\n}\r\nfunction renderDiscEdge2(context, disc) {\r\n    context.fillStyle = '#BBB';\r\n    //context.fillRect(disc.x - disc.radius, disc.y, disc.radius * 2, discDepth / 2);\r\n    context.beginPath();\r\n    //context.moveTo(disc.x - disc.radius, disc.y);\r\n    //context.lineTo(disc.x - disc.radius, disc.y + discDepth / 2);\r\n    context.arc(disc.x, disc.y + discDepth / 2, disc.radius, 0, Math.PI);\r\n    //context.lineTo(disc.x + disc.radius, disc.y);\r\n    context.fill();\r\n}\r\nfunction renderDisc(context, disc) {\r\n    context.fillStyle = disc.boss ? '#FBB' : '#DDD';\r\n    context.beginPath();\r\n    context.arc(disc.x, disc.y, disc.radius, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\nfunction renderDiscCenter(context, disc) {\r\n    context.fillStyle = disc.boss ? '#FCC' : '#FFF';\r\n    context.beginPath();\r\n    context.arc(disc.x, disc.y, disc.radius / 2, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderGame.ts?");

/***/ }),

/***/ "./app/render/renderGeometry.ts":
/*!**************************************!*\
  !*** ./app/render/renderGeometry.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawRect: () => (/* binding */ drawRect),\n/* harmony export */   fillCircle: () => (/* binding */ fillCircle)\n/* harmony export */ });\nfunction fillCircle(context, circle, color) {\r\n    context.fillStyle = color;\r\n    context.beginPath();\r\n    context.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\nfunction drawRect(context, { x, y, w, h }, reverse = false) {\r\n    if (reverse) {\r\n        context.moveTo(x, y);\r\n        context.lineTo(x, y + h);\r\n        context.lineTo(x + w, y + h);\r\n        context.lineTo(x + w, y);\r\n    }\r\n    else {\r\n        context.rect(x, y, w, h);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderGeometry.ts?");

/***/ }),

/***/ "./app/render/renderInventory.ts":
/*!***************************************!*\
  !*** ./app/render/renderInventory.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   renderArmorLong: () => (/* binding */ renderArmorLong),\n/* harmony export */   renderArmorShort: () => (/* binding */ renderArmorShort),\n/* harmony export */   renderEnchantmentLong: () => (/* binding */ renderEnchantmentLong),\n/* harmony export */   renderEnchantmentShort: () => (/* binding */ renderEnchantmentShort),\n/* harmony export */   renderInventorySlot: () => (/* binding */ renderInventorySlot),\n/* harmony export */   renderItemDetails: () => (/* binding */ renderItemDetails),\n/* harmony export */   renderSelectedInventorySlot: () => (/* binding */ renderSelectedInventorySlot),\n/* harmony export */   renderWeaponLong: () => (/* binding */ renderWeaponLong),\n/* harmony export */   renderWeaponShort: () => (/* binding */ renderWeaponShort)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_render_renderText__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/render/renderText */ \"./app/render/renderText.ts\");\n/* harmony import */ var app_armor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/armor */ \"./app/armor.ts\");\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_inventory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/inventory */ \"./app/inventory.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction renderInventorySlot(context, state, { x, y, w, h, item }) {\r\n    context.fillStyle = 'white';\r\n    context.beginPath();\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.drawRect)(context, { x, y, w, h });\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.drawRect)(context, { x: x + 2, y: y + 2, w: w - 4, h: h - 4 }, true);\r\n    context.fill();\r\n    if ((item === null || item === void 0 ? void 0 : item.type) === 'armor') {\r\n        renderArmorShort(context, x + w / 2, y + h / 2, item);\r\n    }\r\n    if ((item === null || item === void 0 ? void 0 : item.type) === 'enchantment') {\r\n        renderEnchantmentShort(context, x + w / 2, y + h / 2, item);\r\n        if (state.hero.activeEnchantment === item) {\r\n            context.save();\r\n            context.globalAlpha *= 0.6;\r\n            context.fillStyle = 'white';\r\n            context.fillRect(x, y, w, h);\r\n            context.restore();\r\n        }\r\n    }\r\n    if ((item === null || item === void 0 ? void 0 : item.type) === 'weapon') {\r\n        renderWeaponShort(context, x + w / 2, y + h / 2, item);\r\n    }\r\n}\r\nfunction renderSelectedInventorySlot(context, state) {\r\n    const slot = (0,app_inventory__WEBPACK_IMPORTED_MODULE_5__.getSelectedInventorySlot)(state);\r\n    if (!slot) {\r\n        return;\r\n    }\r\n    const { x, y, w, h } = slot;\r\n    context.fillStyle = 'blue';\r\n    context.beginPath();\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.drawRect)(context, { x, y, w, h });\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.drawRect)(context, { x: x + 2, y: y + 2, w: w - 4, h: h - 4 }, true);\r\n    context.fill();\r\n}\r\nfunction renderArmorLong(context, x, y, armor) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x, y, radius: 12 }, '#88F');\r\n    const label = armor.name;\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_2__.embossText)(context, label, x, y, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction renderArmorShort(context, x, y, armor) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x, y, radius: 12 }, '#88F');\r\n    const label = armor.armorType.charAt(0).toUpperCase() + armor.level;\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_2__.embossText)(context, label, x, y, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction renderEnchantmentLong(context, x, y, enchantment) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x, y, radius: 12 }, '#8F8');\r\n    const label = app_enchantments__WEBPACK_IMPORTED_MODULE_4__.enchantmentStrengthLabels[enchantment.strength] + ' ' + enchantment.name + ' enchantment';\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_2__.embossText)(context, label, x, y, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction renderEnchantmentShort(context, x, y, enchantment) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x, y, radius: 12 }, '#8F8');\r\n    const label = 'E' + enchantment.strength;\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_2__.embossText)(context, label, x, y, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction renderWeaponLong(context, x, y, weapon) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x, y, radius: 12 }, '#F88');\r\n    const label = weapon.name;\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_2__.embossText)(context, label, x, y, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction renderWeaponShort(context, x, y, weapon) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x, y, radius: 12 }, '#F88');\r\n    const label = weapon.weaponType.charAt(0).toUpperCase() + weapon.level;\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_2__.embossText)(context, label, x, y, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nconst minDetailsWidth = 200;\r\nconst minDetailsHeight = 50;\r\nfunction renderItemDetails(context, item, { x, y }, equippedItem) {\r\n    let w = minDetailsWidth, h = minDetailsHeight;\r\n    const textLines = equippedItem && equippedItem !== item && item.type !== 'enchantment'\r\n        ? getItemComparisonTextLines(item, equippedItem)\r\n        : getItemTextLines(item);\r\n    const lineWidths = [];\r\n    for (const line of textLines) {\r\n        const lineWidth = context.measureText(line).width;\r\n        w = Math.max(w, lineWidth + 20);\r\n        lineWidths.push(lineWidth);\r\n    }\r\n    h = Math.max(h, textLines.length * 20 + 20);\r\n    x = Math.max(10, Math.min(app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - 10 - w, x - w / 2));\r\n    y = Math.max(10, Math.min(app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - 10 - h, y - h - 10));\r\n    context.fillStyle = 'white';\r\n    context.fillRect(x, y, w, h);\r\n    context.fillStyle = 'black';\r\n    context.fillRect(x + 2, y + 2, w - 4, h - 4);\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'top';\r\n    context.textAlign = 'left';\r\n    context.font = `16px sans-serif`;\r\n    for (let i = 0; i < textLines.length; i++) {\r\n        const line = textLines[i];\r\n        context.fillText(line, x + 10, y + 10 + 20 * i);\r\n    }\r\n}\r\nfunction getItemTextLines(item) {\r\n    if (item.type === 'enchantment') {\r\n        return [\r\n            app_enchantments__WEBPACK_IMPORTED_MODULE_4__.enchantmentStrengthLabels[item.strength] + ' ' + item.name + ' enchantment',\r\n            'Weapon: Grants ' + (0,app_enchantments__WEBPACK_IMPORTED_MODULE_4__.getEnchantmentBonusText)(item.weaponEnchantmentType, 10 * item.strength, 20 * item.strength),\r\n            'Armor: Grants ' + (0,app_enchantments__WEBPACK_IMPORTED_MODULE_4__.getEnchantmentBonusText)(item.armorEnchantmentType, 10 * item.strength, 20 * item.strength),\r\n        ];\r\n    }\r\n    if (item.type === 'weapon') {\r\n        return [\r\n            item.name,\r\n            'Lv ' + item.level + ' ' + app_weapons__WEBPACK_IMPORTED_MODULE_6__.weaponTypeLabels[item.weaponType],\r\n            Math.round(item.damage * item.shots.length * item.attacksPerSecond) + ' DPS',\r\n            ...getEnchantmentTextLines(item),\r\n        ];\r\n    }\r\n    if (item.type === 'armor') {\r\n        return [\r\n            item.name,\r\n            'Lv ' + item.level + ' ' + app_armor__WEBPACK_IMPORTED_MODULE_3__.armorTypeLabels[item.armorType],\r\n            item.armor + ' Armor',\r\n            '+' + item.life + ' Life',\r\n            ...getEnchantmentTextLines(item),\r\n        ];\r\n    }\r\n    return [];\r\n}\r\nfunction getItemComparisonTextLines(newItem, equippedItem) {\r\n    if (newItem.type === 'weapon' && equippedItem.type === 'weapon') {\r\n        const oldDps = Math.round(equippedItem.damage * equippedItem.shots.length * equippedItem.attacksPerSecond);\r\n        const newDps = Math.round(newItem.damage * newItem.shots.length * newItem.attacksPerSecond);\r\n        return [\r\n            newItem.name,\r\n            'Lv ' + newItem.level + ' ' + app_weapons__WEBPACK_IMPORTED_MODULE_6__.weaponTypeLabels[newItem.weaponType],\r\n            oldDps + '  ' + newDps + ' DPS',\r\n            ...getEnchantmentComparisonTextLines(newItem, equippedItem),\r\n        ];\r\n    }\r\n    if (newItem.type === 'armor' && equippedItem.type === 'armor') {\r\n        return [\r\n            newItem.name,\r\n            'Lv ' + newItem.level + ' ' + app_armor__WEBPACK_IMPORTED_MODULE_3__.armorTypeLabels[newItem.armorType],\r\n            equippedItem.armor + '  ' + newItem.armor + ' Armor',\r\n            '+' + equippedItem.life + '  ' + '+' + newItem.life + ' Life',\r\n            ...getEnchantmentComparisonTextLines(newItem, equippedItem),\r\n        ];\r\n    }\r\n    return [];\r\n}\r\nfunction getEnchantmentTextLines(item) {\r\n    return item.enchantmentSlots.map(getEnchantmentText);\r\n}\r\nfunction getEnchantmentComparisonTextLines(newItem, equippedItem) {\r\n    const lines = [];\r\n    for (let i = 0; i < newItem.enchantmentSlots.length || i < equippedItem.enchantmentSlots.length; i++) {\r\n        lines.push(getEnchantmentText(equippedItem.enchantmentSlots[i]) + '  ' + getEnchantmentText(newItem.enchantmentSlots[i]));\r\n    }\r\n    return lines;\r\n}\r\nfunction getEnchantmentText(enchantment) {\r\n    if (!enchantment) {\r\n        return '-- ';\r\n    }\r\n    if (enchantment.enchantmentType === 'empty') {\r\n        return 'Empty Slot';\r\n    }\r\n    if (!enchantment.value) {\r\n        return enchantment.enchantmentType;\r\n    }\r\n    return (0,app_enchantments__WEBPACK_IMPORTED_MODULE_4__.getEnchantmentBonusText)(enchantment.enchantmentType, enchantment.value);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderInventory.ts?");

/***/ }),

/***/ "./app/render/renderText.ts":
/*!**********************************!*\
  !*** ./app/render/renderText.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   embossText: () => (/* binding */ embossText)\n/* harmony export */ });\nfunction embossText(context, text, x, y, { textAlign = 'center', textBaseline = 'middle', size = 16, color = 'white', borderColor = 'black', bold = false, }) {\r\n    context.textBaseline = textBaseline;\r\n    context.textAlign = textAlign;\r\n    context.font = `${size}px ${bold ? 'bold ' : ''}sans-serif`;\r\n    if (borderColor) {\r\n        context.fillStyle = borderColor;\r\n        context.fillText(text, x - 1, y);\r\n        context.fillText(text, x + 1, y);\r\n        context.fillText(text, x, y + 1);\r\n        context.fillText(text, x, y - 1);\r\n    }\r\n    context.fillStyle = color;\r\n    context.fillText(text, x, y);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderText.ts?");

/***/ }),

/***/ "./app/utils/Random.ts":
/*!*****************************!*\
  !*** ./app/utils/Random.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Random = {\r\n    /**\r\n     * @param {number} min  The smallest returned value\r\n     * @param {number} max  The largest returned value\r\n     */\r\n    range(A, B) {\r\n        var min = Math.min(A, B);\r\n        var max = Math.max(A, B);\r\n        return Math.floor(Math.random() * (max + 1 - min)) + min;\r\n    },\r\n    /**\r\n     * @param {Collection} collection  The collection of elements to return random element from\r\n     */\r\n    element(collection) {\r\n        if (collection.constructor === Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = Random.element(keys);\r\n            return object[key];\r\n        }\r\n        if (collection.constructor === Array) {\r\n            const array = collection;\r\n            return array[Math.floor(Math.random() * array.length)];\r\n        }\r\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\r\n    },\r\n    /**\r\n     * @param {Array} array  The array of elements to return random element from\r\n     */\r\n    removeElement(collection) {\r\n        if (collection.constructor === Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = Random.element(keys);\r\n            const value = object[key];\r\n            delete object[key];\r\n            return value;\r\n        }\r\n        if (collection.constructor === Array) {\r\n            const array = collection;\r\n            return array.splice(Math.floor(Math.random() * array.length), 1)[0];\r\n        }\r\n        throw new Error(\"Warning @ Random.removeElement: \" + collection + \" is neither Array or Object\");\r\n    },\r\n    /**\r\n     * Shuffles an array.\r\n     *\r\n     * Knuth algorithm found at:\r\n     * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n     *\r\n     * @param {Array} array  The array of elements to shuffle\r\n     */\r\n    shuffle(array) {\r\n        array = [...array];\r\n        let currentIndex = array.length, temporaryValue, randomIndex;\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(Math.random() * currentIndex);\r\n            currentIndex -= 1;\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n        return array;\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Random);\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/Random.ts?");

/***/ }),

/***/ "./app/utils/SRandom.ts":
/*!******************************!*\
  !*** ./app/utils/SRandom.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst MAX_INT = 2 ** 32;\r\n// Decent pseudo random number generator based on:\r\n// https://en.wikipedia.org/wiki/Xorshift\r\n// Values seem fairly evenly distributed on [0, 1)\r\nfunction nextSeed(seed) {\r\n    let x = Math.floor(MAX_INT * seed);\r\n    x ^= x << 13;\r\n    x ^= x >> 17;\r\n    x ^= x << 5;\r\n    return (x / MAX_INT) + 0.5;\r\n}\r\nfunction numberToSeed(number) {\r\n    return nextSeed((Math.cos(number) + 1) / 2);\r\n}\r\n// Seeded random number generator.\r\nclass SRandom {\r\n    constructor(seed) {\r\n        this._seed = seed;\r\n    }\r\n    // Return an instance of SRandom with a seed based on the given value.\r\n    seed(value) {\r\n        return new SRandom(numberToSeed(value));\r\n    }\r\n    // Create a new seed based on the current seed and a given value.\r\n    addSeed(value) {\r\n        return this.seed(this._seed + value);\r\n    }\r\n    nextSeed() {\r\n        return new SRandom(nextSeed(this._seed));\r\n    }\r\n    random() {\r\n        return nextSeed(this._seed);\r\n    }\r\n    // This generates a random number and advances *this* geneator to the next seed.\r\n    generateAndMutate() {\r\n        this._seed = nextSeed(this._seed);\r\n        return this._seed;\r\n    }\r\n    /**\r\n     * @param {number} min  The smallest returned value\r\n     * @param {number} max  The largest returned value\r\n     */\r\n    range(A, B) {\r\n        var min = Math.min(A, B);\r\n        var max = Math.max(A, B);\r\n        return Math.floor(this.random() * (max + 1 - min)) + min;\r\n    }\r\n    /**\r\n     * @param {Collection} collection  The collection of elements to return random element from\r\n     */\r\n    element(collection) {\r\n        if (collection.constructor == Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = this.element(keys);\r\n            return object[key];\r\n        }\r\n        if (collection.constructor == Array) {\r\n            const array = collection;\r\n            return array[Math.floor(this.random() * array.length)];\r\n        }\r\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\r\n    }\r\n    /**\r\n     * @param {Array} array  The array of elements to return random element from\r\n     */\r\n    removeElement(collection) {\r\n        if (collection.constructor == Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = this.element(keys);\r\n            const value = object[key];\r\n            delete object[key];\r\n            return value;\r\n        }\r\n        if (collection.constructor == Array) {\r\n            const array = collection;\r\n            return array.splice(Math.floor(this.random() * array.length), 1)[0];\r\n        }\r\n        throw new Error(\"Warning @ Random.removeElement: \" + collection + \" is neither Array or Object\");\r\n    }\r\n    /**\r\n     * Shuffles an array.\r\n     *\r\n     * Knuth algorithm found at:\r\n     * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n     *\r\n     * @param {Array} array  The array of elements to shuffle\r\n     */\r\n    shuffle(array) {\r\n        let randomizer = this;\r\n        array = [...array];\r\n        let currentIndex = array.length, temporaryValue, randomIndex;\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(randomizer.random() * currentIndex);\r\n            randomizer = randomizer.nextSeed();\r\n            currentIndex -= 1;\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n;\r\nconst instance = new SRandom(0.5);\r\n// @ts-ignore\r\nwindow['SRandom'] = instance;\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/SRandom.ts?");

/***/ }),

/***/ "./app/utils/canvas.ts":
/*!*****************************!*\
  !*** ./app/utils/canvas.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCanvas: () => (/* binding */ createCanvas),\n/* harmony export */   createCanvasAndContext: () => (/* binding */ createCanvasAndContext),\n/* harmony export */   drawCanvas: () => (/* binding */ drawCanvas),\n/* harmony export */   mainCanvas: () => (/* binding */ mainCanvas),\n/* harmony export */   mainContext: () => (/* binding */ mainContext),\n/* harmony export */   require2dContext: () => (/* binding */ require2dContext)\n/* harmony export */ });\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n\r\nconst mainCanvas = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-mainCanvas');\r\n// @ts-ignore\r\nwindow['mainCanvas'] = mainCanvas;\r\n// mainCanvas.width = mainCanvas.height = 512;\r\nconst mainContext = require2dContext(mainCanvas);\r\n// mainContext.imageSmoothingEnabled = false;\r\n// @ts-ignore\r\nwindow['mainContext'] = mainContext;\r\nfunction require2dContext(canvas) {\r\n    const context = canvas.getContext('2d');\r\n    if (!context) {\r\n        throw new Error('Failed to get context');\r\n    }\r\n    return context;\r\n}\r\nfunction createCanvas(width, height, classes = '') {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.className = classes;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    return canvas;\r\n}\r\nfunction createCanvasAndContext(width, height) {\r\n    const canvas = createCanvas(width, height);\r\n    const context = require2dContext(canvas);\r\n    return [canvas, context];\r\n}\r\n/**\r\n * Safari (and possibly other browsers) will not draw canvases if the source\r\n * rectangle has any parts outside the dimensions of the actual canvas, so this\r\n * method takes arbitrary rectangles and then modifies them to only draw the\r\n * part that overlaps with the canvas.\r\n */\r\nfunction drawCanvas(context, canvas, { x, y, w, h }, { x: tx, y: ty, w: tw, h: th }) {\r\n    if (w > canvas.width - x) {\r\n        const dx = w - (canvas.width - x);\r\n        w += dx;\r\n        tw += dx;\r\n    }\r\n    if (h > canvas.height - y) {\r\n        const dy = h - (canvas.height - y);\r\n        h += dy;\r\n        th += dy;\r\n    }\r\n    if (x < 0) {\r\n        tx -= x;\r\n        tw += x;\r\n        w += x;\r\n        x = 0;\r\n    }\r\n    if (y < 0) {\r\n        ty -= y;\r\n        th += y;\r\n        h += y;\r\n        y = 0;\r\n    }\r\n    if (w > 0 && h > 0) {\r\n        context.drawImage(canvas, x, y, w, h, tx, ty, tw, th);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/canvas.ts?");

/***/ }),

/***/ "./app/utils/combat.ts":
/*!*****************************!*\
  !*** ./app/utils/combat.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abbreviate: () => (/* binding */ abbreviate),\n/* harmony export */   addDamageNumber: () => (/* binding */ addDamageNumber),\n/* harmony export */   applyArmorToDamage: () => (/* binding */ applyArmorToDamage),\n/* harmony export */   fixedDigits: () => (/* binding */ fixedDigits)\n/* harmony export */ });\nfunction addDamageNumber(state, target, damage, isCrit = false) {\r\n    state.fieldText.push({\r\n        x: target.x - 5 + Math.random() * 10,\r\n        y: target.y - 10,\r\n        vx: 2 * Math.random() - 1,\r\n        vy: -1,\r\n        text: abbreviate(damage),\r\n        color: isCrit ? 'yellow' : 'red',\r\n        borderColor: 'black',\r\n        expirationTime: state.fieldTime + 1000,\r\n        time: 0,\r\n    });\r\n}\r\nfunction applyArmorToDamage(state, damage, armor) {\r\n    return Math.max(Math.ceil(damage / 10), Math.round(damage - armor));\r\n}\r\nfunction fixedDigits(number, digits = 1) {\r\n    return parseFloat(number.toFixed(digits));\r\n}\r\nfunction abbreviate(number, digits) {\r\n    if (typeof (digits) === 'number') {\r\n        number = fixedDigits(number, digits);\r\n    }\r\n    if (number >= 1000000000000) {\r\n        return (number / 1000000000000 + '').slice(0, 4) + 'T';\r\n    }\r\n    if (number >= 1000000000) {\r\n        return (number / 1000000000 + '').slice(0, 4) + 'B';\r\n    }\r\n    if (number >= 1000000) {\r\n        return (number / 1000000 + '').slice(0, 4) + 'M';\r\n    }\r\n    if (number >= 10000) {\r\n        return (number / 1000 + '').slice(0, 4) + 'K';\r\n    }\r\n    return `${number}`;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/combat.ts?");

/***/ }),

/***/ "./app/utils/dom.ts":
/*!**************************!*\
  !*** ./app/utils/dom.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bodyDiv: () => (/* binding */ bodyDiv),\n/* harmony export */   divider: () => (/* binding */ divider),\n/* harmony export */   findEmptyElement: () => (/* binding */ findEmptyElement),\n/* harmony export */   getClosestElement: () => (/* binding */ getClosestElement),\n/* harmony export */   getDomRectCenter: () => (/* binding */ getDomRectCenter),\n/* harmony export */   getElementIndex: () => (/* binding */ getElementIndex),\n/* harmony export */   getElementRect: () => (/* binding */ getElementRect),\n/* harmony export */   handleChildEvent: () => (/* binding */ handleChildEvent),\n/* harmony export */   mainContent: () => (/* binding */ mainContent),\n/* harmony export */   mouseContainer: () => (/* binding */ mouseContainer),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryAll: () => (/* binding */ queryAll),\n/* harmony export */   tag: () => (/* binding */ tag),\n/* harmony export */   tagElement: () => (/* binding */ tagElement),\n/* harmony export */   titleDiv: () => (/* binding */ titleDiv),\n/* harmony export */   toggleElement: () => (/* binding */ toggleElement),\n/* harmony export */   toggleElements: () => (/* binding */ toggleElements)\n/* harmony export */ });\nfunction query(className) {\r\n    return document.querySelector(className);\r\n}\r\nfunction queryAll(className) {\r\n    return document.querySelectorAll(className);\r\n}\r\nconst mouseContainer = query('.js-mouseContainer');\r\nconst mainContent = query('.js-gameContent');\r\nfunction tag(type, classes = '', content = '') {\r\n    return '<' + type + ' class=\"' + classes + '\">' + content + '</' + type + '>';\r\n}\r\nfunction tagElement(type, classes = '', content = '') {\r\n    const element = document.createElement(type);\r\n    element.className = classes || '';\r\n    element.innerHTML = '' + (content || '');\r\n    return element;\r\n}\r\nconst divider = tag('div', 'centered medium', tag('div', 'divider'));\r\nfunction titleDiv(titleMarkup) {\r\n    return titleMarkup && tag('div', 'title', titleMarkup);\r\n}\r\nfunction bodyDiv(bodyMarkup) {\r\n    return bodyMarkup && tag('div', 'body', bodyMarkup);\r\n}\r\n;\r\nfunction findEmptyElement(elements) {\r\n    return [...elements].find(element => element.innerHTML === '');\r\n}\r\nfunction getDomRectCenter(r) {\r\n    return [r.x + r.width / 2, r.y + r.height / 2];\r\n}\r\nfunction getElementRect(element, container) {\r\n    let b = element.getBoundingClientRect();\r\n    const rect = { x: b.left, y: b.top, w: b.width, h: b.height };\r\n    // If container is specified, return the rectangle relative to the container's coordinates.\r\n    if (container) {\r\n        const containerRect = container.getBoundingClientRect();\r\n        rect.x -= containerRect.left;\r\n        rect.y -= containerRect.top;\r\n    }\r\n    return rect;\r\n}\r\nfunction getClosestElement(element, elements, threshold) {\r\n    let closestElement = null;\r\n    let closestDistanceSquared = threshold * threshold;\r\n    const center = getDomRectCenter(element.getBoundingClientRect());\r\n    elements.forEach(element => {\r\n        const elementCenter = getDomRectCenter(element.getBoundingClientRect());\r\n        const d2 = (center[0] - elementCenter[0]) ** 2 + (center[1] - elementCenter[1]) ** 2;\r\n        if (d2 <= closestDistanceSquared) {\r\n            closestDistanceSquared = d2;\r\n            closestElement = element;\r\n        }\r\n    });\r\n    return closestElement;\r\n}\r\nfunction toggleElements(elements, show) {\r\n    elements.forEach(element => toggleElement(element, show));\r\n}\r\nfunction toggleElement(element, show) {\r\n    element.style.display = show ? '' : 'none';\r\n}\r\nfunction handleChildEvent(eventType, container, selector, handler) {\r\n    container.addEventListener(eventType, event => {\r\n        const element = event.target;\r\n        const matchedElement = element.closest(selector);\r\n        if (matchedElement) {\r\n            return handler(matchedElement, event);\r\n        }\r\n    });\r\n}\r\nfunction getElementIndex(element) {\r\n    if (!element.parentElement) {\r\n        return -1;\r\n    }\r\n    return [...element.parentElement.children].indexOf(element);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/dom.ts?");

/***/ }),

/***/ "./app/utils/dungeon.ts":
/*!******************************!*\
  !*** ./app/utils/dungeon.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   activateDungeonPortal: () => (/* binding */ activateDungeonPortal),\n/* harmony export */   addDungeonPortalToDisc: () => (/* binding */ addDungeonPortalToDisc),\n/* harmony export */   addOverworldPortalToDisc: () => (/* binding */ addOverworldPortalToDisc),\n/* harmony export */   clearNearbyEnemies: () => (/* binding */ clearNearbyEnemies),\n/* harmony export */   createCaveDungeon: () => (/* binding */ createCaveDungeon),\n/* harmony export */   createDisc: () => (/* binding */ createDisc),\n/* harmony export */   createDungeon: () => (/* binding */ createDungeon),\n/* harmony export */   createReefDungeon: () => (/* binding */ createReefDungeon),\n/* harmony export */   createTreeDungeon: () => (/* binding */ createTreeDungeon),\n/* harmony export */   createWorldCell: () => (/* binding */ createWorldCell),\n/* harmony export */   dungeonTypes: () => (/* binding */ dungeonTypes),\n/* harmony export */   getCellCoordinates: () => (/* binding */ getCellCoordinates),\n/* harmony export */   getDungeonLevelBonus: () => (/* binding */ getDungeonLevelBonus),\n/* harmony export */   linkDiscs: () => (/* binding */ linkDiscs),\n/* harmony export */   projectDiscToClosestDisc: () => (/* binding */ projectDiscToClosestDisc),\n/* harmony export */   returnToOverworld: () => (/* binding */ returnToOverworld),\n/* harmony export */   startDungeon: () => (/* binding */ startDungeon),\n/* harmony export */   updateActiveCells: () => (/* binding */ updateActiveCells)\n/* harmony export */ });\n/* harmony import */ var app_bosses_guardian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/bosses/guardian */ \"./app/bosses/guardian.ts\");\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/enemies/bat */ \"./app/enemies/bat.ts\");\n/* harmony import */ var app_enemies_chaser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enemies/chaser */ \"./app/enemies/chaser.ts\");\n/* harmony import */ var app_enemies_chest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/enemies/chest */ \"./app/enemies/chest.ts\");\n/* harmony import */ var app_enemies_circler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/enemies/circler */ \"./app/enemies/circler.ts\");\n/* harmony import */ var app_enemies_clam__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/enemies/clam */ \"./app/enemies/clam.ts\");\n/* harmony import */ var app_enemies_crab__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/enemies/crab */ \"./app/enemies/crab.ts\");\n/* harmony import */ var app_enemies_lord__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/enemies/lord */ \"./app/enemies/lord.ts\");\n/* harmony import */ var app_enemies_slime__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/enemies/slime */ \"./app/enemies/slime.ts\");\n/* harmony import */ var app_enemies_squid__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/enemies/squid */ \"./app/enemies/squid.ts\");\n/* harmony import */ var app_enemies_turret__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/enemies/turret */ \"./app/enemies/turret.ts\");\n/* harmony import */ var app_enemies_urchin__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/enemies/urchin */ \"./app/enemies/urchin.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_SRandom__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! app/utils/SRandom */ \"./app/utils/SRandom.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst platformSizes = [200, 350, 500];\r\nconst dungeonTypes = ['reef', 'cave', 'tree'];\r\nfunction clearNearbyEnemies(state) {\r\n    updateActiveCells(state);\r\n    for (const enemy of state.enemies) {\r\n        if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_14__.getTargetVector)(state.hero, enemy).distance2 <= 1000 ** 2) {\r\n            // This will cause the enemy to be cleaned up when `updateActiveCells` is called again.\r\n            enemy.life = 0;\r\n        }\r\n    }\r\n    updateActiveCells(state);\r\n}\r\nfunction addDungeonPortalToDisc({ x, y }, type, level, seed = Math.random(), disc) {\r\n    const dungeon = createDungeon(type, level, seed);\r\n    const portal = {\r\n        x, y, radius: 40,\r\n        disc,\r\n        dungeon,\r\n        name: dungeon.name,\r\n        activate(state) {\r\n            activateDungeonPortal(state, this);\r\n        },\r\n    };\r\n    disc.portals.push(portal);\r\n    return portal;\r\n}\r\nfunction getDungeonLevelBonus(type) {\r\n    if (type === 'reef')\r\n        return 0;\r\n    if (type === 'cave')\r\n        return 1;\r\n    if (type === 'tree')\r\n        return 1;\r\n    return 2;\r\n}\r\nfunction createDungeon(type, level, seed = Math.random()) {\r\n    level = Math.max(0, Math.min(100, level + getDungeonLevelBonus(type)));\r\n    if (type === 'reef')\r\n        return createReefDungeon(seed, 2000 + 40 * level, level);\r\n    if (type === 'cave')\r\n        return createCaveDungeon(seed, 2000 + 40 * level, level);\r\n    return createTreeDungeon(seed, 2000 + 40 * level, level);\r\n}\r\nfunction returnToOverworld(state) {\r\n    var _a;\r\n    delete state.dungeon;\r\n    // If the player happens to leave during a boss fight, we have to clear the\r\n    // boss in order to automatically assign them to a different disc.\r\n    if ((_a = state.hero.disc) === null || _a === void 0 ? void 0 : _a.boss) {\r\n        delete state.hero.disc.boss;\r\n    }\r\n    state.hero.x = state.hero.overworldX;\r\n    state.hero.y = state.hero.overworldY;\r\n    clearNearbyEnemies(state);\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_15__.refillAllPotions)(state);\r\n}\r\nfunction addOverworldPortalToDisc({ x, y }, disc) {\r\n    const portal = {\r\n        x, y, radius: 40,\r\n        disc,\r\n        name: 'Overworld',\r\n        activate(state) {\r\n            returnToOverworld(state);\r\n        },\r\n    };\r\n    disc.portals.push(portal);\r\n    return portal;\r\n}\r\nfunction createDisc(props) {\r\n    return {\r\n        level: 1,\r\n        name: 'Shinsekai',\r\n        x: 0,\r\n        y: 0,\r\n        radius: 400,\r\n        links: [],\r\n        enemies: [],\r\n        portals: [],\r\n        loot: [],\r\n        ...props,\r\n    };\r\n}\r\nfunction getCellCoordinates(state, x = state.hero.x, y = state.hero.y) {\r\n    return {\r\n        x: Math.floor(x / app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE),\r\n        y: Math.floor(-y / app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE),\r\n    };\r\n}\r\nfunction addCellTohistory(state, cell) {\r\n    const index = state.recentCells.indexOf(cell);\r\n    if (index) {\r\n        state.recentCells.splice(index, 1);\r\n    }\r\n    state.recentCells.unshift(cell);\r\n    // Forget about cells that have not been active recently.\r\n    if (state.recentCells.length > 100) {\r\n        const ancientCell = state.recentCells.pop();\r\n        state.cellMap.delete(`${ancientCell.x}x${ancientCell.y}`);\r\n    }\r\n}\r\nfunction updateActiveCells(state) {\r\n    // Cells only apply when on the overworld.\r\n    if (!state.dungeon) {\r\n        state.activeDiscs = [];\r\n        state.activeCells = [];\r\n        const { x: minX, y: minY } = getCellCoordinates(state, state.hero.x - 3750, state.hero.y + 3750);\r\n        const { x: maxX, y: maxY } = getCellCoordinates(state, state.hero.x + 3750, state.hero.y - 3750);\r\n        for (let cellY = Math.max(0, minY); cellY <= maxY; cellY++) {\r\n            for (let cellX = minX; cellX <= maxX; cellX++) {\r\n                const cellKey = `${cellX}x${cellY}`;\r\n                const cell = state.cellMap.get(cellKey) || createWorldCell(state.worldSeed, { x: cellX, y: cellY });\r\n                addCellTohistory(state, cell);\r\n                state.cellMap.set(cellKey, cell);\r\n                state.activeCells.push(cell);\r\n                state.activeDiscs = [...state.activeDiscs, ...cell.discs];\r\n            }\r\n        }\r\n        state.visibleDiscs = state.activeDiscs;\r\n    }\r\n    state.enemies = [];\r\n    state.loot = [];\r\n    state.portals = [];\r\n    for (const disc of state.activeDiscs) {\r\n        disc.enemies = disc.enemies.filter(e => e.life > 0);\r\n        state.enemies = [\r\n            ...state.enemies,\r\n            ...disc.enemies,\r\n        ];\r\n        state.loot = [\r\n            ...state.loot,\r\n            ...disc.loot,\r\n        ];\r\n        state.portals = [\r\n            ...state.portals,\r\n            ...disc.portals,\r\n        ];\r\n    }\r\n}\r\nfunction getBiome(cellY) {\r\n    if (cellY === 0)\r\n        return 'Beach';\r\n    if (cellY === 1)\r\n        return 'Desert';\r\n    if (cellY <= 3) {\r\n        return 'Field';\r\n    }\r\n    if (cellY <= 5) { // Level 10\r\n        return 'Forest';\r\n    }\r\n    if (cellY <= 7) {\r\n        return 'Swamp';\r\n    }\r\n    if (cellY <= 9) { // Level 30\r\n        return 'Foothills';\r\n    }\r\n    if (cellY <= 11) {\r\n        return 'Mountains';\r\n    }\r\n    if (cellY <= 13) { // Level 50\r\n        return 'Frozen Peaks';\r\n    }\r\n    if (cellY <= 15) { // Level 60\r\n        return 'Descent';\r\n    }\r\n    if (cellY <= 17) { // Level 70\r\n        return 'Badlands';\r\n    }\r\n    if (cellY <= 19) { // Level 80\r\n        return 'Inferno';\r\n    }\r\n    // Level 90\r\n    return 'Abyss';\r\n}\r\nfunction getCellLevel(randomizer, cellY) {\r\n    if (cellY === 0) {\r\n        return 1;\r\n    }\r\n    if (cellY === 1) {\r\n        return randomizer.range(2, 3);\r\n    }\r\n    if (cellY <= 3) {\r\n        return randomizer.range(5, 8);\r\n    }\r\n    const baseLevel = Math.min(90, 10 * (Math.floor(cellY / 2) - 1));\r\n    return randomizer.range(baseLevel, baseLevel + 5);\r\n}\r\nfunction addOverworldEnemiesToDisc(randomizer, disc) {\r\n    if (disc.level === 1) {\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y, app_enemies_clam__WEBPACK_IMPORTED_MODULE_6__.clam, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y, app_enemies_urchin__WEBPACK_IMPORTED_MODULE_12__.urchin, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.4) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y - 100, app_enemies_crab__WEBPACK_IMPORTED_MODULE_7__.crab, disc.level, disc);\r\n            if (randomizer.generateAndMutate() < 0.2) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y + 100, app_enemies_crab__WEBPACK_IMPORTED_MODULE_7__.crab, disc.level, disc);\r\n            }\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.4) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x + 100, disc.y, app_enemies_squid__WEBPACK_IMPORTED_MODULE_10__.squid, disc.level, disc);\r\n            if (randomizer.generateAndMutate() < 0.2) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y - 100, app_enemies_squid__WEBPACK_IMPORTED_MODULE_10__.squid, disc.level, disc);\r\n            }\r\n        }\r\n    }\r\n    else if (disc.level === 2) {\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_11__.turret, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.1) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_4__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y - 100, app_enemies_slime__WEBPACK_IMPORTED_MODULE_9__.slime, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y + 100, app_enemies_slime__WEBPACK_IMPORTED_MODULE_9__.slime, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x + 100, disc.y, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_3__.chaser, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x - 100, disc.y, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_3__.chaser, disc.level, disc);\r\n        }\r\n    }\r\n    else if (disc.level === 3) {\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y, app_enemies_urchin__WEBPACK_IMPORTED_MODULE_12__.urchin, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.1) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_4__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y - 100, app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__.bat, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y + 100, app_enemies_crab__WEBPACK_IMPORTED_MODULE_7__.crab, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x + 100, disc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_9__.slime, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x - 100, disc.y, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_3__.chaser, disc.level, disc);\r\n        }\r\n    }\r\n    else {\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y, app_enemies_lord__WEBPACK_IMPORTED_MODULE_8__.lord, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y, app_enemies_urchin__WEBPACK_IMPORTED_MODULE_12__.urchin, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_11__.turret, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_4__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x - 50, disc.y, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_3__.chaser, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x + 50, disc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_9__.slime, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y + 50, app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__.bat, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(disc.x, disc.y - 50, app_enemies_crab__WEBPACK_IMPORTED_MODULE_7__.crab, disc.level, disc);\r\n        }\r\n    }\r\n}\r\nfunction createWorldCell(worldSeed, { x, y }) {\r\n    const discs = [];\r\n    const worldRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_16__[\"default\"].seed(worldSeed);\r\n    const hasNorthExit = worldRandomizer.addSeed((y + 1) * 1357).random() <= 0.5;\r\n    const hasSouthExit = y > 0 && worldRandomizer.addSeed(y * 1357).random() <= 0.5;\r\n    const cellRandomizer = worldRandomizer.addSeed(x * 37).addSeed(y * 29);\r\n    const level = getCellLevel(cellRandomizer, y);\r\n    const cellRadius = app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE / 2;\r\n    const name = getBiome(y);\r\n    const c = { x: app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE * (x + 0.5), y: -app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE * (y + 0.5) };\r\n    let discRandomizer = cellRandomizer.addSeed(79);\r\n    discs.push(createDisc({\r\n        level,\r\n        name,\r\n        x: c.x + (discRandomizer.generateAndMutate() - 0.5) * app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE / 10,\r\n        y: c.y + (discRandomizer.generateAndMutate() - 0.5) * app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE / 10,\r\n        radius: discRandomizer.element(platformSizes),\r\n    }));\r\n    const goalDiscs = [];\r\n    let westDisc = createDisc({\r\n        level,\r\n        name,\r\n        x: c.x - cellRadius,\r\n        y: c.y,\r\n        radius: 400,\r\n    });\r\n    goalDiscs.push(westDisc);\r\n    goalDiscs.push(createDisc({\r\n        level,\r\n        name,\r\n        x: app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE,\r\n        y: c.y,\r\n        radius: 400,\r\n    }));\r\n    let northDisc;\r\n    if (hasNorthExit) {\r\n        goalDiscs.push(northDisc = createDisc({\r\n            level,\r\n            name,\r\n            x: c.x,\r\n            y: c.y - cellRadius,\r\n            radius: 400,\r\n        }));\r\n    }\r\n    if (hasSouthExit) {\r\n        goalDiscs.push(createDisc({\r\n            level,\r\n            name,\r\n            x: c.x,\r\n            y: app_constants__WEBPACK_IMPORTED_MODULE_1__.CELL_SIZE,\r\n            radius: 400,\r\n        }));\r\n    }\r\n    for (let i = 0; i < 200 && (goalDiscs.length || i < 10); i++) {\r\n        const theta = 2 * Math.PI * discRandomizer.generateAndMutate();\r\n        const newDisc = createDisc({\r\n            level,\r\n            name,\r\n            x: c.x + cellRadius * Math.cos(theta),\r\n            y: c.y + cellRadius * Math.sin(theta),\r\n            radius: discRandomizer.element(platformSizes),\r\n        });\r\n        projectDiscToClosestDisc(discs, newDisc, discRandomizer.range(16, 128));\r\n        if ((newDisc.x - c.x) ** 2 + (newDisc.y - c.y) ** 2 >= cellRadius * cellRadius) {\r\n            continue;\r\n        }\r\n        for (let j = 0; j < goalDiscs.length; j++) {\r\n            const goalDisc = goalDiscs[j];\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_14__.getTargetVector)(goalDisc, newDisc);\r\n            if (distance2 <= (goalDisc.radius + newDisc.radius - 16) ** 2) {\r\n                goalDiscs.splice(j--, 1);\r\n            }\r\n        }\r\n        addOverworldEnemiesToDisc(discRandomizer, newDisc);\r\n        discs.push(newDisc);\r\n    }\r\n    discs.push(westDisc);\r\n    if (northDisc) {\r\n        discs.push(northDisc);\r\n    }\r\n    linkDiscs(discs);\r\n    return {\r\n        level,\r\n        x, y,\r\n        discs,\r\n    };\r\n}\r\nfunction createTreeDungeon(seed, radius, level) {\r\n    const name = 'Tree';\r\n    const discs = [];\r\n    const entrance = { x: 0, y: 0, radius: 16 };\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_16__[\"default\"].seed(seed);\r\n    const startingPlatform = createDisc({\r\n        level,\r\n        name,\r\n        x: entrance.x,\r\n        y: entrance.y,\r\n        radius: 400,\r\n    });\r\n    addOverworldPortalToDisc(entrance, startingPlatform);\r\n    discs.push(startingPlatform);\r\n    let finished = false;\r\n    for (let i = 0; i < 100 && (!finished || i < 20); i++) {\r\n        dungeonRandomizer.nextSeed();\r\n        const theta = 2 * Math.PI * dungeonRandomizer.generateAndMutate();\r\n        const newDisc = createDisc({\r\n            level,\r\n            name,\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: dungeonRandomizer.element(platformSizes),\r\n        });\r\n        projectDiscToClosestDisc(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n        if (newDisc.x * newDisc.x + newDisc.y * newDisc.y >= radius * radius) {\r\n            // Only one disc is allowed to spawn outside of the radius.\r\n            if (!finished) {\r\n                finished = true;\r\n                newDisc.radius = 400;\r\n                projectDiscToClosestDisc(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n                newDisc.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_bosses_guardian__WEBPACK_IMPORTED_MODULE_0__.guardian, Math.min(100, level + 2), newDisc);\r\n                newDisc.boss.isBoss = true;\r\n                discs.push(newDisc);\r\n            }\r\n            continue;\r\n        }\r\n        discs.push(newDisc);\r\n        // TODO: Add different enemy generators and apply them at random.\r\n        if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_11__.turret, level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_enemies_lord__WEBPACK_IMPORTED_MODULE_8__.lord, level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_4__.chest, level + 1, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x + 50, newDisc.y, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_3__.chaser, level, newDisc);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x - 50, newDisc.y, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_3__.chaser, level, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y + 50, app_enemies_circler__WEBPACK_IMPORTED_MODULE_5__.circler, level, newDisc);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y - 50, app_enemies_circler__WEBPACK_IMPORTED_MODULE_5__.circler, level, newDisc);\r\n        }\r\n    }\r\n    linkDiscs(discs);\r\n    return {\r\n        name,\r\n        level,\r\n        discs,\r\n        entrance,\r\n    };\r\n}\r\nfunction createReefDungeon(seed, radius, level) {\r\n    const name = 'Reef';\r\n    const discs = [];\r\n    const entrance = { x: 0, y: radius, radius: 16 };\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_16__[\"default\"].seed(seed);\r\n    const startingPlatform = createDisc({\r\n        level,\r\n        name,\r\n        x: entrance.x,\r\n        y: entrance.y,\r\n        radius: 400,\r\n    });\r\n    addOverworldPortalToDisc(entrance, startingPlatform);\r\n    discs.push(startingPlatform);\r\n    let finished = false;\r\n    for (let i = 0; i < 100 && (!finished || i < 10); i++) {\r\n        dungeonRandomizer.nextSeed();\r\n        const theta = 5 * Math.PI / 4 + Math.PI * dungeonRandomizer.generateAndMutate() / 2;\r\n        const newDisc = createDisc({\r\n            level,\r\n            name,\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: dungeonRandomizer.element(platformSizes),\r\n        });\r\n        projectDiscToClosestDisc(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n        if (newDisc.x * newDisc.x + newDisc.y * newDisc.y >= radius * radius) {\r\n            // Only one disc is allowed to spawn outside of the radius.\r\n            if (!finished) {\r\n                finished = true;\r\n                newDisc.radius = 400;\r\n                projectDiscToClosestDisc(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n                newDisc.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_enemies_clam__WEBPACK_IMPORTED_MODULE_6__.giantClam, Math.min(100, level + 2), newDisc);\r\n                newDisc.boss.isBoss = true;\r\n                discs.push(newDisc);\r\n            }\r\n            continue;\r\n        }\r\n        discs.push(newDisc);\r\n        // TODO: Add different enemy generators and apply them at random.\r\n        if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_enemies_urchin__WEBPACK_IMPORTED_MODULE_12__.urchin, level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_enemies_clam__WEBPACK_IMPORTED_MODULE_6__.clam, level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_4__.chest, level + 1, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x + 50, newDisc.y, app_enemies_crab__WEBPACK_IMPORTED_MODULE_7__.crab, level, newDisc);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x - 50, newDisc.y, app_enemies_crab__WEBPACK_IMPORTED_MODULE_7__.crab, level, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y + 50, app_enemies_crab__WEBPACK_IMPORTED_MODULE_7__.crab, level, newDisc);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y - 50, app_enemies_crab__WEBPACK_IMPORTED_MODULE_7__.crab, level, newDisc);\r\n        }\r\n    }\r\n    linkDiscs(discs);\r\n    return {\r\n        name,\r\n        level,\r\n        discs,\r\n        entrance,\r\n    };\r\n}\r\nfunction createCaveDungeon(seed, radius, level) {\r\n    const name = 'Cave';\r\n    const discs = [];\r\n    const entrance = { x: 0, y: 0, radius: 16 };\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_16__[\"default\"].seed(seed);\r\n    const startingPlatform = createDisc({\r\n        level,\r\n        name,\r\n        x: entrance.x,\r\n        y: entrance.y,\r\n        radius: 400,\r\n    });\r\n    addOverworldPortalToDisc(entrance, startingPlatform);\r\n    discs.push(startingPlatform);\r\n    let finished = false;\r\n    let theta = Math.PI / 2;\r\n    for (let i = 0; i < 100 && (!finished || i < 12); i++) {\r\n        theta += Math.PI / 24 + Math.PI / 12 * dungeonRandomizer.generateAndMutate();\r\n        const newDisc = createDisc({\r\n            level,\r\n            name,\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: dungeonRandomizer.element(platformSizes),\r\n        });\r\n        projectDiscToClosestDisc(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n        if (newDisc.x * newDisc.x + newDisc.y * newDisc.y >= radius * radius) {\r\n            // Only one disc is allowed to spawn outside of the radius.\r\n            if (!finished) {\r\n                finished = true;\r\n                newDisc.radius = 400;\r\n                projectDiscToClosestDisc(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n                newDisc.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_9__.megaSlime, Math.min(100, level + 2), newDisc);\r\n                newDisc.boss.isBoss = true;\r\n                discs.push(newDisc);\r\n            }\r\n            continue;\r\n        }\r\n        discs.push(newDisc);\r\n        // TODO: Add different enemy generators and apply them at random.\r\n        if (dungeonRandomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_9__.greatSlime, level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_4__.chest, level + 1, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x + 50, newDisc.y, app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__.bat, level, newDisc);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x - 50, newDisc.y, app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__.bat, level, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y + 50, app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__.bat, level, newDisc);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_13__.createEnemy)(newDisc.x, newDisc.y - 50, app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__.bat, level, newDisc);\r\n        }\r\n    }\r\n    linkDiscs(discs);\r\n    return {\r\n        name,\r\n        level,\r\n        discs,\r\n        entrance,\r\n    };\r\n}\r\nfunction activateDungeonPortal(state, portal) {\r\n    const dungeon = portal.dungeon;\r\n    if (!dungeon) {\r\n        return;\r\n    }\r\n    // Remove this portal when it is used.\r\n    portal.disc.portals = portal.disc.portals.filter(p => p !== portal);\r\n    startDungeon(state, dungeon);\r\n}\r\nfunction startDungeon(state, dungeon) {\r\n    if (!dungeon) {\r\n        return;\r\n    }\r\n    if (!state.dungeon) {\r\n        state.hero.overworldX = state.hero.x;\r\n        state.hero.overworldY = state.hero.y;\r\n    }\r\n    // Remove this portal when it is used.\r\n    state.dungeon = dungeon;\r\n    state.hero.x = dungeon.entrance.x;\r\n    state.hero.y = dungeon.entrance.y;\r\n    state.activeDiscs = dungeon.discs;\r\n    state.visibleDiscs = dungeon.discs;\r\n    updateActiveCells(state);\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_15__.refillAllPotions)(state);\r\n}\r\nfunction projectDiscToClosestDisc(discs, newDisc, overlap) {\r\n    const closestDisc = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_14__.findClosestDisc)(newDisc, discs);\r\n    const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_14__.getTargetVector)(closestDisc, newDisc);\r\n    const m = Math.sqrt(distance2);\r\n    const distance = closestDisc.radius + newDisc.radius - overlap;\r\n    newDisc.x = closestDisc.x + x / m * distance;\r\n    newDisc.y = closestDisc.y + y / m * distance;\r\n}\r\nfunction linkDiscs(discs) {\r\n    for (let i = 0; i < discs.length; i++) {\r\n        const disc = discs[i];\r\n        for (let j = i + 1; j < discs.length; j++) {\r\n            const otherDisc = discs[j];\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_14__.getTargetVector)(disc, otherDisc);\r\n            const minDistance = disc.radius + otherDisc.radius - 16;\r\n            if (distance2 <= minDistance * minDistance) {\r\n                disc.links.push(otherDisc);\r\n                otherDisc.links.push(disc);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/dungeon.ts?");

/***/ }),

/***/ "./app/utils/enemy.ts":
/*!****************************!*\
  !*** ./app/utils/enemy.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chaseTarget: () => (/* binding */ chaseTarget),\n/* harmony export */   createEnemy: () => (/* binding */ createEnemy),\n/* harmony export */   getEnemyColor: () => (/* binding */ getEnemyColor),\n/* harmony export */   isEnemyOffDisc: () => (/* binding */ isEnemyOffDisc),\n/* harmony export */   moveEnemyInCurrentDirection: () => (/* binding */ moveEnemyInCurrentDirection),\n/* harmony export */   moveEnemyInDirection: () => (/* binding */ moveEnemyInDirection),\n/* harmony export */   moveEnemyToTarget: () => (/* binding */ moveEnemyToTarget),\n/* harmony export */   shootBulletArc: () => (/* binding */ shootBulletArc),\n/* harmony export */   shootBulletAtHero: () => (/* binding */ shootBulletAtHero),\n/* harmony export */   shootBulletCircle: () => (/* binding */ shootBulletCircle),\n/* harmony export */   shootCirclingBullet: () => (/* binding */ shootCirclingBullet),\n/* harmony export */   shootEnemyBullet: () => (/* binding */ shootEnemyBullet),\n/* harmony export */   turnTowardsTarget: () => (/* binding */ turnTowardsTarget)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n\r\n\r\n\r\nfunction createEnemy(x, y, definition, level, disc) {\r\n    var _a, _b, _c, _d, _e;\r\n    const heroBaseWeaponDamage = level * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_WEAPON_DPS_PER_LEVEL;\r\n    const heroLevelDamageFactor = Math.pow(1.05, level);\r\n    const heroWeaponProficiencyDamageFactor = Math.pow(1.05, level);\r\n    const heroDamage = Math.ceil(heroBaseWeaponDamage * heroLevelDamageFactor * heroWeaponProficiencyDamageFactor);\r\n    // This includes attack speed gain from both level and weapon proficiency\r\n    const heroAttacksPerSecond = 1 + 0.02 * level;\r\n    const heroMaxLife = 20 * (level + 1);\r\n    const dps = heroAttacksPerSecond * heroDamage;\r\n    const targetDuration = 1 + level * 10 / 100;\r\n    const maxLife = Math.ceil((dps * targetDuration) * ((_a = definition.statFactors.maxLife) !== null && _a !== void 0 ? _a : 1));\r\n    const baseArmor = 2 * level * ((_b = definition.statFactors.armor) !== null && _b !== void 0 ? _b : 1);\r\n    const enemy = {\r\n        definition,\r\n        disc,\r\n        params: { ...definition.initialParams },\r\n        x,\r\n        y,\r\n        vx: 0,\r\n        vy: 0,\r\n        maxLife,\r\n        life: maxLife,\r\n        level,\r\n        baseColor: getEnemyColor(level),\r\n        speed: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED * ((_c = definition.statFactors.speed) !== null && _c !== void 0 ? _c : 1) * (0.9 + 0.2 * Math.random()),\r\n        baseArmor,\r\n        armor: baseArmor,\r\n        damage: Math.floor((heroMaxLife / 10 + heroMaxLife / 10 * level / 100 + 1.5 * level) * ((_d = definition.statFactors.damage) !== null && _d !== void 0 ? _d : 1)),\r\n        attacksPerSecond: (1 + 0.03 * level) * ((_e = definition.statFactors.attacksPerSecond) !== null && _e !== void 0 ? _e : 1),\r\n        attackCooldown: 0,\r\n        radius: definition.radius,\r\n        theta: 0,\r\n        minions: [],\r\n        chargingLevel: 1,\r\n        attackChargeLevel: 1,\r\n        mode: 'choose',\r\n        modeTime: 0,\r\n        isInvulnerable: definition.isInvulnerable,\r\n        setMode(mode) {\r\n            this.mode = mode;\r\n            this.modeTime = 0;\r\n        }\r\n    };\r\n    disc.enemies.push(enemy);\r\n    return enemy;\r\n}\r\nfunction getEnemyColor(level) {\r\n    if (level === 1) {\r\n        return 'lightBlue';\r\n    }\r\n    if (level <= 3) {\r\n        return 'lightGreen';\r\n    }\r\n    if (level < 10) {\r\n        return 'orange';\r\n    }\r\n    if (level < 20) {\r\n        return 'red';\r\n    }\r\n    if (level < 30) {\r\n        return 'purple';\r\n    }\r\n    if (level < 40) {\r\n        return 'grey';\r\n    }\r\n    if (level < 50) {\r\n        return 'green';\r\n    }\r\n    if (level < 60) {\r\n        return '#FF0';\r\n    }\r\n    if (level < 70) {\r\n        return '#F0F';\r\n    }\r\n    if (level < 80) {\r\n        return '#0FF';\r\n    }\r\n    if (level < 90) {\r\n        return 'silver';\r\n    }\r\n    return 'gold';\r\n}\r\nfunction shootEnemyBullet(state, enemy, vx, vy, stats = {}) {\r\n    //const mag = Math.sqrt(vx * vx + vy * vy);\r\n    state.enemyBullets.push({\r\n        time: 0,\r\n        //x: enemy.x + vx / mag * enemy.radius,\r\n        //y: enemy.y + vy / mag * enemy.radius,\r\n        baseX: enemy.x,\r\n        baseY: enemy.y,\r\n        x: enemy.x,\r\n        y: enemy.y,\r\n        damage: enemy.damage,\r\n        radius: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS,\r\n        vx,\r\n        vy,\r\n        expirationTime: state.fieldTime + app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_DURATION,\r\n        update: app_weapons__WEBPACK_IMPORTED_MODULE_2__.updateSimpleBullet,\r\n        hitTargets: new Set(),\r\n        // Armor shred is not functional against the player, although maybe it could be added\r\n        // with player recovering armor over time.\r\n        armorShred: 0,\r\n        ...stats,\r\n    });\r\n}\r\nfunction shootCirclingBullet(state, enemy, theta, radius, stats = {}) {\r\n    //const mag = Math.sqrt(vx * vx + vy * vy);\r\n    state.enemyBullets.push({\r\n        time: 0,\r\n        //x: enemy.x + vx / mag * enemy.radius,\r\n        //y: enemy.y + vy / mag * enemy.radius,\r\n        baseX: enemy.x,\r\n        baseY: enemy.y,\r\n        x: enemy.x,\r\n        y: enemy.y,\r\n        source: enemy,\r\n        damage: enemy.damage,\r\n        radius: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS,\r\n        vx: 0,\r\n        vy: 0,\r\n        orbitRadius: radius,\r\n        theta,\r\n        vTheta: 2 * Math.PI,\r\n        expirationTime: state.fieldTime + app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_DURATION,\r\n        update: updateCirclingBullet,\r\n        hitTargets: new Set(),\r\n        // Armor shred is not functional against the player, although maybe it could be added\r\n        // with player recovering armor over time.\r\n        armorShred: 0,\r\n        ...stats,\r\n    });\r\n}\r\nfunction updateCirclingBullet(state, bullet) {\r\n    if (!bullet.source\r\n        || typeof (bullet.theta) !== 'number'\r\n        || typeof (bullet.vTheta) !== 'number'\r\n        || typeof (bullet.orbitRadius) !== 'number') {\r\n        return;\r\n    }\r\n    bullet.theta += app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH * bullet.vTheta / 1000;\r\n    bullet.x = bullet.source.x + bullet.orbitRadius * Math.cos(bullet.theta);\r\n    bullet.y = bullet.source.y + bullet.orbitRadius * Math.sin(bullet.theta);\r\n}\r\nfunction shootBulletArc(state, enemy, theta, angle, count, speed, stats = {}) {\r\n    for (let i = 0; i < count; i++) {\r\n        const bulletTheta = count > 1 ? (theta - angle / 2 + angle * i / (count - 1)) : theta;\r\n        shootEnemyBullet(state, enemy, speed * Math.cos(bulletTheta), speed * Math.sin(bulletTheta), stats);\r\n    }\r\n}\r\nfunction shootBulletCircle(state, enemy, theta, count, speed, stats = {}) {\r\n    for (let i = 0; i < count; i++) {\r\n        const bulletTheta = theta + 2 * Math.PI * i / count;\r\n        shootEnemyBullet(state, enemy, speed * Math.cos(bulletTheta), speed * Math.sin(bulletTheta), stats);\r\n    }\r\n}\r\nfunction isEnemyOffDisc(state, enemy) {\r\n    return enemy.disc && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__.getTargetVector)(enemy, enemy.disc).distance2 >= enemy.disc.radius ** 2;\r\n}\r\nfunction shootBulletAtHero(state, enemy, speed, stats = {}) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__.getTargetVector)(enemy, state.hero);\r\n    const theta = Math.atan2(y, x);\r\n    shootEnemyBullet(state, enemy, speed * Math.cos(theta), speed * Math.sin(theta), stats);\r\n}\r\nfunction moveEnemyInCurrentDirection(state, enemy, speed = enemy.speed) {\r\n    enemy.x += speed * Math.cos(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n    enemy.y += speed * Math.sin(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n}\r\nfunction moveEnemyInDirection(state, enemy, theta = enemy.theta, speed = enemy.speed) {\r\n    enemy.x += speed * Math.cos(theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n    enemy.y += speed * Math.sin(theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n}\r\nfunction turnTowardsTarget(state, enemy, target, turnSpeed = 0.2) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__.getTargetVector)(enemy, target);\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__.turnTowardsAngle)(enemy.theta, turnSpeed, Math.atan2(y, x));\r\n}\r\nfunction chaseTarget(state, enemy, target, speed = enemy.speed) {\r\n    turnTowardsTarget(state, enemy, target);\r\n    moveEnemyInDirection(state, enemy, enemy.theta, speed);\r\n}\r\nfunction moveEnemyToTarget(state, enemy, { x, y }, speed = enemy.speed) {\r\n    const dx = x - enemy.x, dy = y - enemy.y;\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(dy, dx));\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    enemy.x += Math.min(speed / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH, distance) * Math.cos(enemy.theta);\r\n    enemy.y += Math.min(speed / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH, distance) * Math.sin(enemy.theta);\r\n    return distance <= speed / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/enemy.ts?");

/***/ }),

/***/ "./app/utils/geometry.ts":
/*!*******************************!*\
  !*** ./app/utils/geometry.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doCirclesIntersect: () => (/* binding */ doCirclesIntersect),\n/* harmony export */   findClosestDisc: () => (/* binding */ findClosestDisc),\n/* harmony export */   getClosestElement: () => (/* binding */ getClosestElement),\n/* harmony export */   getTargetVector: () => (/* binding */ getTargetVector),\n/* harmony export */   isPointInRect: () => (/* binding */ isPointInRect),\n/* harmony export */   turnTowardsAngle: () => (/* binding */ turnTowardsAngle)\n/* harmony export */ });\nfunction isPointInRect({ x, y, w, h }, p) {\r\n    return p.x >= x && p.x <= (x + w) && p.y >= y && p.y <= (y + h);\r\n}\r\nfunction doCirclesIntersect(circleA, circleB) {\r\n    const radius = circleA.radius + circleB.radius;\r\n    const dx = circleB.x - circleA.x, dy = circleB.y - circleA.y;\r\n    return dx * dx + dy * dy < radius * radius;\r\n}\r\nfunction findClosestDisc({ x, y }, discs) {\r\n    let closestDistance2 = Number.MAX_SAFE_INTEGER, closestDisc = discs[0];\r\n    for (const disc of discs) {\r\n        const dx = disc.x - x, dy = disc.y - y;\r\n        const distance2 = dx * dx + dy * dy - disc.radius * disc.radius;\r\n        if (distance2 < closestDistance2) {\r\n            closestDistance2 = distance2;\r\n            closestDisc = disc;\r\n        }\r\n    }\r\n    return closestDisc;\r\n}\r\nfunction getClosestElement({ x, y }, elements) {\r\n    let closestDistance2 = Number.MAX_SAFE_INTEGER, closestElement = elements[0];\r\n    for (const element of elements) {\r\n        const dx = element.x - x, dy = element.y - y;\r\n        const distance2 = dx * dx + dy * dy - element.radius * element.radius;\r\n        if (distance2 < closestDistance2) {\r\n            closestDistance2 = distance2;\r\n            closestElement = element;\r\n        }\r\n    }\r\n    return closestElement;\r\n}\r\nfunction getTargetVector(circleA, circleB) {\r\n    const dx = circleB.x - circleA.x, dy = circleB.y - circleA.y;\r\n    const distance2 = dx * dx + dy * dy;\r\n    if (distance2 <= 0) {\r\n        return { x: 1, y: 0, distance2: 0 };\r\n    }\r\n    return { x: dx, y: dy, distance2 };\r\n}\r\nfunction turnTowardsAngle(theta, delta, targetTheta) {\r\n    const negativeDistance = (theta - targetTheta + 2 * Math.PI) % (2 * Math.PI);\r\n    const positiveDistance = (targetTheta - theta + 2 * Math.PI) % (2 * Math.PI);\r\n    if (negativeDistance <= delta || positiveDistance <= delta) {\r\n        return targetTheta;\r\n    }\r\n    if (negativeDistance < positiveDistance) {\r\n        return theta - delta;\r\n    }\r\n    return theta + delta;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/geometry.ts?");

/***/ }),

/***/ "./app/utils/hero.ts":
/*!***************************!*\
  !*** ./app/utils/hero.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   damageHero: () => (/* binding */ damageHero),\n/* harmony export */   gainExperience: () => (/* binding */ gainExperience),\n/* harmony export */   gainItemExperience: () => (/* binding */ gainItemExperience),\n/* harmony export */   gainWeaponExperience: () => (/* binding */ gainWeaponExperience),\n/* harmony export */   getExperienceForNextLevel: () => (/* binding */ getExperienceForNextLevel),\n/* harmony export */   getExperienceForNextWeaponLevel: () => (/* binding */ getExperienceForNextWeaponLevel),\n/* harmony export */   getWeaponProficiency: () => (/* binding */ getWeaponProficiency),\n/* harmony export */   refillAllPotions: () => (/* binding */ refillAllPotions),\n/* harmony export */   rollForCritDamage: () => (/* binding */ rollForCritDamage),\n/* harmony export */   setDerivedHeroStats: () => (/* binding */ setDerivedHeroStats)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_utils_combat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/combat */ \"./app/utils/combat.ts\");\n\r\n\r\n\r\nfunction gainExperience(state, experience) {\r\n    const requiredExperience = getExperienceForNextLevel(state.hero.level);\r\n    // You cannot gain more than 100% of the experience for the next level at once.\r\n    state.hero.experience += Math.min(experience, requiredExperience);\r\n    if (state.hero.experience >= requiredExperience) {\r\n        state.hero.level++;\r\n        state.hero.experience -= requiredExperience;\r\n        setDerivedHeroStats(state);\r\n        refillAllPotions(state);\r\n    }\r\n}\r\nfunction gainWeaponExperience(state, weaponType, sourceLevel, experience) {\r\n    const weaponProficiency = getWeaponProficiency(state, weaponType);\r\n    const weaponXpPenalty = Math.min(1, Math.max(0, (weaponProficiency.level - sourceLevel) * 0.1));\r\n    const requiredExperience = getExperienceForNextWeaponLevel(weaponProficiency.level);\r\n    // You cannot gain more than 10% of the experience for the next weapon level at once.\r\n    weaponProficiency.experience += Math.min(Math.ceil(experience * (1 - weaponXpPenalty)), requiredExperience / 5);\r\n    if (weaponProficiency.experience >= requiredExperience) {\r\n        weaponProficiency.level++;\r\n        weaponProficiency.experience -= requiredExperience;\r\n        setDerivedHeroStats(state);\r\n    }\r\n}\r\nfunction getWeaponProficiency(state, weaponType = state.hero.equipment.weapon.weaponType) {\r\n    return state.hero.weaponProficiency[weaponType] = state.hero.weaponProficiency[weaponType] || { level: 0, experience: 0 };\r\n}\r\nfunction gainItemExperience(state, item) {\r\n    const experiencePenalty = Math.min(1, Math.max(0, (state.hero.level - item.level) * 0.1));\r\n    const experience = app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_XP * Math.pow(1.2, item.level) * 1.5;\r\n    gainExperience(state, Math.ceil(experience * (1 - experiencePenalty)));\r\n    if (item.type === 'weapon') {\r\n        gainWeaponExperience(state, item.weaponType, item.level, 2 * experience);\r\n    }\r\n}\r\nfunction setDerivedHeroStats(state) {\r\n    const weaponLevel = state.hero.equipment.weapon.level;\r\n    const weaponProficiency = getWeaponProficiency(state);\r\n    state.hero.damage = Math.pow(1.05, state.hero.level - 1 + weaponProficiency.level - 1);\r\n    state.hero.attacksPerSecond = 1 + 0.01 * state.hero.level + 0.01 * weaponProficiency.level;\r\n    // If weapon level is higher than your proficiency, attack speed is reduced down to a minimum of 10% base attack speed.\r\n    const proficiencyDefecit = weaponLevel - weaponProficiency.level;\r\n    if (proficiencyDefecit > 0) {\r\n        state.hero.attacksPerSecond = state.hero.attacksPerSecond * Math.max(0.1, 0.95 ** proficiencyDefecit);\r\n    }\r\n    const lifePercentage = state.hero.life / state.hero.maxLife;\r\n    state.hero.maxLife = 20 * state.hero.level;\r\n    state.hero.armor = 0;\r\n    state.hero.speed = 100;\r\n    state.hero.potionEffect = 1;\r\n    const armor = state.hero.equipment.armor;\r\n    if (armor) {\r\n        state.hero.maxLife += armor.life;\r\n        state.hero.armor += armor.armor;\r\n        state.hero.speed *= armor.speedFactor;\r\n    }\r\n    else {\r\n        state.hero.speed *= 1.2;\r\n    }\r\n    // Bow gives 0.1% -> 10% increased crit chance\r\n    state.hero.critChance = getWeaponProficiency(state, 'bow').level * 0.001;\r\n    // Dagger gives +0.01 -> 1 increased base attacks per second\r\n    state.hero.attacksPerSecond += getWeaponProficiency(state, 'dagger').level * 0.01;\r\n    // Katana gives 1% -> 100% increased crit damage\r\n    state.hero.critDamage = getWeaponProficiency(state, 'katana').level * 0.01;\r\n    // Morning Star gives +0.01 -> 1 increased armor shred effect\r\n    state.hero.armorShredEffect = 1 + getWeaponProficiency(state, 'morningStar').level * 0.01;\r\n    // Staff gives +0.01 -> 1 increased charge damage\r\n    state.hero.chargeDamage = getWeaponProficiency(state, 'staff').level * 0.01;\r\n    // Sword gives 1% -> 100% increased damage\r\n    state.hero.damage *= (1 + getWeaponProficiency(state, 'sword').level * 0.01);\r\n    // Enchantments are applied last to stats.\r\n    (0,app_enchantments__WEBPACK_IMPORTED_MODULE_1__.applyEnchantmentsToStats)(state);\r\n    // Make sure updating stats doesn't change the hero's life percentage beyond rounding it.\r\n    state.hero.life = Math.round(lifePercentage * state.hero.maxLife);\r\n}\r\nfunction getExperienceForNextLevel(currentLevel) {\r\n    const averageKills = 8 * currentLevel;\r\n    const xpPerKill = Math.ceil(app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_XP * Math.pow(1.2, currentLevel - 1));\r\n    return averageKills * xpPerKill;\r\n}\r\nfunction getExperienceForNextWeaponLevel(currentLevel) {\r\n    const averageKills = 4 * (currentLevel + 1);\r\n    const xpPerKill = Math.ceil(app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_XP * Math.pow(1.2, currentLevel));\r\n    return averageKills * xpPerKill;\r\n}\r\nfunction refillAllPotions(state) {\r\n    state.hero.life = state.hero.maxLife;\r\n    state.hero.potions = app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_MAX_POTIONS;\r\n}\r\nfunction damageHero(state, damage) {\r\n    damage = (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_2__.applyArmorToDamage)(state, damage, state.hero.armor);\r\n    // Incoming damage is limited by both the amount of the damage and the players total health.\r\n    // Shots that deal X damage only deal damage if the player has taken less than 2X damage recently.\r\n    // A player cannot take more than 50% of their health over their recorded damage history.\r\n    const damageCap = Math.min(Math.floor(state.hero.maxLife / 2), 2 * damage);\r\n    const damageTaken = Math.max(0, Math.min(damage, damageCap - state.hero.recentDamageTaken));\r\n    state.hero.life -= damageTaken;\r\n    if (state.hero.life < 0) {\r\n        state.hero.life = 0;\r\n    }\r\n    state.hero.damageHistory[0] += damageTaken;\r\n    state.hero.recentDamageTaken += damageTaken;\r\n    (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_2__.addDamageNumber)(state, state.hero, damageTaken);\r\n}\r\nfunction rollForCritDamage(state, additionalCritchance = 0) {\r\n    const weapon = state.hero.equipment.weapon;\r\n    const isCrit = Math.random() < additionalCritchance + state.hero.critChance + weapon.critChance;\r\n    if (!isCrit) {\r\n        return 1;\r\n    }\r\n    return 1 + state.hero.critDamage + weapon.critDamage;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/hero.ts?");

/***/ }),

/***/ "./app/utils/mouse.ts":
/*!****************************!*\
  !*** ./app/utils/mouse.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addContextMenuListeners: () => (/* binding */ addContextMenuListeners),\n/* harmony export */   bindMouseListeners: () => (/* binding */ bindMouseListeners),\n/* harmony export */   getMousePosition: () => (/* binding */ getMousePosition),\n/* harmony export */   isMiddleMouseDown: () => (/* binding */ isMiddleMouseDown),\n/* harmony export */   isMouseDown: () => (/* binding */ isMouseDown),\n/* harmony export */   isMouseOverElement: () => (/* binding */ isMouseOverElement),\n/* harmony export */   isRightMouseDown: () => (/* binding */ isRightMouseDown)\n/* harmony export */ });\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n//import { CANVAS_SCALE } from 'app/constants';\r\n\r\n\r\nlet mousePosition = [-1000, -1000];\r\nlet mouseIsDown = false;\r\nlet rightMouseIsDown = false;\r\nlet middleMouseIsDown = false;\r\nfunction isMouseDown() {\r\n    return mouseIsDown;\r\n}\r\nfunction getMousePosition(container = null, scale = 1) {\r\n    if (container) {\r\n        const containerRect = container.getBoundingClientRect();\r\n        return [\r\n            (mousePosition[0] - containerRect.x) / scale,\r\n            (mousePosition[1] - containerRect.y) / scale,\r\n        ];\r\n    }\r\n    return [mousePosition[0] / scale, mousePosition[1] / scale];\r\n}\r\nfunction onMouseMove(event) {\r\n    mousePosition = [event.pageX, event.pageY];\r\n    // console.log(mousePosition);\r\n}\r\nfunction onMouseDown(event) {\r\n    if (event.which === 1)\r\n        mouseIsDown = true;\r\n    if (event.which === 2)\r\n        middleMouseIsDown = true;\r\n    if (event.which === 3)\r\n        rightMouseIsDown = true;\r\n}\r\nfunction onMouseUp(event) {\r\n    if (event.which === 1)\r\n        mouseIsDown = false;\r\n    if (event.which === 2)\r\n        middleMouseIsDown = false;\r\n    if (event.which === 3)\r\n        rightMouseIsDown = false;\r\n}\r\nfunction bindMouseListeners() {\r\n    document.addEventListener('mousemove', onMouseMove);\r\n    document.addEventListener('mousedown', onMouseDown);\r\n    document.addEventListener('mouseup', onMouseUp);\r\n}\r\n/* This would in theory be used if we ever cleaned up the application\r\nexport function unbindMouseListeners() {\r\n    document.removeEventListener('mousemove', onMouseMove);\r\n    document.removeEventListener('mousedown', onMouseDown);\r\n    document.removeEventListener('mouseup', onMouseUp);\r\n    // Prevent mouse from being \"stuck down\"\r\n    mouseIsDown = false;\r\n}*/\r\nfunction isMouseOverElement(element) {\r\n    const rect = element.getBoundingClientRect();\r\n    return mousePosition[0] >= rect.x && mousePosition[0] <= rect.x + rect.width\r\n        && mousePosition[1] >= rect.y && mousePosition[1] <= rect.y + rect.height;\r\n}\r\nfunction isMiddleMouseDown() {\r\n    return middleMouseIsDown;\r\n}\r\nfunction isRightMouseDown() {\r\n    return rightMouseIsDown;\r\n}\r\nfunction addContextMenuListeners() {\r\n    // Prevent the context menu from displaying when clicking over the canvas unless shift is held.\r\n    app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__.mainCanvas.addEventListener('contextmenu', function (event) {\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.KEY.SHIFT)) {\r\n            return;\r\n        }\r\n        event.preventDefault();\r\n        // const [x, y] = getMousePosition();\r\n        // lastContextClick = getMousePosition(mainCanvas, CANVAS_SCALE);\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/mouse.ts?");

/***/ }),

/***/ "./app/utils/userInput.ts":
/*!********************************!*\
  !*** ./app/utils/userInput.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ANALOG_THRESHOLD: () => (/* binding */ ANALOG_THRESHOLD),\n/* harmony export */   KEY: () => (/* binding */ KEY),\n/* harmony export */   addKeyboardListeners: () => (/* binding */ addKeyboardListeners),\n/* harmony export */   clearKeyboardState: () => (/* binding */ clearKeyboardState),\n/* harmony export */   getMovementDeltas: () => (/* binding */ getMovementDeltas),\n/* harmony export */   getRightAnalogDeltas: () => (/* binding */ getRightAnalogDeltas),\n/* harmony export */   isGameKeyDown: () => (/* binding */ isGameKeyDown),\n/* harmony export */   isKeyboardKeyDown: () => (/* binding */ isKeyboardKeyDown),\n/* harmony export */   updateKeyboardState: () => (/* binding */ updateKeyboardState),\n/* harmony export */   wasGameKeyPressed: () => (/* binding */ wasGameKeyPressed),\n/* harmony export */   wasGameKeyPressedAndReleased: () => (/* binding */ wasGameKeyPressedAndReleased)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* global navigator */\r\n\r\nconst KEY = {\r\n    ESCAPE: 27,\r\n    LEFT: 37,\r\n    RIGHT: 39,\r\n    UP: 38,\r\n    DOWN: 40,\r\n    SPACE: 32,\r\n    SHIFT: 16,\r\n    ENTER: 13,\r\n    BACK_SPACE: 8,\r\n    COMMAND: 91,\r\n    CONTROL: 17,\r\n    LEFT_BRACKET: 219,\r\n    BACK_SLASH: 220,\r\n    RIGHT_BRACKET: 221,\r\n    A: 'A'.charCodeAt(0),\r\n    B: 'B'.charCodeAt(0),\r\n    C: 'C'.charCodeAt(0),\r\n    D: 'D'.charCodeAt(0),\r\n    E: 'E'.charCodeAt(0),\r\n    F: 'F'.charCodeAt(0),\r\n    G: 'G'.charCodeAt(0),\r\n    H: 'H'.charCodeAt(0),\r\n    I: 'I'.charCodeAt(0),\r\n    J: 'J'.charCodeAt(0),\r\n    K: 'K'.charCodeAt(0),\r\n    L: 'L'.charCodeAt(0),\r\n    M: 'M'.charCodeAt(0),\r\n    O: 'O'.charCodeAt(0),\r\n    P: 'P'.charCodeAt(0),\r\n    Q: 'Q'.charCodeAt(0),\r\n    R: 'R'.charCodeAt(0),\r\n    S: 'S'.charCodeAt(0),\r\n    T: 'T'.charCodeAt(0),\r\n    U: 'U'.charCodeAt(0),\r\n    V: 'V'.charCodeAt(0),\r\n    W: 'W'.charCodeAt(0),\r\n    X: 'X'.charCodeAt(0),\r\n    Y: 'Y'.charCodeAt(0),\r\n    Z: 'Z'.charCodeAt(0),\r\n};\r\nconst KEYBOARD_MAPPINGS = {\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MENU]: [KEY.ENTER],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: [KEY.UP, KEY.W],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: [KEY.DOWN, KEY.S],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: [KEY.LEFT, KEY.A],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: [KEY.RIGHT, KEY.D],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE]: [KEY.F],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL]: [KEY.X],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.POTION]: [KEY.SPACE],\r\n};\r\n// Under this threshold, the analog buttons are considered \"released\" for the sake of\r\n// actions that are only taken once per button push (like moving a menu cursor).\r\nconst ANALOG_THRESHOLD = 0.3;\r\n// This mapping assumes a canonical gamepad setup as seen in:\r\n// https://w3c.github.io/gamepad/#remapping\r\n// Which seems to work well with my xbox 360 controller.\r\n// I based this code on examples from:\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API\r\n// Easy to find mappings at: http://html5gamepad.com/\r\nconst GAME_PAD_MAPPINGS = {\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MENU]: 9,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: 12,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: 13,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: 14,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: 15,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE]: [\r\n        0,\r\n        1, // B (right button)\r\n    ],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL]: 3,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.POTION]: 4,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SHOOT]: 5,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SPECIAL_ATTACK]: 6, // L Back Bumper\r\n    // 2, // X (left button)\r\n    // 7, // R Back bumper\r\n    // 8, // BACK\r\n    // 10 ??\r\n    // 11 ??\r\n};\r\nconst LEFT_ANALOG_Y_AXIS = 1;\r\nconst LEFT_ANALOG_X_AXIS = 0;\r\nconst RIGHT_ANALOG_Y_AXIS = 3;\r\nconst RIGHT_ANALOG_X_AXIS = 2;\r\n// These two are currently unused, but would be used for aiming instead of the mouse.\r\n//const RIGHT_ANALOG_Y_AXIS = 3; // eslint-disable-line no-unused-vars\r\n//const RIGHT_ANALOG_X_AXIS = 2; // eslint-disable-line no-unused-vars\r\nconst GAME_PAD_AXIS_MAPPINGS = {\r\n    // Map the negative y axis of the left stick to the up key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: [LEFT_ANALOG_Y_AXIS, -1],\r\n    // Map the positive y axis of the left stick to the down key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: [LEFT_ANALOG_Y_AXIS, 1],\r\n    // Map the negative x axis of the left stick to the up key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: [LEFT_ANALOG_X_AXIS, -1],\r\n    // Map the positive x axis of the left stick to the down key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: [LEFT_ANALOG_X_AXIS, 1],\r\n    // Map the negative y axis of the right stick to the aim up key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_UP]: [RIGHT_ANALOG_Y_AXIS, -1],\r\n    // Map the positive y axis of the right stick to the aim down key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_DOWN]: [RIGHT_ANALOG_Y_AXIS, 1],\r\n    // Map the negative x axis of the right stick to the aim up key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_LEFT]: [RIGHT_ANALOG_X_AXIS, -1],\r\n    // Map the positive x axis of the right stick to the aim down key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_RIGHT]: [RIGHT_ANALOG_X_AXIS, 1],\r\n};\r\n// Apparently, depending on the button type, either button.pressed or button == 1.0 indicates the button is pressed.\r\nfunction buttonIsPressed(button) {\r\n    if (typeof (button) == \"object\")\r\n        return button.pressed;\r\n    return button == 1.0;\r\n}\r\nconst keysDown = [];\r\nlet lastInput;\r\nfunction isKeyboardKeyDown(keyCode) {\r\n    if (keysDown[keyCode]) {\r\n        lastInput = 'keyboard';\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction isGamepadGamekeyPressed(gameKey) {\r\n    // If a mapping exists for the current key code to a gamepad button,\r\n    // check if that gamepad button is pressed.\r\n    const buttonIndexArrayOrNumber = GAME_PAD_MAPPINGS[gameKey], axisIndex = GAME_PAD_AXIS_MAPPINGS[gameKey];\r\n    const buttonIndexArray = Array.isArray(buttonIndexArrayOrNumber) ? buttonIndexArrayOrNumber : [buttonIndexArrayOrNumber];\r\n    for (const buttonIndex of buttonIndexArray) {\r\n        if (typeof (buttonIndex) !== 'undefined' || typeof (axisIndex) !== 'undefined') {\r\n            // There can be multiple game pads connected. For now, let's just check all of them for the button.\r\n            const gamepads = navigator.getGamepads();\r\n            for (const gamepad of gamepads) {\r\n                if (!gamepad)\r\n                    continue;\r\n                let value = 0;\r\n                if (typeof (buttonIndex) !== 'undefined' && buttonIsPressed(gamepad.buttons[buttonIndex])) {\r\n                    value = 1;\r\n                }\r\n                else if (typeof (axisIndex) !== 'undefined' && gamepad.axes[axisIndex[0]] * axisIndex[1] > 0) {\r\n                    value = gamepad.axes[axisIndex[0]] * axisIndex[1];\r\n                }\r\n                if (value) {\r\n                    if (value >= ANALOG_THRESHOLD) {\r\n                        lastInput = 'gamepad';\r\n                    }\r\n                    return value;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\nfunction addKeyboardListeners() {\r\n    window.addEventListener('blur', (event) => {\r\n        for (let i = 0; i < keysDown.length; i++) {\r\n            keysDown[i] = 0;\r\n        }\r\n    });\r\n    document.addEventListener('keyup', function (event) {\r\n        const keyCode = event.which;\r\n        keysDown[keyCode] = 0;\r\n    });\r\n    document.addEventListener('keydown', function (event) {\r\n        if (event.repeat) {\r\n            return;\r\n        }\r\n        // Don't process keys if an input is targeted, otherwise we prevent typing in\r\n        // the input.\r\n        if (event.target.closest('input')\r\n            || event.target.closest('textarea')\r\n            || event.target.closest('select')) {\r\n            return;\r\n        }\r\n        const commandIsDown = (keysDown[KEY.CONTROL] || keysDown[KEY.COMMAND]);\r\n        const keyCode = event.which;\r\n        //console.log(keyCode);\r\n        // Don't override the refresh page command.\r\n        if (keyCode === KEY.R && commandIsDown) {\r\n            return;\r\n        }\r\n        keysDown[keyCode] = 1;\r\n    });\r\n}\r\nfunction updateKeyboardState(state) {\r\n    const previousGameKeysDown = state.keyboard.gameKeysDown;\r\n    // This set is persisted until a new set of keys is pressed.\r\n    let mostRecentKeysPressed = state.keyboard.mostRecentKeysPressed;\r\n    const gameKeyValues = [];\r\n    const gameKeysDown = new Set();\r\n    const gameKeysPressed = new Set();\r\n    const gameKeysReleased = new Set();\r\n    /*for (const gameKey of GAME_PAD_AXIS_MAPPINGS) {\r\n\r\n    }*/\r\n    for (let gameKey of Object.values(app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY)) {\r\n        gameKeyValues[gameKey] = 0;\r\n        for (const keyboardCode of (KEYBOARD_MAPPINGS[gameKey] || [])) {\r\n            gameKeyValues[gameKey] = isKeyboardKeyDown(keyboardCode);\r\n            if (gameKeyValues[gameKey]) {\r\n                break;\r\n            }\r\n        }\r\n        if (!gameKeyValues[gameKey]) {\r\n            gameKeyValues[gameKey] = isGamepadGamekeyPressed(gameKey);\r\n        }\r\n        if (gameKeyValues[gameKey] >= ANALOG_THRESHOLD) {\r\n            gameKeysDown.add(gameKey);\r\n        }\r\n    }\r\n    for (const oldKeyDown of [...previousGameKeysDown]) {\r\n        if (!gameKeysDown.has(oldKeyDown)) {\r\n            gameKeysReleased.add(oldKeyDown);\r\n        }\r\n    }\r\n    for (const newKeyDown of [...gameKeysDown]) {\r\n        if (!previousGameKeysDown.has(newKeyDown)) {\r\n            gameKeysPressed.add(newKeyDown);\r\n        }\r\n    }\r\n    if (gameKeysPressed.size > 0) {\r\n        mostRecentKeysPressed = gameKeysPressed;\r\n    }\r\n    state.keyboard = { gameKeyValues, gameKeysDown, gameKeysPressed, gameKeysReleased, mostRecentKeysPressed };\r\n    if (lastInput === 'gamepad') {\r\n        state.isUsingKeyboard = false;\r\n        state.isUsingXbox = true;\r\n    }\r\n    else if (lastInput === 'keyboard') {\r\n        state.isUsingKeyboard = true;\r\n        state.isUsingXbox = false;\r\n    }\r\n}\r\nfunction clearKeyboardState(state) {\r\n    const gameKeyValues = [];\r\n    for (let gameKey of Object.values(app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY)) {\r\n        gameKeyValues[gameKey] = 0;\r\n    }\r\n    state.keyboard = {\r\n        gameKeyValues,\r\n        gameKeysDown: new Set(),\r\n        gameKeysPressed: new Set(),\r\n        gameKeysReleased: new Set(),\r\n        mostRecentKeysPressed: new Set(),\r\n    };\r\n}\r\nfunction wasGameKeyPressed(state, keyCode) {\r\n    return state.keyboard.gameKeysPressed.has(keyCode);\r\n}\r\n// Only returns true if a key was pressed and released without any other keys having been pressed in between.\r\n// Specifically this is used to determined whether to switch clones, which should only happen if the user presses\r\n// the clone tool button without pressing any other buttons before releasing it. Note that it is okay if they\r\n// continue holding buttons that were already down when pressing the clone button.\r\nfunction wasGameKeyPressedAndReleased(state, keyCode) {\r\n    return state.keyboard.mostRecentKeysPressed.has(keyCode) && state.keyboard.gameKeysReleased.has(keyCode);\r\n}\r\nfunction isGameKeyDown(state, keyCode) {\r\n    return state.keyboard.gameKeysDown.has(keyCode);\r\n}\r\nfunction getMovementDeltas(state) {\r\n    const { gameKeyValues } = state.keyboard;\r\n    let dy = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP];\r\n    if (Math.abs(dy) < ANALOG_THRESHOLD)\r\n        dy = 0;\r\n    let dx = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT];\r\n    if (Math.abs(dx) < ANALOG_THRESHOLD)\r\n        dx = 0;\r\n    if (isNaN(dx) || isNaN(dy)) {\r\n        debugger;\r\n    }\r\n    return [dx, dy];\r\n}\r\nfunction getRightAnalogDeltas(state) {\r\n    const { gameKeyValues } = state.keyboard;\r\n    let dy = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_DOWN] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_UP];\r\n    let dx = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_RIGHT] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_LEFT];\r\n    if (Math.abs(dx) < ANALOG_THRESHOLD && Math.abs(dy) < ANALOG_THRESHOLD) {\r\n        return [0, 0];\r\n    }\r\n    if (isNaN(dx) || isNaN(dy)) {\r\n        debugger;\r\n    }\r\n    return [dx, dy];\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/userInput.ts?");

/***/ }),

/***/ "./app/weapons.ts":
/*!************************!*\
  !*** ./app/weapons.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allWeapons: () => (/* binding */ allWeapons),\n/* harmony export */   bows: () => (/* binding */ bows),\n/* harmony export */   daggers: () => (/* binding */ daggers),\n/* harmony export */   katanas: () => (/* binding */ katanas),\n/* harmony export */   morningStars: () => (/* binding */ morningStars),\n/* harmony export */   staffs: () => (/* binding */ staffs),\n/* harmony export */   swords: () => (/* binding */ swords),\n/* harmony export */   updateSimpleBullet: () => (/* binding */ updateSimpleBullet),\n/* harmony export */   weaponTypeLabels: () => (/* binding */ weaponTypeLabels),\n/* harmony export */   weaponTypes: () => (/* binding */ weaponTypes),\n/* harmony export */   weaponsByType: () => (/* binding */ weaponsByType)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n\r\n\r\nfunction updateSimpleBullet(state, bullet) {\r\n    bullet.baseX += bullet.vx / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n    bullet.baseY += bullet.vy / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n    if (bullet.frequency && bullet.amplitude) {\r\n        const theta = Math.atan2(bullet.vy, bullet.vx) + Math.PI / 2;\r\n        const amplitude = bullet.amplitude * Math.sin(bullet.frequency * 2 * Math.PI * bullet.time / 1000);\r\n        bullet.x = bullet.baseX + amplitude * Math.cos(theta);\r\n        bullet.y = bullet.baseY + amplitude * Math.sin(theta);\r\n    }\r\n    else {\r\n        bullet.x = bullet.baseX;\r\n        bullet.y = bullet.baseY;\r\n    }\r\n}\r\nfunction getArmorShred(state, chargeLevel) {\r\n    return state.hero.armorShredEffect * (0.01 + 0.02 * chargeLevel);\r\n}\r\nfunction getChargeDamage(state, chargeLevel) {\r\n    if (chargeLevel <= 1) {\r\n        return 1;\r\n    }\r\n    return chargeLevel + state.hero.chargeDamage;\r\n}\r\nfunction basicBullet(state, source, weapon) {\r\n    const critDamage = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_1__.rollForCritDamage)(state);\r\n    return {\r\n        time: 0,\r\n        baseX: source.x,\r\n        baseY: source.y,\r\n        x: source.x,\r\n        y: source.y,\r\n        radius: weapon.radius * source.attackChargeLevel,\r\n        vx: weapon.speed * Math.cos(source.theta),\r\n        vy: weapon.speed * Math.sin(source.theta),\r\n        damage: Math.ceil(weapon.damage * getChargeDamage(state, source.attackChargeLevel) * source.damage * critDamage),\r\n        chargeGain: 0.1,\r\n        isCrit: critDamage > 1,\r\n        isEnemyPiercing: (source.attackChargeLevel >= 2),\r\n        source,\r\n        expirationTime: state.fieldTime + weapon.duration,\r\n        update: updateSimpleBullet,\r\n        hitTargets: new Set(),\r\n        armorShred: getArmorShred(state, source.attackChargeLevel),\r\n    };\r\n}\r\n/*\r\nExample damage spread for weapon tiers:\r\n0: 20\r\n1: 35\r\n2: 60\r\n3: 100\r\n4: 150\r\n5: 230\r\n6: 350\r\n7: 500\r\n8: 700\r\n9: 950\r\n10: 1250\r\n11: 1550\r\n12: 1850\r\n13: 2000\r\n*/\r\nconst bowShots = [\r\n    {\r\n        generateBullet(state, source, weapon) {\r\n            const speed = weapon.speed * (0.6 + 0.4 * source.attackChargeLevel);\r\n            const critDamage = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_1__.rollForCritDamage)(state, 0.1 * source.attackChargeLevel);\r\n            return {\r\n                ...basicBullet(state, source, weapon),\r\n                radius: weapon.radius + (source.attackChargeLevel - 1),\r\n                vx: speed * Math.cos(source.theta),\r\n                vy: speed * Math.sin(source.theta),\r\n                damage: Math.ceil(weapon.damage * getChargeDamage(state, source.attackChargeLevel) * source.damage * critDamage),\r\n                // Bow gains charge very fast relative to its rate of fire.\r\n                chargeGain: 0.5,\r\n                isCrit: critDamage > 1,\r\n                isEnemyPiercing: true,\r\n            };\r\n        },\r\n    }\r\n];\r\nfunction createBow(level, name) {\r\n    const attacksPerSecond = app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND * 0.8;\r\n    return {\r\n        type: 'weapon',\r\n        weaponType: 'bow',\r\n        level: Math.floor(level),\r\n        name,\r\n        shots: bowShots,\r\n        attacksPerSecond,\r\n        critChance: 0.2,\r\n        critDamage: 0.5,\r\n        damage: Math.ceil(0.6 * level * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_WEAPON_DPS_PER_LEVEL / attacksPerSecond),\r\n        chargeLevel: 3,\r\n        speed: 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_SPEED,\r\n        radius: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_RADIUS,\r\n        duration: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_DURATION,\r\n        enchantmentSlots: [],\r\n    };\r\n}\r\nconst bows = [\r\n    createBow(1, 'Primitive Bow'),\r\n    createBow(3, 'Short Bow'),\r\n    createBow(5, 'Recurve Bow'),\r\n    createBow(8, 'Long Bow'),\r\n    createBow(11, 'Crossbow'),\r\n    createBow(15, 'Composite Bow'),\r\n    createBow(21, 'Repeating Crossbow'),\r\n    createBow(32, 'Recurve Crossbow'),\r\n    createBow(44, 'Arbalest'),\r\n    createBow(57, 'Compound Bow'),\r\n    createBow(71, 'Compound Crossbow'),\r\n    createBow(86, 'Adamantine Crossbow'),\r\n    createBow(95, 'Dragonbone Greabow'),\r\n];\r\nconst swordShots = [\r\n    {\r\n        generateBullet(state, source, weapon) {\r\n            return {\r\n                ...basicBullet(state, source, weapon),\r\n            };\r\n        },\r\n    }\r\n];\r\nfunction createSword(level, name) {\r\n    return {\r\n        type: 'weapon',\r\n        weaponType: 'sword',\r\n        level,\r\n        name,\r\n        shots: swordShots,\r\n        attacksPerSecond: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND,\r\n        critChance: 0.05,\r\n        critDamage: 0.5,\r\n        damage: Math.ceil(level * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_WEAPON_DPS_PER_LEVEL / app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND),\r\n        chargeLevel: 2,\r\n        speed: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_SPEED,\r\n        radius: Math.ceil(1.2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_RADIUS),\r\n        duration: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_DURATION,\r\n        enchantmentSlots: [],\r\n    };\r\n}\r\nconst swords = [\r\n    createSword(1, 'Gladius'),\r\n    createSword(2, 'Short Sword'),\r\n    createSword(5, 'Falchion'),\r\n    createSword(8, 'Scimitar'),\r\n    createSword(12, 'Wakizashi'),\r\n    createSword(17, 'Longsword'),\r\n    createSword(27, 'Estoic'),\r\n    createSword(38, 'Broadsword'),\r\n    createSword(50, 'Bastardsword'),\r\n    createSword(63, 'Meteoric Saber'),\r\n    createSword(77, 'Runed Saber'),\r\n    createSword(92, 'Etched Dragon Horn'),\r\n    createSword(95, 'Precursor Blade'),\r\n];\r\nfunction generateDaggerShot(timingOffset, thetaOffset) {\r\n    return {\r\n        timingOffset,\r\n        generateBullet(state, source, weapon) {\r\n            const critDamage = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_1__.rollForCritDamage)(state);\r\n            return {\r\n                ...basicBullet(state, source, weapon),\r\n                vx: weapon.speed * Math.cos(source.theta + thetaOffset / source.attackChargeLevel / source.attackChargeLevel),\r\n                vy: weapon.speed * Math.sin(source.theta + thetaOffset / source.attackChargeLevel / source.attackChargeLevel),\r\n                damage: Math.ceil(weapon.damage * getChargeDamage(state, source.attackChargeLevel) * source.damage * critDamage),\r\n                // Dagger gains charge 40% faster than average if every bullet hits.\r\n                chargeGain: 0.02,\r\n                isCrit: critDamage > 1,\r\n                radius: weapon.radius + (source.attackChargeLevel - 1),\r\n            };\r\n        },\r\n    };\r\n}\r\nconst daggerShots = [\r\n    generateDaggerShot(0 / 7, 0),\r\n    generateDaggerShot(1 / 7, Math.PI / 18),\r\n    generateDaggerShot(2 / 7, -Math.PI / 18),\r\n    generateDaggerShot(3 / 7, 2 * Math.PI / 18),\r\n    generateDaggerShot(4 / 7, -2 * Math.PI / 18),\r\n    generateDaggerShot(5 / 7, 3 * Math.PI / 18),\r\n    generateDaggerShot(6 / 7, -3 * Math.PI / 18),\r\n];\r\nfunction createDagger(level, name) {\r\n    return {\r\n        type: 'weapon',\r\n        weaponType: 'dagger',\r\n        level: Math.floor(level),\r\n        name,\r\n        shots: daggerShots,\r\n        attacksPerSecond: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND,\r\n        critChance: 0.05,\r\n        critDamage: 0.5,\r\n        damage: Math.ceil(0.3 * level * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_WEAPON_DPS_PER_LEVEL / app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND),\r\n        chargeLevel: 2,\r\n        speed: Math.ceil(app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_SPEED * 0.7),\r\n        radius: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_RADIUS,\r\n        duration: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_DURATION,\r\n        enchantmentSlots: [],\r\n    };\r\n}\r\nconst daggers = [\r\n    createDagger(1.5, 'Pugio'),\r\n    createDagger(3, 'Hewing Knife'),\r\n    createDagger(6, 'Cross-hilt Dagger'),\r\n    createDagger(11, 'Tanto'),\r\n    createDagger(17, 'Stiletto'),\r\n    createDagger(23, 'Steel Dirk'),\r\n    createDagger(34, 'Stainless Dirk'),\r\n    createDagger(46, 'Serrated Dirk'),\r\n    createDagger(59, 'Masterful Dirk'),\r\n    createDagger(73, 'Meteoric Dirk'),\r\n    createDagger(88, 'Runed Dirk'),\r\n    createDagger(95, 'Etched Dragon Fang'),\r\n];\r\nfunction generateKatanaShot(timingOffset, offset) {\r\n    return {\r\n        timingOffset,\r\n        generateBullet(state, source, weapon) {\r\n            const speed = weapon.speed * (0.8 + 0.2 * source.attackChargeLevel);\r\n            const critDamage = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_1__.rollForCritDamage)(state);\r\n            const x = source.x + offset * Math.cos(source.theta + Math.PI / 2);\r\n            const y = source.y + offset * Math.sin(source.theta + Math.PI / 2);\r\n            return {\r\n                ...basicBullet(state, source, weapon),\r\n                baseX: x,\r\n                baseY: y,\r\n                x,\r\n                y,\r\n                vx: speed * Math.cos(source.theta),\r\n                vy: speed * Math.sin(source.theta),\r\n                damage: Math.ceil(weapon.damage * getChargeDamage(state, source.attackChargeLevel) * source.damage * critDamage),\r\n                // Katana can gain charge almost 2x faster when piercing several enemies.\r\n                chargeGain: 0.05,\r\n                isCrit: critDamage > 1,\r\n                isEnemyPiercing: true,\r\n                radius: weapon.radius + (source.attackChargeLevel - 1),\r\n            };\r\n        },\r\n    };\r\n}\r\nconst katanaShots = [\r\n    generateKatanaShot(0 / 2, 10),\r\n    generateKatanaShot(1 / 2, -10),\r\n];\r\nfunction createKatana(level, name) {\r\n    return {\r\n        type: 'weapon',\r\n        weaponType: 'katana',\r\n        level: Math.floor(level),\r\n        name,\r\n        shots: katanaShots,\r\n        attacksPerSecond: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND,\r\n        critChance: 0.05,\r\n        critDamage: 1,\r\n        damage: Math.ceil(0.5 * level * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_WEAPON_DPS_PER_LEVEL / app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND),\r\n        chargeLevel: 2,\r\n        speed: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_SPEED * 0.8,\r\n        radius: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_RADIUS,\r\n        duration: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_DURATION,\r\n        enchantmentSlots: [],\r\n    };\r\n}\r\nconst katanas = [\r\n    createKatana(1.5, 'Kitetsu I'),\r\n    createKatana(4, 'Yubashiri'),\r\n    createKatana(7, 'Kitetsu II'),\r\n    createKatana(11, 'Shusui'),\r\n    createKatana(16, 'Ichimonji'),\r\n    createKatana(22, 'Soto Muso'),\r\n    createKatana(30, 'Sukesan'),\r\n    createKatana(40, 'Shigure'),\r\n    createKatana(51, 'Kitetsu III'),\r\n    createKatana(64, 'Ame no Habakiri'),\r\n    createKatana(76, 'Wado Ichimonji'),\r\n    createKatana(90, 'Enma'),\r\n    createKatana(95, 'Masamune'),\r\n];\r\nconst morningStars = [];\r\nconst staffs = [];\r\nconst weaponTypes = [\r\n    'bow',\r\n    'dagger',\r\n    'katana',\r\n    'sword',\r\n];\r\nconst weaponTypeLabels = {\r\n    bow: 'Bow',\r\n    dagger: 'Dagger',\r\n    katana: 'Katana',\r\n    morningStar: 'Morning Star',\r\n    staff: 'Staff',\r\n    sword: 'Sword',\r\n};\r\nconst weaponsByType = {\r\n    bow: bows,\r\n    dagger: daggers,\r\n    katana: katanas,\r\n    sword: swords,\r\n    morningStar: morningStars,\r\n    staff: staffs,\r\n};\r\nconst allWeapons = Object.values(weaponsByType);\r\n// TODO: Add morning star, shot spins around the source and loops at the attack speed interval, pierces enemies\r\n//       2 Charge levels increases radius by 16px each\r\n// TODO: Add staff, single piercing shot that gets bigger but weaker with distance 120% damage at close range, down to 20% at max range\r\n//       Add rendering function to bullets so we can make the staff shot fade as it gets weaker.\r\n\n\n//# sourceURL=webpack://alttp/./app/weapons.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app/client.ts");
/******/ 	
/******/ })()
;
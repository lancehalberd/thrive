/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./app/armor.ts":
/*!**********************!*\
  !*** ./app/armor.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allArmors: () => (/* binding */ allArmors),\n/* harmony export */   armorTypeLabels: () => (/* binding */ armorTypeLabels),\n/* harmony export */   armorTypes: () => (/* binding */ armorTypes),\n/* harmony export */   armorsByType: () => (/* binding */ armorsByType),\n/* harmony export */   heavyArmors: () => (/* binding */ heavyArmors),\n/* harmony export */   lightArmors: () => (/* binding */ lightArmors),\n/* harmony export */   mediumArmors: () => (/* binding */ mediumArmors)\n/* harmony export */ });\nfunction createLightArmor(level, name) {\r\n    return {\r\n        type: 'armor',\r\n        armorType: 'lightArmor',\r\n        level: Math.floor(level),\r\n        name,\r\n        life: level * 10,\r\n        armor: level,\r\n        speedFactor: 1.1,\r\n        enchantmentSlots: [],\r\n        bonusEnchantmentSlots: [],\r\n    };\r\n}\r\nconst lightArmors = [\r\n    createLightArmor(1, 'Wool Shirt'),\r\n    createLightArmor(2, 'Hemp Frock'),\r\n    createLightArmor(7, 'Linen Frock'),\r\n    createLightArmor(11, 'Cotton Frock'),\r\n    createLightArmor(17, 'Fur Coat'),\r\n    createLightArmor(24, 'Cashmere Robe'),\r\n    createLightArmor(32, 'Silk Robe'),\r\n    createLightArmor(41, 'Angora Robe'),\r\n    createLightArmor(51, 'Velvet Robe'),\r\n    createLightArmor(62, 'Embroidered Robe'),\r\n    createLightArmor(74, 'Sorcerous Vestment'),\r\n    createLightArmor(87, 'Blessed Vestment'),\r\n    createLightArmor(95, 'Divine Vestment'),\r\n];\r\nfunction createMediumArmor(level, name) {\r\n    return {\r\n        type: 'armor',\r\n        armorType: 'mediumArmor',\r\n        level: Math.floor(level),\r\n        name,\r\n        life: level * 15,\r\n        armor: Math.ceil(level * 1.5),\r\n        speedFactor: 1,\r\n        enchantmentSlots: [],\r\n        bonusEnchantmentSlots: [],\r\n    };\r\n}\r\nconst mediumArmors = [\r\n    createMediumArmor(1, 'Cloth Tunic'),\r\n    createMediumArmor(3, 'Leather Tunic'),\r\n    createMediumArmor(8, 'Hide Tunic'),\r\n    createMediumArmor(13, 'Leather Armor'),\r\n    createMediumArmor(19, 'Studded Armor'),\r\n    createMediumArmor(26, 'Hide Armor'),\r\n    createMediumArmor(34, 'Carapace Armor'),\r\n    createMediumArmor(43, 'Treated Armor'),\r\n    createMediumArmor(53, 'Splint Armor'),\r\n    createMediumArmor(64, 'Scale Armor'),\r\n    createMediumArmor(76, 'Composite Armor'),\r\n    createMediumArmor(89, 'Runed Armor'),\r\n    createMediumArmor(95, 'Dragon Armor'),\r\n];\r\nfunction createHeavyArmor(level, name) {\r\n    return {\r\n        type: 'armor',\r\n        armorType: 'heavyArmor',\r\n        level: Math.floor(level),\r\n        name,\r\n        life: level * 20,\r\n        armor: Math.ceil(level * 2),\r\n        speedFactor: 0.9,\r\n        enchantmentSlots: [],\r\n        bonusEnchantmentSlots: [],\r\n    };\r\n}\r\nconst heavyArmors = [\r\n    createHeavyArmor(1, 'Lamellar'),\r\n    createHeavyArmor(5, 'Bamboo Armor'),\r\n    createHeavyArmor(10, 'Panoply'),\r\n    createHeavyArmor(15, 'Plated Coat'),\r\n    createHeavyArmor(21, 'Brigandine'),\r\n    createHeavyArmor(28, 'Cuirass'),\r\n    createHeavyArmor(36, 'Chainmail'),\r\n    createHeavyArmor(45, 'Scalemail'),\r\n    createHeavyArmor(55, 'Platemail'),\r\n    createHeavyArmor(66, 'Half Plate'),\r\n    createHeavyArmor(78, 'Full Plate'),\r\n    createHeavyArmor(91, 'Adamantium Plate'),\r\n    createHeavyArmor(95, 'Orichalcum Plate'),\r\n];\r\nconst armorTypes = ['lightArmor', 'mediumArmor', 'heavyArmor'];\r\nconst armorsByType = {\r\n    lightArmor: lightArmors,\r\n    mediumArmor: mediumArmors,\r\n    heavyArmor: heavyArmors,\r\n};\r\nconst allArmors = Object.values(armorsByType);\r\nconst armorTypeLabels = {\r\n    lightArmor: 'Light Armor',\r\n    mediumArmor: 'Medium Armor',\r\n    heavyArmor: 'Heavy Armor',\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/armor.ts?");

/***/ }),

/***/ "./app/bosses/guardian.ts":
/*!********************************!*\
  !*** ./app/bosses/guardian.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   guardian: () => (/* binding */ guardian)\n/* harmony export */ });\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n\r\n\r\n\r\n\r\n\r\nconst guardian = {\r\n    name: 'Guardian',\r\n    statFactors: {\r\n        maxLife: window.BOSS_MAX_LIFE_FACTOR,\r\n        damage: 1,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 1,\r\n    uniqueMultiplier: 20,\r\n    experienceFactor: 20,\r\n    radius: 40,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        if (!enemy.minions.length && enemy.life <= enemy.maxLife / 2) {\r\n            for (let i = 0; i < 3; i++) {\r\n                const theta = i * 2 * Math.PI / 3;\r\n                const minion = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.createEnemy)(state, enemy.disc.x + (enemy.disc.radius - 30) * Math.cos(theta), enemy.disc.y + (enemy.disc.radius - 30) * Math.sin(theta), guardianTurret, enemy.level, enemy.disc);\r\n                minion.theta = theta;\r\n                enemy.minions.push(minion);\r\n                minion.master = enemy;\r\n            }\r\n        }\r\n        if (enemy.mode === 'choose') {\r\n            enemy.speed = window.BASE_ENEMY_SPEED;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.chaseTarget)(state, enemy, state.hero);\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_4__[\"default\"].element(['moveToEdge', 'moveToEdge', 'moveToCenter', 'chase']));\r\n                //enemy.setMode(Random.element(['moveToCenter']));\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveToEdge') {\r\n            enemy.speed = 1.2 * window.BASE_ENEMY_SPEED;\r\n            let { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy.disc, enemy);\r\n            if (distance2 >= (enemy.disc.radius * 0.8) ** 2) {\r\n                enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_4__[\"default\"].element(['shoot', 'shoot', 'circle']));\r\n            }\r\n            else {\r\n                enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy);\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveToCenter') {\r\n            enemy.speed = 1.2 * window.BASE_ENEMY_SPEED;\r\n            if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyToTarget)(state, enemy, enemy.disc)) {\r\n                enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_4__[\"default\"].element(['chasingSpirals', 'crossingSpirals']));\r\n                //enemy.setMode(Random.element(['chasingSpirals']));\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'chasingSpirals') {\r\n            enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, -Math.PI / 2);\r\n            if (enemy.modeTime < 400) {\r\n                return;\r\n            }\r\n            if (enemy.modeTime % 200 === 0) {\r\n                const duration = 2000;\r\n                for (let i = 0; i < 2; i++) {\r\n                    const thetaIndex = (enemy.modeTime - 400) / 200 + i;\r\n                    const theta = -Math.PI / 2 + (i + 1) * thetaIndex * Math.PI / 12;\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, window.BASE_ENEMY_BULLET_SPEED * Math.cos(theta), window.BASE_ENEMY_BULLET_SPEED * Math.sin(theta), { duration });\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, window.BASE_ENEMY_BULLET_SPEED * Math.cos(theta + Math.PI), window.BASE_ENEMY_BULLET_SPEED * Math.sin(theta + Math.PI), { duration });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= 4000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'crossingSpirals') {\r\n            enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.PI / 2);\r\n            if (enemy.modeTime < 400) {\r\n                return;\r\n            }\r\n            if (enemy.modeTime % 200 === 0) {\r\n                const duration = 2000;\r\n                for (let i = 0; i < 2; i++) {\r\n                    const thetaIndex = (enemy.modeTime - 400) / 200;\r\n                    const theta = Math.PI / 2 + thetaIndex * Math.PI / 6 * (i ? -1 : 1);\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, window.BASE_ENEMY_BULLET_SPEED * Math.cos(theta), window.BASE_ENEMY_BULLET_SPEED * Math.sin(theta), { duration });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= 4000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'shoot') {\r\n            if (enemy.modeTime < 600) {\r\n                const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n                enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n            }\r\n            if (enemy.modeTime === 1000) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 2 * window.BASE_ENEMY_BULLET_SPEED * Math.cos(enemy.theta), 2 * window.BASE_ENEMY_BULLET_SPEED * Math.sin(enemy.theta), {\r\n                    duration: 2000,\r\n                    damage: enemy.damage * 5,\r\n                    radius: 3 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                });\r\n            }\r\n            if (enemy.modeTime >= 1500) {\r\n                enemy.setMode('charge');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'charge') {\r\n            enemy.speed = 1.5 * window.BASE_ENEMY_SPEED;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy);\r\n            if (enemy.modeTime % 200 === 0) {\r\n                const vx = 1.2 * window.BASE_ENEMY_BULLET_SPEED * Math.cos(enemy.theta + Math.PI / 2);\r\n                const vy = 1.2 * window.BASE_ENEMY_BULLET_SPEED * Math.sin(enemy.theta + Math.PI / 2);\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, vx, vy, { duration: 3000 });\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, -vx, -vy, { duration: 3000 });\r\n            }\r\n            if (enemy.modeTime >= 3000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            // Stop earlier if it hits the outside of the ring.\r\n            if (enemy.modeTime >= 1000) {\r\n                let { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy.disc, enemy);\r\n                if (distance2 >= (enemy.disc.radius * 0.9) ** 2) {\r\n                    enemy.setMode('choose');\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'chase') {\r\n            enemy.speed = window.BASE_ENEMY_SPEED;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.chaseTarget)(state, enemy, state.hero);\r\n            if (enemy.modeTime % 800 === 0) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, enemy.theta, Math.PI / 6, 3, 2 * window.BASE_ENEMY_BULLET_SPEED);\r\n            }\r\n            if (enemy.modeTime >= 4000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'circle') {\r\n            enemy.speed = 2 * window.BASE_ENEMY_SPEED;\r\n            let { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n            enemy.theta = Math.atan2(y, x);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, enemy.theta + Math.PI / 2);\r\n            if (enemy.modeTime % 600 === 0) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, enemy.theta, Math.PI / 6, 3, 2 * window.BASE_ENEMY_BULLET_SPEED);\r\n            }\r\n            if (enemy.modeTime >= 6000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 30 * Math.cos(enemy.theta + Math.PI / 6),\r\n            y: enemy.y + 30 * Math.sin(enemy.theta + Math.PI / 6),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 30 * Math.cos(enemy.theta),\r\n            y: enemy.y + 30 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 30 * Math.cos(enemy.theta - Math.PI / 6),\r\n            y: enemy.y + 30 * Math.sin(enemy.theta - Math.PI / 6),\r\n            radius: 5,\r\n        }, 'black');\r\n    },\r\n    getEnchantment(state, enemy) {\r\n        return (0,app_enchantments__WEBPACK_IMPORTED_MODULE_0__.getVigorEnchantment)(state, enemy.level);\r\n    },\r\n};\r\nconst guardianTurret = {\r\n    name: 'Turret',\r\n    statFactors: {\r\n        maxLife: 2,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n        armor: 2,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 0,\r\n    experienceFactor: 2,\r\n    radius: 20,\r\n    isInvulnerable: true,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.1, Math.atan2(y, x));\r\n        if (enemy.modeTime > 1000 && enemy.modeTime % 400 === 0) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, enemy.theta, 2 * Math.PI / 3, 2, window.BASE_ENEMY_BULLET_SPEED * 1.5);\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'yellow');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 20 * Math.cos(enemy.theta + Math.PI / 3),\r\n            y: enemy.y + 20 * Math.sin(enemy.theta + Math.PI / 3),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 20 * Math.cos(enemy.theta - Math.PI / 3),\r\n            y: enemy.y + 20 * Math.sin(enemy.theta - Math.PI / 3),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/bosses/guardian.ts?");

/***/ }),

/***/ "./app/bosses/skissue.ts":
/*!*******************************!*\
  !*** ./app/bosses/skissue.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   skissue: () => (/* binding */ skissue)\n/* harmony export */ });\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst skissue = {\r\n    name: 'Skissue',\r\n    statFactors: {\r\n        maxLife: window.BOSS_MAX_LIFE_FACTOR,\r\n        damage: 1,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 1,\r\n    experienceFactor: 20,\r\n    radius: 48,\r\n    update(state, enemy) {\r\n        if (enemy.life >= enemy.maxLife * 3 / 4) {\r\n            if (enemy.mode !== 'sakura') {\r\n                enemy.setMode('sakura');\r\n            }\r\n        }\r\n        else if (enemy.life >= enemy.maxLife / 2) {\r\n            if (enemy.mode !== 'hanabi') {\r\n                enemy.setMode('hanabi');\r\n            }\r\n        }\r\n        else if (enemy.life >= enemy.maxLife / 4) {\r\n            if (enemy.mode !== 'sakura') {\r\n                enemy.setMode('sakura');\r\n            }\r\n            if (enemy.modeTime % 4000 === 0) {\r\n                const minion = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.createEnemy)(state, enemy.x, enemy.y, blob, enemy.level, enemy.disc);\r\n                enemy.minions.push(minion);\r\n                minion.master = enemy;\r\n            }\r\n        }\r\n        else {\r\n            if (enemy.mode !== 'hanabi') {\r\n                enemy.setMode('hanabi');\r\n            }\r\n            if (enemy.modeTime % 4000 === 0) {\r\n                const minion = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.createEnemy)(state, enemy.x, enemy.y, blob, enemy.level, enemy.disc);\r\n                enemy.minions.push(minion);\r\n                minion.master = enemy;\r\n            }\r\n        }\r\n        if (enemy.mode === 'sakura') {\r\n            if (enemy.minions.filter(e => e.definition === skillPortal).length === 0) {\r\n                //spawn minions\r\n                for (let i = 0; i < 4; i++) {\r\n                    const theta = i * 2 * Math.PI / 4;\r\n                    const minion = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.createEnemy)(state, enemy.disc.x + (enemy.disc.radius - 30) * Math.cos(theta), enemy.disc.y + (enemy.disc.radius - 30) * Math.sin(theta), skillPortal, enemy.level, enemy.disc);\r\n                    minion.theta = theta;\r\n                    enemy.minions.push(minion);\r\n                    minion.master = enemy;\r\n                }\r\n            }\r\n            if (enemy.modeTime % 100 === 0) {\r\n                const theta1 = Math.PI * 2 / 40000 * enemy.modeTime;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletCircle)(state, enemy, theta1, 5, window.BASE_ENEMY_BULLET_SPEED, { duration: 2000 });\r\n            }\r\n        }\r\n        if (enemy.mode === 'hanabi') {\r\n            //delete portals\r\n            for (const minion of enemy.minions) {\r\n                if (minion.definition === skillPortal) {\r\n                    minion.life = 0;\r\n                }\r\n            }\r\n            enemy.minions = enemy.minions.filter(e => e.life > 0);\r\n            if (enemy.modeTime % 3600 === 0) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, window.BASE_ENEMY_BULLET_SPEED / 2, {\r\n                    damage: 5 * enemy.damage,\r\n                    radius: window.BASE_ENEMY_BULLET_RADIUS * 2,\r\n                    duration: 2000,\r\n                    onDeath(state, bullet) {\r\n                        for (let i = 0; i < 5; i++) {\r\n                            const bulletTheta = 2 * Math.PI * i / 5;\r\n                            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, window.BASE_ENEMY_BULLET_SPEED * 1.5 * Math.cos(bulletTheta), window.BASE_ENEMY_BULLET_SPEED * 1.5 * Math.sin(bulletTheta), {\r\n                                x: bullet.x,\r\n                                y: bullet.y,\r\n                                baseX: bullet.x,\r\n                                baseY: bullet.y,\r\n                                duration: 250,\r\n                                onDeath(state, bullet) {\r\n                                    for (let i = 0; i < 5; i++) {\r\n                                        const bulletTheta = 2 * Math.PI * i / 5;\r\n                                        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, window.BASE_ENEMY_BULLET_SPEED * 2 * Math.cos(bulletTheta), window.BASE_ENEMY_BULLET_SPEED * 2 * Math.sin(bulletTheta), {\r\n                                            x: bullet.x,\r\n                                            y: bullet.y,\r\n                                            baseX: bullet.x,\r\n                                            baseY: bullet.y,\r\n                                            duration: 500,\r\n                                            onDeath(state, bullet) {\r\n                                                for (let i = 0; i < 5; i++) {\r\n                                                    const bulletTheta = 2 * Math.PI * i / 5;\r\n                                                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, window.BASE_ENEMY_BULLET_SPEED * Math.cos(bulletTheta), window.BASE_ENEMY_BULLET_SPEED * Math.sin(bulletTheta), {\r\n                                                        x: bullet.x,\r\n                                                        y: bullet.y,\r\n                                                        baseX: bullet.x,\r\n                                                        baseY: bullet.y,\r\n                                                        duration: 2000,\r\n                                                    });\r\n                                                }\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            /*if (enemy.modeTime >= 10000) {\r\n                enemy.setMode('choose');\r\n            }*/\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        context.save();\r\n        context.translate(enemy.x, enemy.y);\r\n        context.rotate(enemy.theta);\r\n        context.scale(enemy.radius, enemy.radius);\r\n        // Black circle\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x: 0, y: 0, radius: 1 }, 'black');\r\n        // Colored \"split mask halves\"\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.arc(0, 0, 0.8, Math.PI / 12, 11 * Math.PI / 12);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.arc(0, 0, 0.8, 13 * Math.PI / 12, 23 * Math.PI / 12);\r\n        context.fill();\r\n        // 4 eyes on each mask half\r\n        for (let i = 0; i < 4; i++) {\r\n            const thetaSpace = 5 * Math.PI / 6 / 5;\r\n            const theta = Math.PI / 12 + (1 + i) * thetaSpace;\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x: 0.6 * Math.cos(theta), y: 0.6 * Math.sin(theta), radius: 0.1 }, 'black');\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x: 0.6 * Math.cos(-theta), y: 0.6 * Math.sin(-theta), radius: 0.1 }, 'black');\r\n        }\r\n        context.restore();\r\n    },\r\n    getEnchantment(state, enemy) {\r\n        return (0,app_enchantments__WEBPACK_IMPORTED_MODULE_0__.getVigorEnchantment)(state, enemy.level);\r\n    },\r\n};\r\nconst skillPortal = {\r\n    name: 'portal',\r\n    statFactors: {\r\n        maxLife: 2,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n        armor: 2,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 0,\r\n    experienceFactor: 2,\r\n    radius: 20,\r\n    isInvulnerable: true,\r\n    update(state, enemy) {\r\n        if (enemy.life >= enemy.maxLife / 2) {\r\n            const theta = enemy.theta + Math.PI + Math.PI / 250;\r\n            enemy.x = enemy.disc.x + enemy.disc.radius * Math.cos(theta);\r\n            enemy.y = enemy.disc.y + enemy.disc.radius * Math.sin(theta);\r\n            enemy.theta = theta - Math.PI;\r\n            if (enemy.modeTime % 100 === 0 && enemy.modeTime % 2000 < 1500) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, window.BASE_ENEMY_BULLET_SPEED / 2 * Math.cos(enemy.theta), window.BASE_ENEMY_BULLET_SPEED / 2 * Math.sin(enemy.theta), { duration: 3000 });\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        context.save();\r\n        context.translate(enemy.x, enemy.y);\r\n        context.rotate(enemy.theta);\r\n        context.scale(enemy.radius, enemy.radius);\r\n        // Black circle\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x: 0, y: 0, radius: 1 }, 'black');\r\n        // Colored \"split mask halves\"\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.arc(0, 0, 0.8, Math.PI / 12, 11 * Math.PI / 12);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.arc(0, 0, 0.8, 13 * Math.PI / 12, 23 * Math.PI / 12);\r\n        context.fill();\r\n        // 4 eyes on each mask half\r\n        for (let i = 0; i < 4; i++) {\r\n            const thetaSpace = 5 * Math.PI / 6 / 5;\r\n            const theta = Math.PI / 12 + (1 + i) * thetaSpace;\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x: 0.6 * Math.cos(theta), y: 0.6 * Math.sin(theta), radius: 0.1 }, 'black');\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x: 0.6 * Math.cos(-theta), y: 0.6 * Math.sin(-theta), radius: 0.1 }, 'black');\r\n        }\r\n        context.restore();\r\n    },\r\n};\r\nconst blob = {\r\n    name: 'Blob',\r\n    statFactors: {\r\n        maxLife: 1,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n        armor: 2,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 0,\r\n    experienceFactor: 0,\r\n    radius: 30,\r\n    update(state, enemy) {\r\n        var _a, _b;\r\n        if (enemy.mode === 'choose') {\r\n            const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n            enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n            enemy.x += enemy.speed * Math.cos(enemy.theta) * window.FRAME_LENGTH / 1800;\r\n            enemy.y += enemy.speed * Math.sin(enemy.theta) * window.FRAME_LENGTH / 1800;\r\n            const radius = 30;\r\n            if (distance2 <= radius * radius) {\r\n                enemy.setMode('exploding');\r\n            }\r\n        }\r\n        if (enemy.mode === 'exploding') {\r\n            if (enemy.modeTime >= 1000) {\r\n                enemy.life = 0;\r\n                (_b = (_a = enemy.definition).onDeath) === null || _b === void 0 ? void 0 : _b.call(_a, state, enemy);\r\n            }\r\n        }\r\n    },\r\n    onDeath(state, enemy) {\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletCircle)(state, enemy, 0, 30, window.BASE_ENEMY_BULLET_SPEED * 3, { duration: +200 });\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'black');\r\n        const count = Math.max(3, Math.ceil((enemy.radius - 8) / 8));\r\n        for (let i = 0; i < count; i++) {\r\n            const theta = state.fieldTime / 4000 + i * 2 * Math.PI / count;\r\n            const p = (1 + Math.sin(state.fieldTime / 500 + i * 2 * Math.PI / 3)) / 2;\r\n            const maxDistance = enemy.radius / 4;\r\n            const minDistance = enemy.radius / 10;\r\n            const distance = minDistance + p * (maxDistance - minDistance);\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n                x: enemy.x + distance * Math.cos(theta),\r\n                y: enemy.y + distance * Math.sin(theta),\r\n                radius: 3 * enemy.radius / 4\r\n            }, enemy.baseColor);\r\n        }\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/bosses/skissue.ts?");

/***/ }),

/***/ "./app/bosses/spider.ts":
/*!******************************!*\
  !*** ./app/bosses/spider.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   babySpiderBomber: () => (/* binding */ babySpiderBomber),\n/* harmony export */   babySpiderNova: () => (/* binding */ babySpiderNova),\n/* harmony export */   overworldSpiderNova: () => (/* binding */ overworldSpiderNova),\n/* harmony export */   spider: () => (/* binding */ spider),\n/* harmony export */   spiderFlower: () => (/* binding */ spiderFlower),\n/* harmony export */   spiderPinwheel: () => (/* binding */ spiderPinwheel)\n/* harmony export */ });\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst attackModes = ['novas', 'pinwheels', 'petals'];\r\nconst spider = {\r\n    name: 'Spider',\r\n    statFactors: {\r\n        maxLife: window.BOSS_MAX_LIFE_FACTOR,\r\n        damage: 1,\r\n    },\r\n    initialParams: {\r\n        attackTime: 0,\r\n        attackMode: 'choose',\r\n        attackSchedule: [],\r\n        attackIntensity: 0,\r\n        bombIntensity: 0,\r\n    },\r\n    dropChance: 1,\r\n    uniqueMultiplier: 40,\r\n    experienceFactor: 20,\r\n    radius: 48,\r\n    update(state, enemy) {\r\n        const nextAttack = () => {\r\n            if (!enemy.params.attackSchedule.length) {\r\n                enemy.params.attackSchedule = app_utils_Random__WEBPACK_IMPORTED_MODULE_5__[\"default\"].shuffle([...attackModes]);\r\n            }\r\n            enemy.params.attackMode = enemy.params.attackSchedule.pop();\r\n            enemy.params.attackTime = 0;\r\n            enemy.params.attackIntensity = (enemy.life <= enemy.maxLife / 2) ? 1 : 0;\r\n        };\r\n        enemy.params.attackTime += window.FRAME_LENGTH;\r\n        if (enemy.params.attackMode === 'novas') {\r\n            const spacing = 800 - enemy.params.attackIntensity * 400;\r\n            if (enemy.params.attackTime % spacing === 0 && enemy.params.attackTime <= 3000) {\r\n                const count = 10;\r\n                const parity = [0, 2, 1, 3][(enemy.params.attackTime / spacing) % 4];\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, parity * 2 * Math.PI / count / 4, count, 0.6 * window.BASE_ENEMY_BULLET_SPEED, { duration: 3000 });\r\n            }\r\n            if (enemy.params.attackTime >= 3500) {\r\n                nextAttack();\r\n            }\r\n        }\r\n        else if (enemy.params.attackMode === 'petals') {\r\n            const spacing = 200;\r\n            if (enemy.params.attackTime > spacing * 5 && enemy.params.attackTime % spacing === 0 && enemy.params.attackTime <= spacing * 35) {\r\n                const count = 3 + enemy.params.attackIntensity * 2;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, enemy.params.attackTime / spacing * 2 * Math.PI / 40, count, 1.1 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                    duration: 3000,\r\n                    update: app_utils_bullet__WEBPACK_IMPORTED_MODULE_2__.updateReturnBullet,\r\n                });\r\n            }\r\n            if (enemy.params.attackTime >= spacing * 45) {\r\n                nextAttack();\r\n            }\r\n        }\r\n        else if (enemy.params.attackMode === 'pinwheels') {\r\n            const spacing = 2000;\r\n            if (enemy.params.attackTime % spacing === window.FRAME_LENGTH && enemy.params.attackTime < spacing * 4) {\r\n                const count = 3 + enemy.params.attackIntensity;\r\n                for (let r = 20; r < enemy.radius + 450; r += 40) {\r\n                    for (let i = 0; i < count; i++) {\r\n                        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootCirclingBullet)(state, enemy, 2 * Math.PI * i / count + r * Math.PI / 40 / 20, r, {\r\n                            vTheta: -Math.PI / count,\r\n                            warningTime: 1000,\r\n                            duration: 3000,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            if (enemy.params.attackTime >= spacing * 6) {\r\n                nextAttack();\r\n            }\r\n        }\r\n        else {\r\n            nextAttack();\r\n        }\r\n        // Face away from the disc.\r\n        const vtheta = Math.PI / 200 * (1.5 - 0.5 * enemy.life / enemy.maxLife);\r\n        enemy.theta += vtheta;\r\n        const targetRadius = Math.round(enemy.params.attackMode === 'petals' ? 0 : 150 * (1 - enemy.life / enemy.maxLife));\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, enemy.disc);\r\n        let radius = Math.sqrt(distance2);\r\n        if (radius < targetRadius)\r\n            radius++;\r\n        else if (radius > targetRadius)\r\n            radius--;\r\n        enemy.x = enemy.disc.x + radius * Math.cos(enemy.theta);\r\n        enemy.y = enemy.disc.y + radius * Math.sin(enemy.theta);\r\n        if (enemy.mode === 'choose') {\r\n            const p = enemy.life / enemy.maxLife;\r\n            if (enemy.modeTime >= 1000 && p <= 0.9) {\r\n                const modes = ['random'];\r\n                if (p <= 0.33) {\r\n                    enemy.params.bombIntensity = 2;\r\n                    modes.push('spiral');\r\n                }\r\n                else if (p <= 0.66) {\r\n                    enemy.params.bombIntensity = 1;\r\n                    modes.push('rings');\r\n                }\r\n                enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_5__[\"default\"].element(modes));\r\n            }\r\n        }\r\n        if (enemy.mode === 'spiral') {\r\n            const time = enemy.modeTime;\r\n            const totalTime = 5000;\r\n            const spacing = 60;\r\n            if (enemy.modeTime % spacing === 0) {\r\n                const count = totalTime / spacing;\r\n                const t = time / spacing;\r\n                const r = 50 + 350 * t / count;\r\n                const arms = 2 + enemy.params.bombIntensity;\r\n                for (let i = 0; i < arms; i++) {\r\n                    const theta = 8 * Math.PI * t / count - r / Math.PI / 3 + 2 * Math.PI * i / arms;\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createBombBullet)(state, enemy, enemy.disc.x + r * Math.cos(theta), enemy.disc.y + r * Math.sin(theta), {\r\n                        warningTime: 1000,\r\n                        duration: 1200,\r\n                    });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= totalTime) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n        if (enemy.mode === 'rings') {\r\n            const totalTime = 5000;\r\n            const time = enemy.modeTime;\r\n            const bombSpacing = 800 - 100 * enemy.params.bombIntensity;\r\n            if (enemy.modeTime % bombSpacing === 0) {\r\n                const t = time / bombSpacing;\r\n                const r = 50 + t * 350 / (totalTime / bombSpacing);\r\n                const count = Math.floor(2 * Math.PI * r / (2 * 3 * window.BASE_ENEMY_BULLET_RADIUS));\r\n                for (let i = 0; i < count; i++) {\r\n                    const theta = 2 * Math.PI * (i + (t % 2) * 0.5) / count;\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createBombBullet)(state, enemy, enemy.disc.x + r * Math.cos(theta), enemy.disc.y + r * Math.sin(theta), {\r\n                        warningTime: 1000,\r\n                        duration: 1200,\r\n                    });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= totalTime) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n        if (enemy.mode === 'random') {\r\n            const totalTime = 5000;\r\n            const bombSpacing = 1200 - 300 * enemy.params.bombIntensity;\r\n            if (enemy.modeTime % bombSpacing === 0) {\r\n                const dr = 100 - 70 * (1 - enemy.life / enemy.maxLife);\r\n                for (let r = 50; r < 400; r += dr) {\r\n                    const theta = Math.random() * 2 * Math.PI;\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createBombBullet)(state, enemy, enemy.disc.x + r * Math.cos(theta), enemy.disc.y + r * Math.sin(theta));\r\n                }\r\n            }\r\n            if (enemy.modeTime >= totalTime) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.renderNormalizedEnemy)((context, state, enemy) => renderNormalizedSpider(context, enemy, 4)),\r\n    getEnchantment(state, enemy) {\r\n        return (0,app_enchantments__WEBPACK_IMPORTED_MODULE_0__.getThiefEnchantment)(state, enemy.level);\r\n    },\r\n};\r\nfunction renderNormalizedSpider(context, enemy, eyeCount) {\r\n    // Black circle\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n    // Colored \"split mask halves\"\r\n    context.fillStyle = enemy.baseColor;\r\n    context.beginPath();\r\n    context.arc(0, 0, 80, Math.PI / 24, 23 * Math.PI / 24);\r\n    context.fill();\r\n    context.beginPath();\r\n    context.arc(0, 0, 80, 25 * Math.PI / 24, 47 * Math.PI / 24);\r\n    context.fill();\r\n    // 4 eyes on each mask half\r\n    context.fillStyle = 'black';\r\n    for (let i = 0; i < eyeCount; i++) {\r\n        const thetaSpace = 5 * Math.PI / 6 / (eyeCount + 1);\r\n        const theta = Math.PI / 12 + (1 + i) * thetaSpace;\r\n        context.beginPath();\r\n        const eyeAngle = Math.PI / 2 + (2 * Math.PI / 3 - Math.PI / 2) * i / eyeCount;\r\n        const eyeRadius = 55;\r\n        context.arc(eyeRadius * Math.cos(theta), eyeRadius * Math.sin(theta), 20, eyeAngle, eyeAngle - Math.PI, true);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.arc(eyeRadius * Math.cos(-theta), eyeRadius * Math.sin(-theta), 20, -eyeAngle, -(eyeAngle - Math.PI), false);\r\n        context.fill();\r\n        //fillCircle(context, {x: 0.6 * Math.cos(-theta), y: 0.6 * Math.sin(-theta), radius: 0.1}, 'black');\r\n    }\r\n}\r\nconst babySpiderBomber = {\r\n    name: 'BabySpiderBomber',\r\n    statFactors: {},\r\n    initialParams: {},\r\n    radius: 24,\r\n    onDeath(state, enemy) {\r\n        for (let r = 50; r < 200; r += 40) {\r\n            const theta = Math.random() * 2 * Math.PI;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createBombBullet)(state, enemy, enemy.x + r * Math.cos(theta), enemy.y + r * Math.sin(theta));\r\n        }\r\n    },\r\n    update(state, enemy) {\r\n        const aggroRadius = 500;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.chaseHeroHeading)(state, enemy);\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, window.BASE_ENEMY_BULLET_SPEED, {\r\n                duration: 2000,\r\n            });\r\n        }\r\n        const bombSpacing = 500;\r\n        if (enemy.modeTime % bombSpacing === 0) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createBombBullet)(state, enemy, enemy.x, enemy.y);\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.renderNormalizedEnemy)((context, state, enemy) => renderNormalizedSpider(context, enemy, 2)),\r\n};\r\nconst babySpiderNova = {\r\n    name: 'BabySpiderNova',\r\n    statFactors: {\r\n        speed: 2,\r\n    },\r\n    initialParams: { targetX: 0, targetY: 0 },\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        if (enemy.mode === 'choose' && enemy.modeTime >= 500) {\r\n            const aggroRadius = 500;\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, state.hero);\r\n            if (distance2 > aggroRadius * aggroRadius) {\r\n                return;\r\n            }\r\n            enemy.params.targetX = state.hero.x + state.hero.vx * 500 / 1000 + 24 * (0.5 - Math.random());\r\n            enemy.params.targetY = state.hero.y + state.hero.vy * 500 / 1000 + 24 * (0.5 - Math.random());\r\n            enemy.setMode('dash');\r\n        }\r\n        if (enemy.mode === 'dash') {\r\n            if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyToTarget)(state, enemy, { x: enemy.params.targetX, y: enemy.params.targetY })) {\r\n                enemy.setMode('attack');\r\n            }\r\n            if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.isEnemyOffDisc)(state, enemy) && enemy.modeTime >= 1000) {\r\n                enemy.setMode('attack');\r\n            }\r\n        }\r\n        if (enemy.mode === 'attack') {\r\n            const spacing = 20 * Math.ceil(1000 / enemy.attacksPerSecond / 20);\r\n            if (enemy.modeTime % spacing === 0) {\r\n                const count = 7;\r\n                const parity = [0, 2, 1, 3][(enemy.modeTime / spacing) % 4];\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, parity * 2 * Math.PI / count / 4, count, window.BASE_ENEMY_BULLET_SPEED, { duration: 1000 });\r\n            }\r\n            if (enemy.modeTime >= 3000) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.renderNormalizedEnemy)((context, state, enemy) => renderNormalizedSpider(context, enemy, 2)),\r\n};\r\nconst overworldSpiderNova = {\r\n    name: 'OverworldSpiderNova',\r\n    statFactors: {\r\n        speed: 1.5,\r\n    },\r\n    initialParams: { targetX: 0, targetY: 0 },\r\n    radius: 24,\r\n    portalChance: 0.1,\r\n    portalDungeonType: 'spiderDen',\r\n    update(state, enemy) {\r\n        if (enemy.mode === 'choose' && enemy.modeTime >= 400) {\r\n            const aggroRadius = 400;\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, state.hero);\r\n            if (distance2 > aggroRadius * aggroRadius) {\r\n                return;\r\n            }\r\n            enemy.params.targetX = state.hero.x + state.hero.vx * 500 / 1000 + 24 * (0.5 - Math.random());\r\n            enemy.params.targetY = state.hero.y + state.hero.vy * 500 / 1000 + 24 * (0.5 - Math.random());\r\n            enemy.setMode('dash');\r\n            return;\r\n        }\r\n        if (enemy.mode === 'dash') {\r\n            if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyToTarget)(state, enemy, { x: enemy.params.targetX, y: enemy.params.targetY })) {\r\n                enemy.setMode('attack');\r\n            }\r\n            if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.isEnemyOffDisc)(state, enemy) && enemy.modeTime >= 1000) {\r\n                enemy.setMode('attack');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'attack') {\r\n            // Normal directed shots at the player\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, window.BASE_ENEMY_BULLET_SPEED);\r\n            }\r\n            // Periodic novas.\r\n            const spacing = 20 * Math.ceil(1000 / enemy.attacksPerSecond / 20);\r\n            if (enemy.modeTime % spacing === 0) {\r\n                const count = 7;\r\n                const parity = [0, 2, 1, 3][(enemy.modeTime / spacing) % 4];\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, parity * 2 * Math.PI / count / 4, count, window.BASE_ENEMY_BULLET_SPEED, { duration: 1000 });\r\n            }\r\n            if (enemy.modeTime >= 2000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.renderNormalizedEnemy)((context, state, enemy) => renderNormalizedSpider(context, enemy, 2)),\r\n};\r\nfunction upgradeBoss(state, enemy) {\r\n    var _a, _b;\r\n    const boss = (_b = (_a = state.dungeon) === null || _a === void 0 ? void 0 : _a.discs.find(d => d.boss)) === null || _b === void 0 ? void 0 : _b.boss;\r\n    if (!boss) {\r\n        return;\r\n    }\r\n    // Every other large spider defeated upgrades the boss level by 1.\r\n    if (boss.level === (boss.level | 0)) {\r\n        boss.level += 0.5;\r\n    }\r\n    else {\r\n        // Replace the boss with a higher leve version.\r\n        boss.disc.enemies = [];\r\n        boss.disc.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, boss.x, boss.y, boss.definition, (boss.level | 0) + 1, boss.disc);\r\n        boss.disc.boss.isBoss = true;\r\n    }\r\n}\r\nconst spiderFlower = {\r\n    name: 'SpiderFlower',\r\n    statFactors: { maxLife: 2 },\r\n    dropChance: 2 * window.BASE_DROP_CHANCE,\r\n    uniqueMultiplier: 10,\r\n    experienceFactor: 5,\r\n    initialParams: {},\r\n    radius: 36,\r\n    onDeath: upgradeBoss,\r\n    update(state, enemy) {\r\n        const aggroRadius = 600;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        const spacing = 200;\r\n        if (enemy.modeTime % spacing === 0) {\r\n            const count = 3;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, enemy.modeTime / spacing * 2 * Math.PI / 40, count, 1.1 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                duration: 3000,\r\n                update: app_utils_bullet__WEBPACK_IMPORTED_MODULE_2__.updateReturnBullet,\r\n            });\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, window.BASE_ENEMY_BULLET_SPEED, { radius: 1.5 * window.BASE_ENEMY_BULLET_RADIUS, damage: 2 * enemy.damage });\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.renderNormalizedEnemy)((context, state, enemy) => renderNormalizedSpider(context, enemy, 3)),\r\n};\r\nconst spiderPinwheel = {\r\n    name: 'SpiderPinwheel',\r\n    statFactors: { maxLife: 2 },\r\n    dropChance: 2 * window.BASE_DROP_CHANCE,\r\n    uniqueMultiplier: 10,\r\n    experienceFactor: 5,\r\n    initialParams: {},\r\n    radius: 36,\r\n    onDeath: upgradeBoss,\r\n    update(state, enemy) {\r\n        const aggroRadius = 600;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        const spacing = 3000;\r\n        if (enemy.modeTime % spacing === 0) {\r\n            const offset = (enemy.modeTime % (2 * spacing)) / spacing;\r\n            const count = 3;\r\n            for (let r = enemy.radius + 5; r < enemy.radius + 440; r += 40) {\r\n                for (let i = 0; i < count; i++) {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootCirclingBullet)(state, enemy, 2 * Math.PI * i / count + 2 * Math.PI * offset / count / 2 + r * Math.PI / 40 / 40, r, {\r\n                        vTheta: -Math.PI / 6,\r\n                        warningTime: 1000,\r\n                        duration: 4000,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, window.BASE_ENEMY_BULLET_SPEED, { radius: 1.5 * window.BASE_ENEMY_BULLET_RADIUS, damage: 2 * enemy.damage });\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.renderNormalizedEnemy)((context, state, enemy) => renderNormalizedSpider(context, enemy, 3)),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/bosses/spider.ts?");

/***/ }),

/***/ "./app/client.ts":
/*!***********************!*\
  !*** ./app/client.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_contextMenu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/contextMenu */ \"./app/contextMenu.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_inventory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/inventory */ \"./app/inventory.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/uniqueEnchantmentHash */ \"./app/uniqueEnchantmentHash.ts\");\n/* harmony import */ var app_utils_audio__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/audio */ \"./app/utils/audio.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_combat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/combat */ \"./app/utils/combat.ts\");\n/* harmony import */ var app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/coreCalculations */ \"./app/utils/coreCalculations.ts\");\n/* harmony import */ var app_utils_disc__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/disc */ \"./app/utils/disc.ts\");\n/* harmony import */ var app_utils_dungeon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/utils/dungeon */ \"./app/utils/dungeon.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_guardSkill__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/utils/guardSkill */ \"./app/utils/guardSkill.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n/* harmony import */ var app_utils_overworld__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! app/utils/overworld */ \"./app/utils/overworld.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n/* harmony import */ var app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! app/utils/rollWithMissBonus */ \"./app/utils/rollWithMissBonus.ts\");\n/* harmony import */ var app_armor__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! app/armor */ \"./app/armor.ts\");\n/* harmony import */ var app_initialize__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! app/initialize */ \"./app/initialize.ts\");\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n// This file sets a bunch of values on `window` and must be the first thing imported.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst state = getInitialState();\r\n// @ts-ignore\r\nwindow['state'] = state;\r\nfunction getState() {\r\n    return state;\r\n}\r\nfunction getInitialState() {\r\n    return {\r\n        worldSeed: Math.random(),\r\n        fieldTime: 0,\r\n        hero: {\r\n            // placeholder disc\r\n            disc: { level: 1, x: 0, y: 0, radius: 100, name: '', links: [], enemies: [], portals: [], loot: [], holes: [] },\r\n            level: 1,\r\n            experience: 0,\r\n            speed: 100,\r\n            x: window.CELL_SIZE / 2,\r\n            y: -window.CELL_SIZE / 2,\r\n            overworldX: window.CELL_SIZE / 2,\r\n            overworldY: -window.CELL_SIZE / 2,\r\n            radius: 20,\r\n            theta: 0,\r\n            damageHistory: [],\r\n            recentDamageTaken: 0,\r\n            lastTimeDamaged: 0,\r\n            equipment: {\r\n                weapon: app_utils_Random__WEBPACK_IMPORTED_MODULE_18__[\"default\"].element(app_weapons__WEBPACK_IMPORTED_MODULE_23__.allWeapons.filter(arr => arr.length))[0],\r\n                armor: app_armor__WEBPACK_IMPORTED_MODULE_20__.mediumArmors[0],\r\n            },\r\n            weapons: [],\r\n            proficiency: {},\r\n            mastery: {},\r\n            bossRecords: {},\r\n            armors: [],\r\n            enchantments: [],\r\n            // Derived stats will get set later.\r\n            life: 10,\r\n            maxLife: 10,\r\n            baseArmor: 0,\r\n            armor: 0,\r\n            damage: 0,\r\n            attacksPerSecond: 0,\r\n            attackCooldown: 0,\r\n            chargingLevel: 1,\r\n            attackChargeLevel: 1,\r\n            attackChargeDuration: 0,\r\n            totalChargeDuration: 2000,\r\n            potions: window.BASE_MAX_POTIONS,\r\n            isShooting: false,\r\n            // Base crit damage/chance is on weapons, this just stores\r\n            // bonuses from enchantments+weapon proficiencies.\r\n            critChance: 0,\r\n            critDamage: 0,\r\n            chargeDamage: 0,\r\n            dropChance: 0,\r\n            dropLevel: 0,\r\n            armorShredEffect: 0,\r\n            potionEffect: 1,\r\n            vx: 0,\r\n            vy: 0,\r\n            uniqueEnchantments: [],\r\n            flags: {},\r\n            guardSkill: {\r\n                cooldownTime: 0,\r\n                charges: 0,\r\n                time: 0,\r\n            },\r\n            frameDamageOverTime: 0,\r\n            slowEffects: [],\r\n        },\r\n        heroBullets: [],\r\n        enemies: [],\r\n        loot: [],\r\n        portals: [],\r\n        holes: [],\r\n        enemyBullets: [],\r\n        fieldText: [],\r\n        activeCells: [],\r\n        recentCells: [],\r\n        cellMap: new Map(),\r\n        activeDiscs: [],\r\n        visibleDiscs: [],\r\n        gameHasBeenInitialized: false,\r\n        paused: false,\r\n        mouse: {\r\n            x: window.CANVAS_WIDTH / 2,\r\n            y: window.CANVAS_HEIGHT / 2,\r\n            isDown: false,\r\n            wasPressed: false,\r\n            isRightDown: false,\r\n            wasRightPressed: false,\r\n        },\r\n        isUsingKeyboard: true,\r\n        keyboard: {\r\n            gameKeyValues: [],\r\n            gameKeysDown: new Set(),\r\n            gameKeysPressed: new Set(),\r\n            mostRecentKeysPressed: new Set(),\r\n            gameKeysReleased: new Set(),\r\n        },\r\n        menuRow: 0,\r\n        menuColumn: 0,\r\n        menuEquipmentSelected: false,\r\n        audio: {\r\n            playingTracks: [],\r\n        },\r\n        missedRolls: {},\r\n        sightRadius: window.SIGHT_RADIUS,\r\n    };\r\n}\r\nfunction restartGame(state) {\r\n    //Object.assign(state,  getInitialState());\r\n    //state.gameHasBeenInitialized = true;\r\n    (0,app_saveGame__WEBPACK_IMPORTED_MODULE_22__.loadGame)(state);\r\n    delete state.dungeon;\r\n    // Delete the current boss, otherwise the current disc\r\n    // will stay active if it has a boss.\r\n    delete state.hero.disc.boss;\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.setDerivedHeroStats)(state);\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.refillAllPotions)(state);\r\n    (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_16__.clearNearbyEnemies)(state);\r\n    state.sightRadius = window.SIGHT_RADIUS;\r\n    //saveGame(state);\r\n}\r\nfunction update() {\r\n    const state = getState();\r\n    if (!state.gameHasBeenInitialized) {\r\n        (0,app_initialize__WEBPACK_IMPORTED_MODULE_21__.initializeGame)(state);\r\n        (0,app_saveGame__WEBPACK_IMPORTED_MODULE_22__.loadGame)(state);\r\n        (0,app_contextMenu__WEBPACK_IMPORTED_MODULE_1__.addContextMenuListeners)(state);\r\n        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.setDerivedHeroStats)(state);\r\n        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.refillAllPotions)(state);\r\n        (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_16__.clearNearbyEnemies)(state);\r\n        // Set testDungeon/testBoss here to load the game in a dungeon and boss room.\r\n        const testDungeon = '';\r\n        if (testDungeon) {\r\n            const dungeon = (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_11__.createDungeon)(state, testDungeon, state.hero.level);\r\n            (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_11__.startDungeon)(state, dungeon);\r\n            (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_16__.updateActiveCells)(state);\r\n            const testBoss = '';\r\n            if (testBoss) {\r\n                const bossDisc = state.activeDiscs.find(d => { var _a; return ((_a = d.boss) === null || _a === void 0 ? void 0 : _a.definition.name) === testBoss; });\r\n                if (bossDisc) {\r\n                    state.hero.x = bossDisc.x;\r\n                    state.hero.y = bossDisc.y + 200;\r\n                    state.hero.disc = bossDisc;\r\n                }\r\n            }\r\n        }\r\n        assignToDisc(state.hero, state.activeDiscs);\r\n        state.hero.x = state.hero.disc.x;\r\n        state.hero.y = state.hero.disc.y;\r\n        state.paused = true;\r\n    }\r\n    if (!state.audio.playingTracks.length) {\r\n        app_utils_audio__WEBPACK_IMPORTED_MODULE_6__.playTrack; //(state, 'beach');\r\n    }\r\n    // This shouldn't drop below 50% otherwise vision won't change even when you can be 1 shot.\r\n    const healthThreshold = Math.max(0.5, 1 - 0.2 * state.hero.potionEffect);\r\n    // Ranges from 0.5 - 1 as health ranges from 0 to maxLife - 1 potion.\r\n    const sightPercentage = 0.5 + 0.5 * Math.min(1, state.hero.life / state.hero.maxLife / healthThreshold);\r\n    const targetSightRadius = sightPercentage * window.SIGHT_RADIUS;\r\n    if (state.sightRadius < targetSightRadius) {\r\n        state.sightRadius = Math.min(state.sightRadius + 4, targetSightRadius);\r\n    }\r\n    else if (state.sightRadius > targetSightRadius) {\r\n        state.sightRadius = Math.max(state.sightRadius - 2, targetSightRadius);\r\n    }\r\n    for (const track of state.audio.playingTracks) {\r\n        track.update(state);\r\n    }\r\n    (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.updateKeyboardState)(state);\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MUTE)) {\r\n        state.areSoundEffectsMuted = !state.areSoundEffectsMuted;\r\n        (0,app_utils_audio__WEBPACK_IMPORTED_MODULE_6__.setVolume)(state.areSoundEffectsMuted ? 0 : 1);\r\n    }\r\n    if (state.isUsingXbox) {\r\n        const [dx, dy] = (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.getRightAnalogDeltas)(state);\r\n        state.hero.theta = Math.atan2(dy, dx);\r\n        state.hero.isShooting = (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SHOOT);\r\n    }\r\n    else {\r\n        const [x, y] = (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_15__.getMousePosition)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_7__.mainCanvas, window.CANVAS_SCALE);\r\n        let aimDx = x - window.FIELD_CENTER.x, aimDy = y - window.FIELD_CENTER.y;\r\n        state.hero.theta = Math.atan2(aimDy, aimDx);\r\n        state.mouse.x = x;\r\n        state.mouse.y = y;\r\n        // Track main(left) mouse button state\r\n        if ((0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_15__.isMouseDown)()) {\r\n            state.mouse.wasPressed = !state.mouse.isDown;\r\n            state.mouse.isDown = true;\r\n        }\r\n        else {\r\n            state.mouse.wasPressed = false;\r\n            state.mouse.isDown = false;\r\n            state.hero.isShooting = false;\r\n        }\r\n        if (state.mouse.wasPressed) {\r\n            state.hero.isShooting = true;\r\n        }\r\n        // Track right mouse button state.\r\n        if ((0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_15__.isRightMouseDown)()) {\r\n            state.mouse.wasRightPressed = !state.mouse.isRightDown;\r\n            state.mouse.isRightDown = true;\r\n        }\r\n        else {\r\n            state.mouse.wasRightPressed = false;\r\n            state.mouse.isRightDown = false;\r\n        }\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MENU)) {\r\n        state.paused = !state.paused;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.KEY.SHIFT) && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.KEY.B)) {\r\n        const bossDisc = state.activeDiscs.find(d => d.boss);\r\n        if (bossDisc) {\r\n            state.hero.x = bossDisc.x;\r\n            state.hero.y = bossDisc.y;\r\n        }\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.KEY.SHIFT) && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.KEY.K)) {\r\n        for (const enemy of state.enemies) {\r\n            if (enemy.disc === state.hero.disc) {\r\n                defeatEnemy(state, enemy);\r\n            }\r\n        }\r\n        state.enemies = state.enemies.filter(e => e.life > 0);\r\n    }\r\n    (0,app_inventory__WEBPACK_IMPORTED_MODULE_3__.updateInventory)(state);\r\n    if (state.paused) {\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.KEY.SHIFT)) {\r\n            let [dx, dy] = (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.getMovementDeltas)(state);\r\n            const m = Math.sqrt(dx * dx + dy * dy);\r\n            if (m > 1) {\r\n                dx /= m;\r\n                dy /= m;\r\n            }\r\n            const speed = 5000;\r\n            state.hero.x += dx * speed * window.FRAME_LENGTH / 1000;\r\n            state.hero.y += dy * speed * window.FRAME_LENGTH / 1000;\r\n            (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_16__.updateActiveCells)(state);\r\n        }\r\n        return;\r\n    }\r\n    state.fieldTime += window.FRAME_LENGTH;\r\n    if (state.hero.life <= 0) {\r\n        restartGame(state);\r\n        return;\r\n    }\r\n    (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_16__.updateActiveCells)(state);\r\n    updateHero(state);\r\n    updateEnemies(state);\r\n    updateHeroBullets(state);\r\n    updateEnemyBullets(state);\r\n    state.fieldText = state.fieldText.filter(t => t.expirationTime > state.fieldTime);\r\n    for (const fieldText of state.fieldText) {\r\n        fieldText.x += fieldText.vx;\r\n        fieldText.y += fieldText.vy;\r\n        fieldText.time += window.FRAME_LENGTH;\r\n    }\r\n    const hoverSlot = (0,app_inventory__WEBPACK_IMPORTED_MODULE_3__.getHoverInventorySlot)(state);\r\n    if (!hoverSlot) {\r\n        state.activeLoot = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_12__.getClosestElement)(state.hero, state.loot);\r\n    }\r\n    else {\r\n        delete state.activeLoot;\r\n    }\r\n    if (state.activeLoot && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_12__.getTargetVector)(state.hero, state.activeLoot).distance2 >= (state.activeLoot.radius + state.hero.radius + 10) ** 2) {\r\n        delete state.activeLoot;\r\n    }\r\n    if (state.activeLoot && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE)) {\r\n        state.activeLoot.activate(state);\r\n        state.activeLoot.disc.loot.splice(state.activeLoot.disc.loot.indexOf(state.activeLoot), 1);\r\n        delete state.activeLoot;\r\n    }\r\n    else if (state.activeLoot && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL)) {\r\n        state.activeLoot.sell();\r\n        state.activeLoot.disc.loot.splice(state.activeLoot.disc.loot.indexOf(state.activeLoot), 1);\r\n        delete state.activeLoot;\r\n    }\r\n}\r\nfunction updateHero(state) {\r\n    var _a, _b, _c, _d;\r\n    const hero = state.hero;\r\n    // Hero damage frames\r\n    hero.damageHistory.unshift(0);\r\n    if (hero.damageHistory.length > window.HERO_DAMAGE_FRAME_COUNT) {\r\n        const oldDamage = hero.damageHistory.pop();\r\n        hero.recentDamageTaken -= oldDamage;\r\n    }\r\n    // Hero movement\r\n    let [dx, dy] = (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.getMovementDeltas)(state);\r\n    const m = Math.sqrt(dx * dx + dy * dy);\r\n    if (m > 1) {\r\n        dx /= m;\r\n        dy /= m;\r\n    }\r\n    const slowEffect = (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_8__.updateSlowEffects)(state, state.hero);\r\n    const speed = hero.speed * (1 - slowEffect);\r\n    hero.x += dx * speed * window.FRAME_LENGTH / 1000;\r\n    hero.y += dy * speed * window.FRAME_LENGTH / 1000;\r\n    hero.vx = dx * speed;\r\n    hero.vy = dy * speed;\r\n    // Hero attack\r\n    const weapon = hero.equipment.weapon;\r\n    const attacksPerSecond = weapon.getAttacksPerSecond(state, weapon) * hero.attacksPerSecond * (1 - slowEffect);\r\n    // chargingLevel increases as long as the hero\r\n    // Default charge speed is 1 charge per 20 seconds.\r\n    gainAttackCharge(state, window.FRAME_LENGTH / 20000);\r\n    (0,app_utils_guardSkill__WEBPACK_IMPORTED_MODULE_13__.updateGuardSkill)(state);\r\n    if (hero.lastTimeDamaged <= (state.fieldTime - 1000) && hero.armor < hero.baseArmor) {\r\n        hero.armor = Math.min(hero.baseArmor, hero.armor * 1.005);\r\n    }\r\n    const isRolling = !!state.hero.roll;\r\n    if (state.hero.attackChargeLevel > 1) {\r\n        state.hero.attackChargeDuration -= window.FRAME_LENGTH;\r\n        if (state.hero.attackChargeDuration <= 0) {\r\n            state.hero.attackChargeLevel = 1;\r\n        }\r\n    }\r\n    else if (state.hero.chargingLevel >= 2 && !isRolling &&\r\n        ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SPECIAL_ATTACK)\r\n            || (state.isUsingKeyboard && state.mouse.wasRightPressed))) {\r\n        let skipRegularCharge = false;\r\n        for (const enchantment of state.hero.uniqueEnchantments) {\r\n            const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_5__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n            skipRegularCharge = skipRegularCharge || !!((_a = definition.onActivateCharge) === null || _a === void 0 ? void 0 : _a.call(definition, state, enchantment));\r\n        }\r\n        // Charge duration is 2 seconds by default.\r\n        if (!skipRegularCharge) {\r\n            state.hero.totalChargeDuration = 2000;\r\n            state.hero.attackChargeDuration = state.hero.totalChargeDuration;\r\n            state.hero.attackChargeLevel = state.hero.chargingLevel;\r\n            (0,app_utils_audio__WEBPACK_IMPORTED_MODULE_6__.playSound)(state, 'activateCharge');\r\n            state.hero.chargingLevel = 1;\r\n            // Restart attack pattern when triggering charged attacks.\r\n            hero.attackCooldown = state.fieldTime;\r\n        }\r\n    }\r\n    const isShooting = (state.hero.isShooting\r\n        // Automatically shoot when using charge attack.\r\n        || (state.hero.attackChargeLevel > 1 && state.hero.attackChargeDuration > 0)) && !isRolling;\r\n    if (isShooting) {\r\n        const attackCooldownDuration = 1000 / attacksPerSecond;\r\n        if (hero.attackCooldown <= state.fieldTime) {\r\n            hero.attackCooldown = state.fieldTime + attackCooldownDuration;\r\n        }\r\n        const attackTime = attackCooldownDuration - (hero.attackCooldown - state.fieldTime);\r\n        for (const shot of weapon.getShots(state, weapon)) {\r\n            const shotTime = attackCooldownDuration * ((_b = shot.timingOffset) !== null && _b !== void 0 ? _b : 0);\r\n            if (shotTime >= attackTime - window.FRAME_LENGTH / 2 && shotTime < attackTime + window.FRAME_LENGTH / 2) {\r\n                // TODO: use right analog stick deltas if playing with game pad instead of state.mouse for target.\r\n                const target = {\r\n                    x: state.hero.x + state.mouse.x - window.FIELD_CENTER.x,\r\n                    y: state.hero.y + state.mouse.y - window.FIELD_CENTER.y,\r\n                };\r\n                const bullet = shot.generateBullet(state, hero, weapon, target);\r\n                if (bullet) {\r\n                    for (const enchantment of hero.uniqueEnchantments) {\r\n                        const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_5__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n                        (_c = definition.modifyBullet) === null || _c === void 0 ? void 0 : _c.call(definition, state, enchantment, bullet);\r\n                    }\r\n                    state.heroBullets.push(bullet);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if ((0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_15__.isMiddleMouseDown)() && state.dungeon) {\r\n        (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_16__.returnToOverworld)(state);\r\n    }\r\n    if (!((_d = state.hero.disc) === null || _d === void 0 ? void 0 : _d.boss)) {\r\n        assignToDisc(state.hero, state.activeDiscs);\r\n    }\r\n    constrainToDisc(state.hero, state.hero.disc);\r\n    constrainFromHoles(state.hero, state.holes);\r\n    for (const portal of state.portals) {\r\n        const isActive = !state.activeLoot && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_12__.doCirclesIntersect)(state.hero, portal);\r\n        if (isActive && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE)) {\r\n            portal.activate(state);\r\n            break;\r\n        }\r\n    }\r\n    if (hero.potions > 0 && hero.life < hero.maxLife && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_17__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.POTION)) {\r\n        hero.life = Math.min(hero.maxLife, Math.ceil(hero.life + hero.maxLife * 0.2 * hero.potionEffect));\r\n        hero.potions--;\r\n    }\r\n}\r\nfunction gainAttackCharge(state, amount) {\r\n    // Cannot gain charge while using a charged attack.\r\n    if (state.hero.attackChargeLevel > 1) {\r\n        return;\r\n    }\r\n    let currentCharge = state.hero.chargingLevel | 0;\r\n    state.hero.chargingLevel = Math.min((0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.getMaxChargeLevel)(state), state.hero.chargingLevel + amount);\r\n    if ((state.hero.chargingLevel | 0) > currentCharge) {\r\n        (0,app_utils_audio__WEBPACK_IMPORTED_MODULE_6__.playSound)(state, 'chargeReady');\r\n    }\r\n}\r\nfunction updateEnemies(state) {\r\n    var _a, _b, _c;\r\n    const boss = (_a = state.hero.disc) === null || _a === void 0 ? void 0 : _a.boss;\r\n    for (const enemy of state.enemies) {\r\n        enemy.frameDamageOverTime = 0;\r\n        // Freeze enemies outside of the boss fight.\r\n        if (boss && ((_b = enemy.disc) === null || _b === void 0 ? void 0 : _b.boss) !== boss) {\r\n            continue;\r\n        }\r\n        // Freeze bosses that are not activated.\r\n        if (!boss && ((_c = enemy.disc) === null || _c === void 0 ? void 0 : _c.boss) === enemy) {\r\n            continue;\r\n        }\r\n        if (enemy.warningTime && enemy.warningTime > 0) {\r\n            enemy.warningTime -= window.FRAME_LENGTH;\r\n            continue;\r\n        }\r\n        enemy.modeTime += window.FRAME_LENGTH;\r\n        enemy.time += window.FRAME_LENGTH;\r\n        enemy.definition.update(state, enemy);\r\n        // No changing discs during boss fights.\r\n        if (!boss) {\r\n            assignToDisc(enemy, state.activeDiscs);\r\n        }\r\n        constrainToDisc(enemy, enemy.disc);\r\n        constrainFromHoles(enemy, state.holes);\r\n    }\r\n}\r\nfunction updateHeroBullets(state) {\r\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\r\n    const activeBullets = [];\r\n    for (const bullet of state.heroBullets) {\r\n        if (bullet.time < bullet.duration) {\r\n            activeBullets.push(bullet);\r\n        }\r\n        else {\r\n            (_a = bullet.onDeath) === null || _a === void 0 ? void 0 : _a.call(bullet, state, bullet);\r\n            (_b = bullet.onHitOrDeath) === null || _b === void 0 ? void 0 : _b.call(bullet, state, bullet);\r\n        }\r\n    }\r\n    state.heroBullets = [];\r\n    const boss = (_c = state.hero.disc) === null || _c === void 0 ? void 0 : _c.boss;\r\n    let playedSound = false;\r\n    for (const bullet of activeBullets) {\r\n        bullet.time += window.FRAME_LENGTH;\r\n        if (bullet.warningTime > 0) {\r\n            bullet.warningTime -= window.FRAME_LENGTH;\r\n        }\r\n        bullet.update(state, bullet);\r\n        if (bullet.warningTime > 0) {\r\n            state.heroBullets.push(bullet);\r\n            continue;\r\n        }\r\n        let bulletAbsorbed = false, bulletHit = false;\r\n        for (const enemy of state.enemies) {\r\n            if (enemy.isInvulnerable || (enemy.warningTime && enemy.warningTime > 0)) {\r\n                continue;\r\n            }\r\n            if (enemy.life <= 0) {\r\n                continue;\r\n            }\r\n            // Freeze enemies outside of the boss fight.\r\n            if (boss && ((_d = enemy.disc) === null || _d === void 0 ? void 0 : _d.boss) !== boss) {\r\n                continue;\r\n            }\r\n            // Freeze bosses that are not activated.\r\n            if (!boss && ((_e = enemy.disc) === null || _e === void 0 ? void 0 : _e.boss) === enemy) {\r\n                continue;\r\n            }\r\n            if (bullet.hitTargets.has(enemy)) {\r\n                continue;\r\n            }\r\n            if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_12__.doCirclesIntersect)(enemy, bullet)) {\r\n                if (bullet.slowEffect) {\r\n                    (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_8__.applySlowEffect)(enemy, bullet.slowEffect);\r\n                }\r\n                if (bullet.damageOverTime) {\r\n                    const perFrameDamage = bullet.damageOverTime * window.FRAME_LENGTH / 1000;\r\n                    const maxPerFrameDamage = bullet.damageOverTimeLimit\r\n                        ? bullet.damageOverTimeLimit * window.FRAME_LENGTH / 1000\r\n                        : state.hero.equipment.weapon.damageOverTimeStackSize * perFrameDamage;\r\n                    // Damage over time only applies up to 5x its base damage on enemies.\r\n                    const damageDealt = Math.min(perFrameDamage, maxPerFrameDamage - enemy.frameDamageOverTime);\r\n                    if (damageDealt > 0) {\r\n                        enemy.life -= damageDealt;\r\n                        enemy.frameDamageOverTime += damageDealt;\r\n                        if (enemy.life > 0) {\r\n                            (_g = (_f = enemy.definition).onDamage) === null || _g === void 0 ? void 0 : _g.call(_f, state, enemy, bullet);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // console.log(perFrameDamage, 'limited to ', maxPerFrameDamage);\r\n                    }\r\n                }\r\n                else {\r\n                    bulletHit = true;\r\n                    bullet.hitTargets.add(enemy);\r\n                    const damage = (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_8__.applyArmorToDamage)(state, bullet.damage, enemy.armor);\r\n                    if (damage > 0 && !playedSound) {\r\n                        (0,app_utils_audio__WEBPACK_IMPORTED_MODULE_6__.playSound)(state, 'dealDamage');\r\n                        playedSound = true;\r\n                        (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_8__.addDamageNumber)(state, enemy, damage, bullet.isCrit);\r\n                    }\r\n                    if (bullet.chargeGain) {\r\n                        gainAttackCharge(state, bullet.chargeGain);\r\n                        // A bullet grants less charge for each additional enemy it hits.\r\n                        bullet.chargeGain /= 2;\r\n                    }\r\n                    enemy.life -= damage;\r\n                    let armorShred = bullet.armorShred;\r\n                    if (enemy.armor <= enemy.baseArmor / 2) {\r\n                        armorShred /= 2;\r\n                    }\r\n                    if (enemy.armor <= enemy.baseArmor / 4) {\r\n                        armorShred /= 2;\r\n                    }\r\n                    enemy.armor = Math.max(enemy.baseArmor / 10, enemy.armor * (1 - armorShred));\r\n                    if (enemy.life > 0) {\r\n                        // Shots are not absorbed by defeated enemies.\r\n                        bulletAbsorbed = !bullet.isEnemyPiercing;\r\n                        (_j = (_h = enemy.definition).onHit) === null || _j === void 0 ? void 0 : _j.call(_h, state, enemy, bullet);\r\n                        (_l = (_k = enemy.definition).onDamage) === null || _l === void 0 ? void 0 : _l.call(_k, state, enemy, bullet);\r\n                    }\r\n                }\r\n                if (enemy.life <= 0) {\r\n                    (0,app_utils_audio__WEBPACK_IMPORTED_MODULE_6__.playSound)(state, 'defeatEnemy');\r\n                    defeatEnemy(state, enemy);\r\n                }\r\n            }\r\n        }\r\n        if (bulletHit) {\r\n            (_m = bullet.onHit) === null || _m === void 0 ? void 0 : _m.call(bullet, state, bullet);\r\n            (_o = bullet.onHitOrDeath) === null || _o === void 0 ? void 0 : _o.call(bullet, state, bullet);\r\n        }\r\n        if (!bulletAbsorbed) {\r\n            state.heroBullets.push(bullet);\r\n        }\r\n        else {\r\n            (_p = bullet.onDeath) === null || _p === void 0 ? void 0 : _p.call(bullet, state, bullet);\r\n        }\r\n    }\r\n}\r\nfunction defeatEnemy(state, enemy) {\r\n    var _a, _b, _c, _d, _e, _f, _g;\r\n    enemy.life = 0;\r\n    (_b = (_a = enemy.definition).onDeath) === null || _b === void 0 ? void 0 : _b.call(_a, state, enemy);\r\n    const experiencePenalty = Math.min(1, Math.max(0, (state.hero.level - enemy.level) * 0.1));\r\n    const experience = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_9__.getBaseEnemyExperience)(enemy.level) * ((_c = enemy.definition.experienceFactor) !== null && _c !== void 0 ? _c : 1);\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.gainExperience)(state, Math.ceil(experience * (1 - experiencePenalty)));\r\n    const { armor, weapon } = state.hero.equipment;\r\n    // Gain more weapon experience when using higher level weapons.\r\n    let weaponXpFactor = 1;\r\n    if (weapon.level > (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.getProficiency)(state, weapon.weaponType).level) {\r\n        weaponXpFactor = 2;\r\n    }\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.gainEquipmentExperience)(state, weapon.weaponType, enemy.level, weaponXpFactor * experience);\r\n    let armorXpFactor = 1;\r\n    if (armor.level > (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.getProficiency)(state, armor.armorType).level) {\r\n        armorXpFactor = 2;\r\n    }\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.gainEquipmentExperience)(state, armor.armorType, enemy.level, armorXpFactor * experience);\r\n    (0,app_loot__WEBPACK_IMPORTED_MODULE_2__.checkToDropBasicLoot)(state, enemy);\r\n    if (enemy.disc && enemy.definition.portalDungeonType\r\n        && (0,app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_19__.rollWithMissBonus)(state, enemy.definition.portalDungeonType + 'Portal', ((_d = enemy.definition.portalChance) !== null && _d !== void 0 ? _d : 0))) {\r\n        (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_11__.addDungeonPortalToDisc)(state, enemy, enemy.definition.portalDungeonType, enemy.level, Math.random(), enemy.disc);\r\n    }\r\n    if (((_e = enemy.disc) === null || _e === void 0 ? void 0 : _e.boss) === enemy) {\r\n        delete enemy.disc.boss;\r\n        (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_16__.addOverworldPortalToDisc)(enemy.disc, enemy.disc);\r\n        // Destroy all boss minions when it is defeated. They will not grant experience as they are not\r\n        // killed by taking shot damage.\r\n        for (const minion of enemy.minions) {\r\n            minion.life = 0;\r\n        }\r\n        const enchantment = (_g = (_f = enemy.definition).getEnchantment) === null || _g === void 0 ? void 0 : _g.call(_f, state, enemy);\r\n        if (enchantment) {\r\n            (0,app_loot__WEBPACK_IMPORTED_MODULE_2__.dropEnchantmentLoot)(state, enemy.disc, {\r\n                x: enemy.disc.x,\r\n                y: enemy.disc.y + 100,\r\n            }, enchantment);\r\n        }\r\n        const name = enemy.definition.name;\r\n        const weaponType = app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.masteryMap[name];\r\n        const oldMasteryLevel = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.getMastery)(state, weaponType);\r\n        state.hero.bossRecords[name] = Math.max(state.hero.bossRecords[name] || 0, enemy.level);\r\n        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.setDerivedHeroStats)(state);\r\n        const newMasteryLevel = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.getMastery)(state, weaponType);\r\n        if (newMasteryLevel > oldMasteryLevel) {\r\n            state.fieldText.push({\r\n                x: state.hero.x,\r\n                y: state.hero.y - 10,\r\n                vx: 0,\r\n                vy: -0.5,\r\n                text: '+' + (newMasteryLevel - oldMasteryLevel) + ' ' + app_weapons__WEBPACK_IMPORTED_MODULE_23__.weaponTypeLabels[weaponType] + ' Mastery!',\r\n                color: 'blue',\r\n                borderColor: 'white',\r\n                expirationTime: state.fieldTime + 3000,\r\n                time: 0,\r\n            });\r\n        }\r\n    }\r\n}\r\n// This radius should be slightly larger than the maximum enemy aggro radius.\r\n// Currently the highest aggro radius is 800 on the sniper.\r\nconst enemyBulletR2 = 900 ** 2;\r\nfunction updateEnemyBullets(state) {\r\n    var _a;\r\n    const hero = state.hero;\r\n    hero.frameDamageOverTime = 0;\r\n    let shaved = false, onHit = false;\r\n    const shavebullet = (bullet) => {\r\n        var _a;\r\n        if (!state.hero.flags.noShaveCharge) {\r\n            gainAttackCharge(state, 1 / 10);\r\n        }\r\n        for (const enchantment of state.hero.uniqueEnchantments) {\r\n            const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_5__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n            (_a = definition.onShave) === null || _a === void 0 ? void 0 : _a.call(definition, state, enchantment, bullet);\r\n        }\r\n        bullet.shaveCompleted = true;\r\n        if (!shaved) {\r\n            (0,app_utils_audio__WEBPACK_IMPORTED_MODULE_6__.playSound)(state, 'shaveBullet');\r\n            shaved = true;\r\n        }\r\n    };\r\n    const activeBullets = [];\r\n    for (const bullet of state.enemyBullets) {\r\n        if (bullet.time < bullet.duration) {\r\n            activeBullets.push(bullet);\r\n        }\r\n        else {\r\n            if (bullet.onDeath) {\r\n                bullet.onDeath(state, bullet);\r\n            }\r\n            if (bullet.shaveStarted && !bullet.shaveCompleted) {\r\n                shavebullet(bullet);\r\n            }\r\n        }\r\n    }\r\n    state.enemyBullets = [];\r\n    const shaveRadius = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_14__.getHeroShaveRadius)(state);\r\n    for (const bullet of activeBullets) {\r\n        const bulletDistance2 = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_12__.getTargetVector)(state.hero, bullet).distance2;\r\n        // Forget about enemy bullets that get too far away.\r\n        if (bulletDistance2 >= enemyBulletR2) {\r\n            continue;\r\n        }\r\n        bullet.time += window.FRAME_LENGTH;\r\n        if (bullet.warningTime > 0) {\r\n            bullet.warningTime -= window.FRAME_LENGTH;\r\n        }\r\n        bullet.update(state, bullet);\r\n        if (bullet.warningTime > 0) {\r\n            state.enemyBullets.push(bullet);\r\n            continue;\r\n        }\r\n        let hitTarget = false;\r\n        if (!hero.roll && bulletDistance2 < (state.hero.radius + bullet.radius) ** 2) {\r\n            if (bullet.slowEffect) {\r\n                (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_8__.applySlowEffect)(state.hero, bullet.slowEffect);\r\n            }\r\n            if (bullet.damageOverTime) {\r\n                (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_8__.damageHeroOverTime)(state, bullet.damageOverTime * window.FRAME_LENGTH / 1000);\r\n            }\r\n            else {\r\n                if (!onHit) {\r\n                    for (const enchantment of state.hero.uniqueEnchantments) {\r\n                        const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_5__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n                        (_a = definition.onHit) === null || _a === void 0 ? void 0 : _a.call(definition, state, enchantment, bullet);\r\n                    }\r\n                    onHit = true;\r\n                }\r\n                hitTarget = true;\r\n                let armorShred = bullet.armorShred;\r\n                if (hero.armor <= hero.baseArmor / 2) {\r\n                    armorShred /= 2;\r\n                }\r\n                if (hero.armor <= hero.baseArmor / 4) {\r\n                    armorShred /= 2;\r\n                }\r\n                hero.armor = Math.max(hero.baseArmor / 10, hero.armor * (1 - armorShred));\r\n                hero.lastTimeDamaged = state.fieldTime;\r\n                (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_8__.damageHero)(state, bullet.damage);\r\n            }\r\n        }\r\n        else if (!bullet.shaveStarted && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_12__.doCirclesIntersect)(bullet, { ...state.hero, radius: state.hero.radius + shaveRadius })) {\r\n            bullet.shaveStarted = true;\r\n            /*if (!shaved) {\r\n                playSound(state, 'shaveBullet');\r\n                shaved = true;\r\n            }*/\r\n        }\r\n        else if (bullet.shaveStarted && !bullet.shaveCompleted && !(0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_12__.doCirclesIntersect)(bullet, { ...state.hero, radius: state.hero.radius + shaveRadius })) {\r\n            shavebullet(bullet);\r\n        }\r\n        if (!hitTarget) {\r\n            state.enemyBullets.push(bullet);\r\n        }\r\n    }\r\n    state.enemies = state.enemies.filter(e => e.life > 0);\r\n}\r\nfunction assignToDisc(geometry, discs) {\r\n    geometry.disc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_10__.findClosestDisc)(geometry, discs);\r\n}\r\nfunction constrainToDisc(geometry, disc) {\r\n    if (!disc) {\r\n        return;\r\n    }\r\n    const dx = geometry.x - disc.x, dy = geometry.y - disc.y;\r\n    const distance2 = dx * dx + dy * dy;\r\n    if (distance2 > disc.radius * disc.radius) {\r\n        const m = Math.sqrt(distance2);\r\n        geometry.x = disc.x + disc.radius * dx / m;\r\n        geometry.y = disc.y + disc.radius * dy / m;\r\n    }\r\n}\r\nfunction constrainFromHoles(geometry, holes) {\r\n    for (const hole of holes) {\r\n        const dx = geometry.x - hole.x, dy = geometry.y - hole.y;\r\n        const distance2 = dx * dx + dy * dy;\r\n        if (distance2 < hole.radius * hole.radius) {\r\n            const m = Math.sqrt(distance2);\r\n            geometry.x = hole.x + hole.radius * dx / m;\r\n            geometry.y = hole.y + hole.radius * dy / m;\r\n        }\r\n    }\r\n}\r\nfunction renderLoop() {\r\n    try {\r\n        window.requestAnimationFrame(renderLoop);\r\n        const state = getState();\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_4__.render)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_7__.mainContext, state);\r\n    }\r\n    catch (e) {\r\n        console.log(e);\r\n        debugger;\r\n    }\r\n}\r\nrenderLoop();\r\nsetInterval(update, window.FRAME_LENGTH);\r\n\n\n//# sourceURL=webpack://alttp/./app/client.ts?");

/***/ }),

/***/ "./app/constants.ts":
/*!**************************!*\
  !*** ./app/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GAME_KEY: () => (/* binding */ GAME_KEY)\n/* harmony export */ });\nwindow.FRAME_LENGTH = 20;\r\nwindow.CANVAS_WIDTH = 1000;\r\nwindow.CANVAS_HEIGHT = 800;\r\nwindow.CANVAS_SCALE = 1;\r\nwindow.SIGHT_RADIUS = 400;\r\nwindow.SLOT_SIZE = 40;\r\nwindow.SLOT_PADDING = 10;\r\nwindow.CELL_SIZE = 3000;\r\nwindow.BASE_DROP_CHANCE = 0.15;\r\nwindow.HERO_DAMAGE_FRAME_COUNT = 20;\r\n// This is added to the player's base radius.\r\nwindow.BULLET_SHAVE_RADIUS = 20;\r\nwindow.BASE_MAX_POTIONS = 5;\r\nwindow.BASE_XP = 10;\r\nwindow.BASE_ATTACKS_PER_SECOND = 2;\r\nwindow.BASE_WEAPON_DPS_PER_LEVEL = 10;\r\nwindow.BASE_WEAPON_DPS_PER_LEVEL_MULTIPLIER = 1.024;\r\nwindow.BASE_BULLET_SPEED = 500;\r\nwindow.BASE_BULLET_RADIUS = 10;\r\nwindow.BASE_BULLET_DURATION = 1000;\r\nwindow.BASE_ENEMY_SPEED = 200;\r\nwindow.BASE_ENEMY_BULLET_SPEED = 250;\r\nwindow.BASE_ENEMY_BULLET_RADIUS = 10;\r\nwindow.BASE_ENEMY_BULLET_DURATION = 1000;\r\nwindow.BOSS_MAX_LIFE_FACTOR = 20;\r\nwindow.EVENT_BOSS_MAX_LIFE_FACTOR = 30;\r\nwindow.FIELD_CENTER = { x: window.SIGHT_RADIUS + 40, y: window.CANVAS_HEIGHT / 2 };\r\nconst GAME_KEY = {\r\n    MENU: 0,\r\n    UP: 1,\r\n    DOWN: 2,\r\n    LEFT: 3,\r\n    RIGHT: 4,\r\n    RUN: 5,\r\n    ACTIVATE: 6,\r\n    SELL: 7,\r\n    POTION: 8,\r\n    AIM_UP: 9,\r\n    AIM_DOWN: 10,\r\n    AIM_LEFT: 11,\r\n    AIM_RIGHT: 12,\r\n    SHOOT: 13,\r\n    SPECIAL_ATTACK: 14,\r\n    MUTE: 15,\r\n    GUARD_SKILL: 16,\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/constants.ts?");

/***/ }),

/***/ "./app/contextMenu.ts":
/*!****************************!*\
  !*** ./app/contextMenu.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextMenu: () => (/* binding */ ContextMenu),\n/* harmony export */   addContextMenuListeners: () => (/* binding */ addContextMenuListeners),\n/* harmony export */   getContextMenu: () => (/* binding */ getContextMenu),\n/* harmony export */   hideContextMenu: () => (/* binding */ hideContextMenu),\n/* harmony export */   showContextMenu: () => (/* binding */ showContextMenu)\n/* harmony export */ });\n/* harmony import */ var app_armor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/armor */ \"./app/armor.ts\");\n/* harmony import */ var app_utils_item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/item */ \"./app/utils/item.ts\");\n/* harmony import */ var app_uniqueEnchantments__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/uniqueEnchantments */ \"./app/uniqueEnchantments.ts\");\n/* harmony import */ var app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/uniqueEnchantmentHash */ \"./app/uniqueEnchantmentHash.ts\");\n/* harmony import */ var app_utils_dungeon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/dungeon */ \"./app/utils/dungeon.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_overworld__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/overworld */ \"./app/utils/overworld.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ContextMenu {\r\n    constructor(menuOptions) {\r\n        this.menuOptions = menuOptions;\r\n    }\r\n    /**\r\n        <div class=\"contextMenu\">\r\n            <div class=\"contextOption\">\r\n                Option 1\r\n            </div>\r\n            <div class=\"contextOption\">\r\n                Option 2\r\n            </div>\r\n        </div>\r\n    */\r\n    render(container, x, y) {\r\n        //this.domElement = createContextMenuElement(this.menuOptions);\r\n        this.container = container;\r\n        this.domElement = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_7__.tagElement)('div', 'contextMenu');\r\n        for (const option of this.menuOptions) {\r\n            const label = option.getLabel ? option.getLabel() : (option.label || ' ');\r\n            const optionElement = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_7__.tagElement)('div', 'contextOption', label);\r\n            if (option.onSelect) {\r\n                optionElement.onclick = function () {\r\n                    var _a;\r\n                    (_a = option.onSelect) === null || _a === void 0 ? void 0 : _a.call(option);\r\n                    hideContextMenu();\r\n                };\r\n            }\r\n            optionElement.addEventListener('mouseover', event => {\r\n                // Do nothing if this is the last element we hovered over.\r\n                if (this.hoveredOptionElement === optionElement) {\r\n                    return;\r\n                }\r\n                if (this.hoveredOptionElement) {\r\n                    this.hoveredOptionElement.classList.remove('open');\r\n                }\r\n                this.hoveredOptionElement = optionElement;\r\n                // If another child menu is being displayed, remove it when we hover\r\n                // over a new element at this level.\r\n                if (this.displayedChildMenu) {\r\n                    this.displayedChildMenu.remove();\r\n                }\r\n                const children = option.getChildren ? option.getChildren() : [];\r\n                if (children.length) {\r\n                    this.hoveredOptionElement.classList.add('open');\r\n                    this.displayedChildMenu = new ContextMenu(children);\r\n                    const limits = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_7__.getElementRect)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_6__.mainCanvas, this.container);\r\n                    const r = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_7__.getElementRect)(optionElement, this.container);\r\n                    this.displayedChildMenu.render(this.container, r.x + r.w, r.y);\r\n                    if (!this.displayedChildMenu.domElement) {\r\n                        return;\r\n                    }\r\n                    const r2 = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_7__.getElementRect)(this.displayedChildMenu.domElement, this.container);\r\n                    // If the menu is too low, move it up.\r\n                    const bottom = limits.y + limits.h;\r\n                    if (r2.y + r2.h > bottom) {\r\n                        this.displayedChildMenu.domElement.style.top = `${bottom - r2.h}px`;\r\n                    }\r\n                    // If the menu is too far to the right, display it entirely to the left\r\n                    // of the parent element.\r\n                    if (r2.x + r2.w > limits.x + limits.w) {\r\n                        this.displayedChildMenu.domElement.style.left = `${r.x - r2.w}px`;\r\n                    }\r\n                }\r\n            });\r\n            this.domElement.append(optionElement);\r\n        }\r\n        this.container.append(this.domElement);\r\n        this.domElement.style.left = `${x}px`;\r\n        this.domElement.style.top = `${y}px`;\r\n    }\r\n    remove() {\r\n        if (this.domElement) {\r\n            this.domElement.remove();\r\n            delete this.domElement;\r\n            if (this.displayedChildMenu) {\r\n                this.displayedChildMenu.remove();\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction getContextMenu(state) {\r\n    const options = [\r\n        {\r\n            label: 'Full Life',\r\n            onSelect() {\r\n                (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.refillAllPotions)(state);\r\n            }\r\n        },\r\n        {\r\n            label: 'Set Hero Level',\r\n            getChildren() {\r\n                return [1, 5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100].map(level => ({\r\n                    label: `Lvl ${level}`,\r\n                    onSelect() {\r\n                        state.hero.level = level;\r\n                        state.hero.equipment.weapon = (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.generateWeapon)(state.hero.equipment.weapon.weaponType, level);\r\n                        state.hero.equipment.armor = (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.generateArmor)(state.hero.equipment.armor.armorType, level);\r\n                        state.hero.bossRecords = {};\r\n                        for (const equipmentType of [...app_armor__WEBPACK_IMPORTED_MODULE_0__.armorTypes, ...app_weapons__WEBPACK_IMPORTED_MODULE_11__.weaponTypes]) {\r\n                            const proficiency = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.getProficiency)(state, equipmentType);\r\n                            proficiency.level = level - 1;\r\n                            proficiency.experience = 0;\r\n                        }\r\n                        // Move hero to corresponding overworld area.\r\n                        if (level === 1) {\r\n                            state.hero.overworldY = 0;\r\n                        }\r\n                        else if (level === 5) {\r\n                            state.hero.overworldY = -window.CELL_SIZE * 3;\r\n                        }\r\n                        else {\r\n                            state.hero.overworldY = -window.CELL_SIZE * (3 + 2 * Math.floor(level / 10));\r\n                        }\r\n                        if (!state.dungeon) {\r\n                            state.hero.y = state.hero.overworldY;\r\n                        }\r\n                        state.hero.experience = 0;\r\n                        state.hero.weapons = [];\r\n                        state.hero.armors = [];\r\n                        state.hero.enchantments = [];\r\n                        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.setDerivedHeroStats)(state);\r\n                        (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_9__.updateActiveCells)(state);\r\n                        if (!state.dungeon) {\r\n                            (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_9__.clearNearbyEnemies)(state);\r\n                        }\r\n                    }\r\n                }));\r\n            },\r\n        },\r\n        {\r\n            label: 'Test Dungeon',\r\n            getChildren() {\r\n                return app_utils_dungeon__WEBPACK_IMPORTED_MODULE_4__.dungeonTypes.map(dungeonType => ({\r\n                    label: dungeonType,\r\n                    onSelect() {\r\n                        const dungeon = (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_4__.createDungeon)(state, dungeonType, state.hero.level);\r\n                        (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_4__.startDungeon)(state, dungeon);\r\n                    }\r\n                }));\r\n            },\r\n        },\r\n        {\r\n            label: 'Set Weapon',\r\n            getChildren() {\r\n                return app_weapons__WEBPACK_IMPORTED_MODULE_11__.weaponTypes.map(weaponType => ({\r\n                    label: weaponType,\r\n                    onSelect() {\r\n                        const oldWeapon = state.hero.equipment.weapon;\r\n                        state.hero.equipment.weapon = (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.generateWeapon)(weaponType, state.hero.level);\r\n                        state.hero.equipment.weapon.bonusEnchantmentSlots = oldWeapon.bonusEnchantmentSlots;\r\n                        (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.applyUniqueItemEnchantments)(state.hero.equipment.weapon);\r\n                        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.setDerivedHeroStats)(state);\r\n                    }\r\n                }));\r\n            },\r\n        },\r\n        {\r\n            label: 'Set Armor',\r\n            getChildren() {\r\n                return app_armor__WEBPACK_IMPORTED_MODULE_0__.armorTypes.map(armorType => ({\r\n                    label: armorType,\r\n                    onSelect() {\r\n                        const oldArmor = state.hero.equipment.armor;\r\n                        state.hero.equipment.armor = (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.generateArmor)(armorType, state.hero.level);\r\n                        state.hero.equipment.armor.bonusEnchantmentSlots = oldArmor.bonusEnchantmentSlots;\r\n                        (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.applyUniqueItemEnchantments)(state.hero.equipment.armor);\r\n                        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.setDerivedHeroStats)(state);\r\n                    }\r\n                }));\r\n            },\r\n        },\r\n        {\r\n            label: 'Set Unique Weapon',\r\n            getChildren() {\r\n                return Object.values(app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_3__.uniqueEnchantmentHash)\r\n                    .filter(enchantment => enchantment.enchantmentType === 'uniqueWeaponEnchantment')\r\n                    .map(uniqueWeaponEnchantment => ({\r\n                    label: uniqueWeaponEnchantment.name,\r\n                    onSelect() {\r\n                        const weapon = state.hero.equipment.weapon;\r\n                        weapon.bonusEnchantmentSlots = [];\r\n                        (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.resetWeapon)(weapon);\r\n                        (0,app_uniqueEnchantments__WEBPACK_IMPORTED_MODULE_2__.addUniqueEnchantmentToItem)(weapon, uniqueWeaponEnchantment);\r\n                        (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.applyUniqueItemEnchantments)(weapon);\r\n                        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.setDerivedHeroStats)(state);\r\n                    }\r\n                }));\r\n            }\r\n        },\r\n        {\r\n            label: 'Set Unique Armor',\r\n            getChildren() {\r\n                return Object.values(app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_3__.uniqueEnchantmentHash)\r\n                    .filter(enchantment => enchantment.enchantmentType === 'uniqueArmorEnchantment')\r\n                    .map(uniqueArmorEnchantment => ({\r\n                    label: uniqueArmorEnchantment.name,\r\n                    onSelect() {\r\n                        const armor = state.hero.equipment.armor;\r\n                        armor.bonusEnchantmentSlots = [];\r\n                        (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.resetArmor)(armor);\r\n                        (0,app_uniqueEnchantments__WEBPACK_IMPORTED_MODULE_2__.addUniqueEnchantmentToItem)(armor, uniqueArmorEnchantment);\r\n                        (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.applyUniqueItemEnchantments)(armor);\r\n                        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_8__.setDerivedHeroStats)(state);\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n    ];\r\n    return options;\r\n}\r\nconst contextMenuState = {\r\n    contextMenu: undefined\r\n};\r\nfunction showContextMenu(menu, x, y) {\r\n    hideContextMenu();\r\n    const container = document.body;\r\n    contextMenuState.contextMenu = new ContextMenu(menu);\r\n    contextMenuState.contextMenu.render(container, x, y);\r\n    if (!contextMenuState.contextMenu.domElement) {\r\n        return;\r\n    }\r\n    const limits = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_7__.getElementRect)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_6__.mainCanvas, container);\r\n    const r = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_7__.getElementRect)(contextMenuState.contextMenu.domElement, container);\r\n    const bottom = limits.y + limits.h;\r\n    const right = limits.x + limits.w;\r\n    if (r.y + r.h > bottom) {\r\n        contextMenuState.contextMenu.domElement.style.top = `${bottom - r.h}px`;\r\n    }\r\n    // If the menu is too far to the right, display it entirely to the left\r\n    // of the parent element.\r\n    if (r.x + r.w > right) {\r\n        contextMenuState.contextMenu.domElement.style.left = `${right - r.w}px`;\r\n    }\r\n}\r\nfunction hideContextMenu() {\r\n    if (contextMenuState.contextMenu) {\r\n        contextMenuState.contextMenu.remove();\r\n        delete contextMenuState.contextMenu;\r\n    }\r\n}\r\nfunction addContextMenuListeners(state) {\r\n    document.addEventListener('mouseup', function (event) {\r\n        if (event.which !== 1) {\r\n            return;\r\n        }\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_5__.KEY.CONTROL)) {\r\n            event.preventDefault();\r\n            const [x, y] = (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_10__.getMousePosition)();\r\n            (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_10__.getMousePosition)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_6__.mainCanvas, window.CANVAS_SCALE);\r\n            const menu = getContextMenu(state);\r\n            showContextMenu(menu, x, y);\r\n        }\r\n        else if (!event.target.closest('.contextMenu')) {\r\n            hideContextMenu();\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/contextMenu.ts?");

/***/ }),

/***/ "./app/dungeons/pearlTrove.ts":
/*!************************************!*\
  !*** ./app/dungeons/pearlTrove.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPearlTroveDungeon: () => (/* binding */ createPearlTroveDungeon)\n/* harmony export */ });\n/* harmony import */ var app_enemies_chest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enemies/chest */ \"./app/enemies/chest.ts\");\n/* harmony import */ var app_enemies_clam__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enemies/clam */ \"./app/enemies/clam.ts\");\n/* harmony import */ var app_utils_disc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/disc */ \"./app/utils/disc.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_overworld__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/overworld */ \"./app/utils/overworld.ts\");\n/* harmony import */ var app_utils_SRandom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/SRandom */ \"./app/utils/SRandom.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst pearlTrove = {\r\n    name: 'Pearl Trove',\r\n    color: '#28F',\r\n    centerColor: '#4CF',\r\n    topEdgeColor: '#12D',\r\n    bottomEdgeColor: '#00A',\r\n};\r\nfunction createPearlTroveDungeon(state, seed, radius, level) {\r\n    const discs = [];\r\n    const entrance = { x: 0, y: 0, radius: 16 };\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_5__[\"default\"].seed(seed);\r\n    const startingPlatform = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.createDisc)({\r\n        level,\r\n        ...pearlTrove,\r\n        x: entrance.x,\r\n        y: entrance.y,\r\n        radius: 400,\r\n    });\r\n    (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_4__.addOverworldPortalToDisc)(entrance, startingPlatform);\r\n    discs.push(startingPlatform);\r\n    for (let i = 0; i < 3; i++) {\r\n        dungeonRandomizer.nextSeed();\r\n        const theta = 2 * Math.PI * i / 3;\r\n        const treasureDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.createDisc)({\r\n            level,\r\n            ...pearlTrove,\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: 300,\r\n        });\r\n        (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.projectDiscToClosestDisc)(discs, treasureDisc, 32);\r\n        discs.push(treasureDisc);\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, treasureDisc.x, treasureDisc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_0__.chest, level + 1, treasureDisc);\r\n        const bossDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.createDisc)({\r\n            level,\r\n            ...pearlTrove,\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: 400,\r\n        });\r\n        (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.projectDiscToClosestDisc)(discs, bossDisc, 32);\r\n        bossDisc.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, bossDisc.x, bossDisc.y, app_enemies_clam__WEBPACK_IMPORTED_MODULE_1__.giantClam, level + 2, bossDisc);\r\n        bossDisc.boss.isBoss = true;\r\n        discs.push(bossDisc);\r\n    }\r\n    (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.linkDiscs)(discs);\r\n    return {\r\n        name: pearlTrove.name,\r\n        level,\r\n        discs,\r\n        entrance,\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/dungeons/pearlTrove.ts?");

/***/ }),

/***/ "./app/dungeons/reef.ts":
/*!******************************!*\
  !*** ./app/dungeons/reef.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createReefDungeon: () => (/* binding */ createReefDungeon)\n/* harmony export */ });\n/* harmony import */ var app_enemies_chest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enemies/chest */ \"./app/enemies/chest.ts\");\n/* harmony import */ var app_enemies_clam__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enemies/clam */ \"./app/enemies/clam.ts\");\n/* harmony import */ var app_enemies_crab__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/enemies/crab */ \"./app/enemies/crab.ts\");\n/* harmony import */ var app_enemies_squid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enemies/squid */ \"./app/enemies/squid.ts\");\n/* harmony import */ var app_enemies_urchin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/enemies/urchin */ \"./app/enemies/urchin.ts\");\n/* harmony import */ var app_utils_disc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/disc */ \"./app/utils/disc.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_overworld__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/overworld */ \"./app/utils/overworld.ts\");\n/* harmony import */ var app_utils_SRandom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/SRandom */ \"./app/utils/SRandom.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst platformSizes = [200, 350, 500];\r\nconst reefBiome = {\r\n    name: 'Reef',\r\n    color: '#28F',\r\n    centerColor: '#4CF',\r\n    topEdgeColor: '#12D',\r\n    bottomEdgeColor: '#00A',\r\n};\r\nfunction createReefDungeon(state, seed, radius, level) {\r\n    const discs = [];\r\n    const entrance = { x: 0, y: radius, radius: 16 };\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_8__[\"default\"].seed(seed);\r\n    const startingPlatform = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_5__.createDisc)({\r\n        level,\r\n        ...reefBiome,\r\n        x: entrance.x,\r\n        y: entrance.y,\r\n        radius: 400,\r\n    });\r\n    (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_7__.addOverworldPortalToDisc)(entrance, startingPlatform);\r\n    discs.push(startingPlatform);\r\n    let finished = false;\r\n    for (let i = 0; i < 100 && (!finished || i < 10); i++) {\r\n        dungeonRandomizer.nextSeed();\r\n        const theta = 5 * Math.PI / 4 + Math.PI * dungeonRandomizer.generateAndMutate() / 2;\r\n        const newDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_5__.createDisc)({\r\n            level,\r\n            ...reefBiome,\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: dungeonRandomizer.element(platformSizes),\r\n        });\r\n        (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_5__.projectDiscToClosestDisc)(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n        if (newDisc.x * newDisc.x + newDisc.y * newDisc.y >= radius * radius) {\r\n            // Only one disc is allowed to spawn outside of the radius.\r\n            if (!finished) {\r\n                finished = true;\r\n                newDisc.radius = 400;\r\n                (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_5__.projectDiscToClosestDisc)(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n                newDisc.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_6__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_clam__WEBPACK_IMPORTED_MODULE_1__.giantClam, level + 2, newDisc);\r\n                newDisc.boss.isBoss = true;\r\n                discs.push(newDisc);\r\n            }\r\n            continue;\r\n        }\r\n        discs.push(newDisc);\r\n        // TODO: Add different enemy generators and apply them at random.\r\n        if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_6__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_urchin__WEBPACK_IMPORTED_MODULE_4__.reefUrchin, level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_6__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_clam__WEBPACK_IMPORTED_MODULE_1__.clam, level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_6__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_0__.chest, level + 1, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_6__.createEnemy)(state, newDisc.x + 50, newDisc.y, app_enemies_crab__WEBPACK_IMPORTED_MODULE_2__.crab, level, newDisc);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_6__.createEnemy)(state, newDisc.x - 50, newDisc.y, app_enemies_crab__WEBPACK_IMPORTED_MODULE_2__.crab, level, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_6__.createEnemy)(state, newDisc.x, newDisc.y + 50, app_enemies_squid__WEBPACK_IMPORTED_MODULE_3__.squid, level, newDisc);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_6__.createEnemy)(state, newDisc.x, newDisc.y - 50, app_enemies_squid__WEBPACK_IMPORTED_MODULE_3__.squid, level, newDisc);\r\n        }\r\n    }\r\n    (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_5__.linkDiscs)(discs);\r\n    return {\r\n        name: reefBiome.name,\r\n        level,\r\n        discs,\r\n        entrance,\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/dungeons/reef.ts?");

/***/ }),

/***/ "./app/dungeons/spiderDen.ts":
/*!***********************************!*\
  !*** ./app/dungeons/spiderDen.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSpiderDenDungeon: () => (/* binding */ createSpiderDenDungeon)\n/* harmony export */ });\n/* harmony import */ var app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/bosses/spider */ \"./app/bosses/spider.ts\");\n/* harmony import */ var app_enemies_chest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enemies/chest */ \"./app/enemies/chest.ts\");\n/* harmony import */ var app_utils_disc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/disc */ \"./app/utils/disc.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_overworld__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/overworld */ \"./app/utils/overworld.ts\");\n/* harmony import */ var app_utils_SRandom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/SRandom */ \"./app/utils/SRandom.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction generateConnectingDiscs(source, target, randomizer, sizes) {\r\n    const discs = [];\r\n    let safety = 100;\r\n    while (!(0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.doCirclesIntersect)({ ...source, radius: source.radius - 16 }, { ...target, radius: target.radius - 16 }) && safety-- > 0) {\r\n        const newDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.createDisc)({\r\n            level: target.level,\r\n            name: target.name,\r\n            color: target.color,\r\n            centerColor: target.centerColor,\r\n            topEdgeColor: target.topEdgeColor,\r\n            bottomEdgeColor: target.bottomEdgeColor,\r\n            x: target.x,\r\n            y: target.y,\r\n            enemies: [],\r\n            radius: randomizer.element(sizes),\r\n        });\r\n        newDisc.x += 128 * (0.5 - Math.random());\r\n        newDisc.y += 128 * (0.5 - Math.random());\r\n        (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.projectDiscToDisc)(newDisc, source, randomizer.range(32, 48));\r\n        randomizer.generateAndMutate();\r\n        discs.push(newDisc);\r\n        source = newDisc;\r\n    }\r\n    return discs;\r\n}\r\nfunction createBridge(state, discs, source, target, randomizer) {\r\n    const bridgeDiscs = generateConnectingDiscs(source, target, randomizer, smallPlatformSizes);\r\n    for (const disc of bridgeDiscs) {\r\n        disc.holes.push({ x: disc.x, y: disc.y, radius: disc.radius / 2 });\r\n        if (randomizer.generateAndMutate() < 0.05) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_1__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, disc.x, disc.y - 60, app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.babySpiderBomber, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, disc.x, disc.y + 60, app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.babySpiderBomber, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, disc.x - 60, disc.y, app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.babySpiderNova, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, disc.x + 60, disc.y, app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.babySpiderNova, disc.level, disc);\r\n        }\r\n        discs.push(disc);\r\n    }\r\n}\r\nconst spiderDenBiome = {\r\n    name: 'Spider Den',\r\n    color: '#EEE',\r\n    centerColor: '#888',\r\n    topEdgeColor: '#888',\r\n    bottomEdgeColor: '#444',\r\n};\r\nconst smallPlatformSizes = [150, 200, 250];\r\nfunction createSpiderDenDungeon(state, seed, level) {\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_6__[\"default\"].seed(seed);\r\n    const radius = 1600 + 10 * level;\r\n    const name = 'Spider Den';\r\n    const discs = [];\r\n    const entranceTheta = 2 * Math.PI * dungeonRandomizer.generateAndMutate();\r\n    const entrance = {\r\n        x: radius * Math.cos(entranceTheta),\r\n        y: radius * Math.sin(entranceTheta),\r\n        radius: 16,\r\n    };\r\n    const startingPlatform = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.createDisc)({\r\n        level,\r\n        ...spiderDenBiome,\r\n        x: entrance.x,\r\n        y: entrance.y,\r\n        radius: 600,\r\n    });\r\n    (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_5__.addOverworldPortalToDisc)(entrance, startingPlatform);\r\n    discs.push(startingPlatform);\r\n    let previousPlatform = startingPlatform;\r\n    const largePlatforms = [];\r\n    for (let i = 1; i < 5; i++) {\r\n        const theta = entranceTheta + i * 2 * Math.PI / 5;\r\n        const largePlatform = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.createDisc)({\r\n            level,\r\n            ...spiderDenBiome,\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: 350,\r\n        });\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, largePlatform.x, largePlatform.y, (i % 2) ? app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.spiderPinwheel : app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.spiderFlower, largePlatform.level + 1, largePlatform);\r\n        createBridge(state, discs, largePlatform, previousPlatform, dungeonRandomizer);\r\n        discs.push(largePlatform);\r\n        largePlatforms.push(largePlatform);\r\n        previousPlatform = largePlatform;\r\n    }\r\n    // Complete the circle\r\n    createBridge(state, discs, previousPlatform, startingPlatform, dungeonRandomizer);\r\n    const bossPlatform = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.createDisc)({\r\n        level,\r\n        ...spiderDenBiome,\r\n        x: 0,\r\n        y: 0,\r\n        radius: 400,\r\n    });\r\n    // Join all platforms but the starting platform to the boss platform\r\n    for (const largePlatform of largePlatforms) {\r\n        createBridge(state, discs, bossPlatform, largePlatform, dungeonRandomizer);\r\n    }\r\n    bossPlatform.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, bossPlatform.x, bossPlatform.y, app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.spider, Math.min(100, level + 2), bossPlatform);\r\n    bossPlatform.boss.isBoss = true;\r\n    discs.push(bossPlatform);\r\n    (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.linkDiscs)(discs);\r\n    return {\r\n        name,\r\n        level,\r\n        discs,\r\n        entrance,\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/dungeons/spiderDen.ts?");

/***/ }),

/***/ "./app/dungeons/tree.ts":
/*!******************************!*\
  !*** ./app/dungeons/tree.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTreeDungeon: () => (/* binding */ createTreeDungeon)\n/* harmony export */ });\n/* harmony import */ var app_bosses_guardian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/bosses/guardian */ \"./app/bosses/guardian.ts\");\n/* harmony import */ var app_bosses_spider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/bosses/spider */ \"./app/bosses/spider.ts\");\n/* harmony import */ var app_enemies_chest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/enemies/chest */ \"./app/enemies/chest.ts\");\n/* harmony import */ var app_enemies_ent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enemies/ent */ \"./app/enemies/ent.ts\");\n/* harmony import */ var app_enemies_lord__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/enemies/lord */ \"./app/enemies/lord.ts\");\n/* harmony import */ var app_enemies_snake__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/enemies/snake */ \"./app/enemies/snake.ts\");\n/* harmony import */ var app_enemies_sniper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/enemies/sniper */ \"./app/enemies/sniper.ts\");\n/* harmony import */ var app_enemies_turret__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/enemies/turret */ \"./app/enemies/turret.ts\");\n/* harmony import */ var app_utils_disc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/disc */ \"./app/utils/disc.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_overworld__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/overworld */ \"./app/utils/overworld.ts\");\n/* harmony import */ var app_utils_SRandom__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/utils/SRandom */ \"./app/utils/SRandom.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst treeBiome = {\r\n    name: 'Tree',\r\n    color: '#080',\r\n    centerColor: '#0B4',\r\n    topEdgeColor: '#640',\r\n    bottomEdgeColor: '#320',\r\n};\r\nconst platformSizes = [200, 350, 500];\r\nfunction createTreeDungeon(state, seed, radius, level) {\r\n    const name = 'Tree';\r\n    const discs = [];\r\n    const entrance = { x: 0, y: 0, radius: 16 };\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_11__[\"default\"].seed(seed);\r\n    const startingPlatform = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.createDisc)({\r\n        level,\r\n        ...treeBiome,\r\n        x: entrance.x,\r\n        y: entrance.y,\r\n        radius: 600,\r\n    });\r\n    (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_10__.addOverworldPortalToDisc)(entrance, startingPlatform);\r\n    discs.push(startingPlatform);\r\n    let finished = false;\r\n    for (let i = 0; i < 100 && (!finished || i < 20); i++) {\r\n        dungeonRandomizer.nextSeed();\r\n        const theta = 2 * Math.PI * dungeonRandomizer.generateAndMutate();\r\n        const newDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.createDisc)({\r\n            level,\r\n            ...treeBiome,\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: dungeonRandomizer.element(platformSizes),\r\n        });\r\n        (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.projectDiscToClosestDisc)(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n        if (newDisc.x * newDisc.x + newDisc.y * newDisc.y >= radius * radius) {\r\n            // Only one disc is allowed to spawn outside of the radius.\r\n            if (!finished) {\r\n                finished = true;\r\n                newDisc.radius = 400;\r\n                (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.projectDiscToClosestDisc)(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n                newDisc.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y, app_bosses_guardian__WEBPACK_IMPORTED_MODULE_0__.guardian, level + 2, newDisc);\r\n                newDisc.boss.isBoss = true;\r\n                discs.push(newDisc);\r\n            }\r\n            continue;\r\n        }\r\n        discs.push(newDisc);\r\n        if (newDisc.radius >= 300 && dungeonRandomizer.generateAndMutate() < 0.6) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_ent__WEBPACK_IMPORTED_MODULE_3__.ent, newDisc.level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_7__.turret, newDisc.level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_lord__WEBPACK_IMPORTED_MODULE_4__.lord, newDisc.level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.1) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_2__.chest, newDisc.level + 1, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x + 80, newDisc.y, app_bosses_spider__WEBPACK_IMPORTED_MODULE_1__.babySpiderBomber, level, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x - 80, newDisc.y, app_enemies_snake__WEBPACK_IMPORTED_MODULE_5__.snake, level, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y + 80, app_enemies_sniper__WEBPACK_IMPORTED_MODULE_6__.sniper, level, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y - 80, app_bosses_spider__WEBPACK_IMPORTED_MODULE_1__.babySpiderNova, level, newDisc);\r\n        }\r\n    }\r\n    (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.linkDiscs)(discs);\r\n    return {\r\n        name,\r\n        level,\r\n        discs,\r\n        entrance,\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/dungeons/tree.ts?");

/***/ }),

/***/ "./app/enchantments.ts":
/*!*****************************!*\
  !*** ./app/enchantments.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyEnchantmentToEquipment: () => (/* binding */ applyEnchantmentToEquipment),\n/* harmony export */   applyEnchantmentToStats: () => (/* binding */ applyEnchantmentToStats),\n/* harmony export */   applyEnchantmentsToStats: () => (/* binding */ applyEnchantmentsToStats),\n/* harmony export */   enchantmentStatLabels: () => (/* binding */ enchantmentStatLabels),\n/* harmony export */   enchantmentStatScale: () => (/* binding */ enchantmentStatScale),\n/* harmony export */   enchantmentStrengthLabels: () => (/* binding */ enchantmentStrengthLabels),\n/* harmony export */   getEnchantmentBonusText: () => (/* binding */ getEnchantmentBonusText),\n/* harmony export */   getEnchantmentPercentValue: () => (/* binding */ getEnchantmentPercentValue),\n/* harmony export */   getEnchantmentStrength: () => (/* binding */ getEnchantmentStrength),\n/* harmony export */   getInsightEnchantment: () => (/* binding */ getInsightEnchantment),\n/* harmony export */   getPowerEnchantment: () => (/* binding */ getPowerEnchantment),\n/* harmony export */   getSpeedEnchantment: () => (/* binding */ getSpeedEnchantment),\n/* harmony export */   getThiefEnchantment: () => (/* binding */ getThiefEnchantment),\n/* harmony export */   getVigorEnchantment: () => (/* binding */ getVigorEnchantment)\n/* harmony export */ });\n/* harmony import */ var app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/uniqueEnchantmentHash */ \"./app/uniqueEnchantmentHash.ts\");\n\r\nconst enchantmentStrengthLabels = [\r\n    'Failed',\r\n    'Weak',\r\n    'Minor',\r\n    'Major',\r\n    'Great',\r\n    'Perfect',\r\n];\r\nconst enchantmentStatLabels = {\r\n    'attackSpeed': 'Attack Speed',\r\n    'critChance': 'Critical Strike Chance',\r\n    'critDamage': 'Critical Strike Damage',\r\n    'damage': 'Damage',\r\n    'dropChance': 'Item Drop Chance',\r\n    'dropLevel': 'Item Drop Level',\r\n    'speed': 'Movement Speed',\r\n    'life': 'Life',\r\n    'armor': 'Armor',\r\n    'potionEffect': 'Effect of Potions',\r\n};\r\nconst enchantmentStatScale = {\r\n    'attackSpeed': 0.5,\r\n    'critChance': 0.2,\r\n    'critDamage': 1.0,\r\n    'damage': 1.0,\r\n    'dropChance': 0.1,\r\n    'dropLevel': 2,\r\n    'speed': 0.3,\r\n    'life': 0.5,\r\n    'armor': 0.5,\r\n    'potionEffect': 1,\r\n};\r\nfunction getEnchantmentStrength(level) {\r\n    if (level >= 80) {\r\n        return 5;\r\n    }\r\n    if (level >= 50) {\r\n        return 4;\r\n    }\r\n    if (level >= 30) {\r\n        return 3;\r\n    }\r\n    if (level >= 15) {\r\n        return 2;\r\n    }\r\n    return 1;\r\n}\r\nfunction applyEnchantmentsToStats(state) {\r\n    var _a, _b;\r\n    for (const enchantment of state.hero.equipment.weapon.enchantmentSlots) {\r\n        applyEnchantmentToStats(state, enchantment);\r\n    }\r\n    for (const enchantment of ((_b = (_a = state.hero.equipment.armor) === null || _a === void 0 ? void 0 : _a.enchantmentSlots) !== null && _b !== void 0 ? _b : [])) {\r\n        applyEnchantmentToStats(state, enchantment);\r\n    }\r\n}\r\nfunction applyEnchantmentToStats(state, enchantment) {\r\n    var _a;\r\n    if (enchantment.enchantmentType === 'empty') {\r\n        return;\r\n    }\r\n    if (enchantment.enchantmentType === 'uniqueArmorEnchantment' || enchantment.enchantmentType === 'uniqueWeaponEnchantment') {\r\n        const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_0__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n        (_a = definition.modifyHero) === null || _a === void 0 ? void 0 : _a.call(definition, state, enchantment);\r\n        return;\r\n    }\r\n    const effect = enchantment.value * enchantmentStatScale[enchantment.enchantmentType] / 100;\r\n    switch (enchantment.enchantmentType) {\r\n        case 'attackSpeed':\r\n            state.hero.attacksPerSecond *= (1 + effect);\r\n            return;\r\n        case 'damage':\r\n            state.hero.damage *= (1 + effect);\r\n            return;\r\n        case 'critChance':\r\n            state.hero.critChance += effect;\r\n            return;\r\n        case 'critDamage':\r\n            state.hero.critDamage += effect;\r\n            return;\r\n        case 'dropChance':\r\n            state.hero.dropChance += effect;\r\n            return;\r\n        case 'dropLevel':\r\n            state.hero.dropLevel += effect;\r\n            return;\r\n        case 'life':\r\n            state.hero.maxLife = Math.round(state.hero.maxLife * (1 + effect));\r\n            return;\r\n        case 'armor':\r\n            state.hero.armor = Math.round(state.hero.armor * (1 + effect));\r\n            return;\r\n        case 'speed':\r\n            state.hero.speed *= (1 + effect);\r\n            return;\r\n        case 'potionEffect':\r\n            state.hero.potionEffect *= (1 + effect);\r\n            return;\r\n    }\r\n}\r\nfunction getEnchantmentPercentValue(enchantmentType, value) {\r\n    return Math.floor(value * enchantmentStatScale[enchantmentType]) + '%';\r\n}\r\nfunction getEnchantmentBonusText(enchantmentType, value, value2) {\r\n    let text = getEnchantmentPercentValue(enchantmentType, value);\r\n    if (value2) {\r\n        text += ' to ' + getEnchantmentPercentValue(enchantmentType, value2);\r\n    }\r\n    if (enchantmentType === 'dropLevel') {\r\n        text += ' chance to drop higher level items';\r\n    }\r\n    else {\r\n        text += ' increased ' + enchantmentStatLabels[enchantmentType];\r\n    }\r\n    return [text];\r\n}\r\nfunction applyEnchantmentToEquipment(enchantment, item) {\r\n    const enchantmentType = item.type === 'weapon'\r\n        ? enchantment.weaponEnchantmentType\r\n        : enchantment.armorEnchantmentType;\r\n    for (const slot of item.enchantmentSlots) {\r\n        if (slot.enchantmentType === 'empty') {\r\n            slot.enchantmentType = enchantmentType;\r\n            slot.value = 10 * enchantment.strength;\r\n            return true;\r\n        }\r\n        if (slot.enchantmentType === enchantmentType) {\r\n            if (slot.value < 10 * enchantment.strength) {\r\n                slot.value = 10 * enchantment.strength;\r\n                return true;\r\n            }\r\n            else if (slot.value < 20 * enchantment.strength) {\r\n                slot.value = Math.min(slot.value + enchantment.strength, 20 * enchantment.strength);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction getSpeedEnchantment(state, level) {\r\n    return {\r\n        type: 'enchantment',\r\n        name: 'Speed',\r\n        level: applyBonusLevel(state, level),\r\n        weaponEnchantmentType: 'attackSpeed',\r\n        armorEnchantmentType: 'speed',\r\n        strength: getEnchantmentStrength(level),\r\n    };\r\n}\r\nfunction getPowerEnchantment(state, level) {\r\n    return {\r\n        type: 'enchantment',\r\n        name: 'Power',\r\n        level: applyBonusLevel(state, level),\r\n        weaponEnchantmentType: 'damage',\r\n        armorEnchantmentType: 'armor',\r\n        strength: getEnchantmentStrength(level),\r\n    };\r\n}\r\nfunction getVigorEnchantment(state, level) {\r\n    return {\r\n        type: 'enchantment',\r\n        name: 'Vigor',\r\n        level: applyBonusLevel(state, level),\r\n        weaponEnchantmentType: 'critDamage',\r\n        armorEnchantmentType: 'life',\r\n        strength: getEnchantmentStrength(level),\r\n    };\r\n}\r\nfunction getInsightEnchantment(state, level) {\r\n    return {\r\n        type: 'enchantment',\r\n        name: 'Insight',\r\n        level: applyBonusLevel(state, level),\r\n        weaponEnchantmentType: 'critChance',\r\n        armorEnchantmentType: 'potionEffect',\r\n        strength: getEnchantmentStrength(level),\r\n    };\r\n}\r\nfunction getThiefEnchantment(state, level) {\r\n    return {\r\n        type: 'enchantment',\r\n        name: 'Thief',\r\n        level: applyBonusLevel(state, level),\r\n        weaponEnchantmentType: 'dropLevel',\r\n        armorEnchantmentType: 'dropChance',\r\n        strength: getEnchantmentStrength(level),\r\n    };\r\n}\r\nfunction applyBonusLevel(state, level) {\r\n    let bonusLevelChance = state.hero.dropChance;\r\n    while (Math.random() < bonusLevelChance) {\r\n        level++;\r\n        bonusLevelChance--;\r\n    }\r\n    return Math.min(100, level);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/enchantments.ts?");

/***/ }),

/***/ "./app/enemies/bandit.ts":
/*!*******************************!*\
  !*** ./app/enemies/bandit.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bandit: () => (/* binding */ bandit)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n\r\n\r\n\r\n\r\nconst handModes = ['spin', 'spin', 'spin', 'swipe', 'swipe', 'target'];\r\nfunction setHandMode(hand, mode) {\r\n    hand.mode = mode;\r\n    hand.modeTime = 0;\r\n}\r\nfunction attackOnCooldown(state, enemy, hand, attack) {\r\n    if (hand.cooldownTime <= 0) {\r\n        hand.cooldownTime = 1000 / enemy.attacksPerSecond;\r\n        attack();\r\n    }\r\n}\r\nfunction renderKnife(context, state, enemy, x, y, hand) {\r\n    context.save();\r\n    context.translate(x, y);\r\n    context.rotate(hand.theta);\r\n    context.beginPath();\r\n    context.lineWidth = 8;\r\n    context.strokeStyle = context.fillStyle = enemy.baseColor;\r\n    context.moveTo(-60, 0);\r\n    context.lineTo(80, 0);\r\n    ;\r\n    context.moveTo(-20, -40);\r\n    context.lineTo(-20, 40);\r\n    ;\r\n    context.stroke();\r\n    context.beginPath();\r\n    context.moveTo(-20, -20);\r\n    context.lineTo(75, 0);\r\n    ;\r\n    context.lineTo(-20, 20);\r\n    context.fill();\r\n    context.restore();\r\n}\r\nconst bandit = {\r\n    name: 'Bandit',\r\n    statFactors: {\r\n        attacksPerSecond: 10,\r\n        maxLife: 0.75,\r\n        armor: 0.75,\r\n        damage: 0.75,\r\n        speed: 1.5,\r\n    },\r\n    initialParams: {\r\n        leftHand: {\r\n            mode: 'wait',\r\n            modeTime: 0,\r\n            theta: -Math.PI / 4,\r\n            cooldownTime: 0,\r\n        },\r\n        rightHand: {\r\n            mode: 'wait',\r\n            modeTime: 0,\r\n            theta: -Math.PI / 4,\r\n            cooldownTime: 0,\r\n        },\r\n    },\r\n    radius: 24,\r\n    initialize(state, enemy) {\r\n        enemy.params.leftHand = {\r\n            mode: 'wait',\r\n            modeTime: 0,\r\n            theta: -Math.PI / 4,\r\n            cooldownTime: 0,\r\n        };\r\n        enemy.params.rightHand = {\r\n            mode: 'wait',\r\n            modeTime: 0,\r\n            theta: -Math.PI / 4,\r\n            cooldownTime: 0,\r\n        };\r\n    },\r\n    update(state, enemy) {\r\n        const chaseRadius = 500;\r\n        const attackRadius = 200;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 <= attackRadius * attackRadius) {\r\n            if (enemy.mode !== 'attack' && enemy.modeTime >= 200) {\r\n                enemy.setMode('attack');\r\n            }\r\n        }\r\n        else if (distance2 <= chaseRadius * chaseRadius) {\r\n            if (enemy.mode !== 'chase' && enemy.modeTime >= 200) {\r\n                enemy.setMode('chase');\r\n                enemy.speed = 2 * window.BASE_ENEMY_SPEED;\r\n            }\r\n        }\r\n        else {\r\n            if (enemy.mode !== 'wait' && enemy.modeTime >= 200) {\r\n                enemy.setMode('wait');\r\n            }\r\n        }\r\n        const { leftHand, rightHand } = enemy.params;\r\n        if (enemy.mode === 'chase' && leftHand.mode === 'wait' && rightHand.mode === 'wait') {\r\n            enemy.speed = Math.max(window.BASE_ENEMY_SPEED, enemy.speed * 0.99);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyToTargetWithoutTurning)(state, enemy, state.hero);\r\n        }\r\n        if (enemy.mode === 'attack' && enemy.modeTime % 4000 === 20) {\r\n            setHandMode(enemy.params.leftHand, app_utils_Random__WEBPACK_IMPORTED_MODULE_3__[\"default\"].element(handModes));\r\n        }\r\n        else if (leftHand.modeTime >= 3000) {\r\n            setHandMode(enemy.params.leftHand, 'wait');\r\n        }\r\n        // Right hand always acts 500ms after left hand.\r\n        if (leftHand.mode !== 'wait' && leftHand.modeTime === 500) {\r\n            setHandMode(enemy.params.rightHand, app_utils_Random__WEBPACK_IMPORTED_MODULE_3__[\"default\"].element(handModes));\r\n        }\r\n        else if (rightHand.modeTime >= 3000) {\r\n            setHandMode(enemy.params.rightHand, 'wait');\r\n        }\r\n        leftHand.modeTime += window.FRAME_LENGTH;\r\n        rightHand.modeTime += window.FRAME_LENGTH;\r\n        if (leftHand.cooldownTime > 0) {\r\n            leftHand.cooldownTime -= window.FRAME_LENGTH;\r\n        }\r\n        if (rightHand.cooldownTime > 0) {\r\n            rightHand.cooldownTime -= window.FRAME_LENGTH;\r\n        }\r\n        if (leftHand.mode === 'spin') {\r\n            if (leftHand.modeTime <= 500) {\r\n                leftHand.theta -= 2 * Math.PI / 500 * window.FRAME_LENGTH;\r\n            }\r\n            else if (leftHand.modeTime >= 1000 && leftHand.modeTime <= 3000) {\r\n                leftHand.theta -= 2 * Math.PI / 1000 * window.FRAME_LENGTH;\r\n                attackOnCooldown(state, enemy, leftHand, () => {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletInDirection)(state, enemy, leftHand.theta, window.BASE_ENEMY_BULLET_SPEED);\r\n                });\r\n            }\r\n        }\r\n        else if (leftHand.mode === 'target') {\r\n            const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, {\r\n                x: state.hero.x,\r\n                y: state.hero.y\r\n            });\r\n            leftHand.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.turnTowardsAngle)(leftHand.theta, 0.1, Math.atan2(y, x));\r\n            if (leftHand.modeTime >= 1000 && leftHand.modeTime <= 3000) {\r\n                //const p = (leftHand.modeTime - 1000) % 500 / 500;\r\n                attackOnCooldown(state, enemy, leftHand, () => {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletInDirection)(state, enemy, leftHand.theta - Math.PI / 3 * Math.random(), window.BASE_ENEMY_BULLET_SPEED);\r\n                });\r\n            }\r\n        }\r\n        else if (leftHand.mode === 'swipe') {\r\n            if (leftHand.modeTime <= 500) {\r\n                const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, {\r\n                    x: state.hero.x,\r\n                    y: state.hero.y,\r\n                });\r\n                leftHand.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.turnTowardsAngle)(leftHand.theta, 0.1, Math.atan2(y, x) + Math.PI / 3);\r\n            }\r\n            if (leftHand.modeTime >= 1000 && leftHand.modeTime <= 1400) {\r\n                leftHand.theta -= 2 * Math.PI / 3 / 400 * window.FRAME_LENGTH;\r\n                attackOnCooldown(state, enemy, leftHand, () => {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletInDirection)(state, enemy, leftHand.theta, 1.5 * window.BASE_ENEMY_BULLET_SPEED);\r\n                });\r\n            }\r\n            if (leftHand.modeTime >= 2400 && leftHand.modeTime <= 2800) {\r\n                leftHand.theta += 2 * Math.PI / 3 / 400 * window.FRAME_LENGTH;\r\n                attackOnCooldown(state, enemy, leftHand, () => {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletInDirection)(state, enemy, leftHand.theta, 1.5 * window.BASE_ENEMY_BULLET_SPEED);\r\n                });\r\n            }\r\n        }\r\n        if (rightHand.mode === 'spin') {\r\n            if (rightHand.modeTime <= 500) {\r\n                rightHand.theta += 2 * Math.PI / 500 * window.FRAME_LENGTH;\r\n            }\r\n            else if (rightHand.modeTime >= 1000 && rightHand.modeTime <= 3000) {\r\n                rightHand.theta += 2 * Math.PI / 1000 * window.FRAME_LENGTH;\r\n                attackOnCooldown(state, enemy, rightHand, () => {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletInDirection)(state, enemy, rightHand.theta, window.BASE_ENEMY_BULLET_SPEED);\r\n                });\r\n            }\r\n        }\r\n        else if (rightHand.mode === 'target') {\r\n            const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, {\r\n                x: state.hero.x,\r\n                y: state.hero.y\r\n            });\r\n            rightHand.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.turnTowardsAngle)(rightHand.theta, 0.1, Math.atan2(y, x));\r\n            if (rightHand.modeTime >= 1000 && rightHand.modeTime <= 3000) {\r\n                //const p = (rightHand.modeTime - 1000) % 500 / 500;\r\n                attackOnCooldown(state, enemy, rightHand, () => {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletInDirection)(state, enemy, rightHand.theta + Math.PI / 3 * Math.random(), window.BASE_ENEMY_BULLET_SPEED);\r\n                });\r\n            }\r\n        }\r\n        else if (rightHand.mode === 'swipe') {\r\n            if (rightHand.modeTime <= 500) {\r\n                const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, {\r\n                    x: state.hero.x,\r\n                    y: state.hero.y,\r\n                });\r\n                rightHand.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.turnTowardsAngle)(rightHand.theta, 0.1, Math.atan2(y, x) - Math.PI / 3);\r\n            }\r\n            if (rightHand.modeTime >= 1000 && rightHand.modeTime <= 1400) {\r\n                rightHand.theta += 2 * Math.PI / 3 / 400 * window.FRAME_LENGTH;\r\n                attackOnCooldown(state, enemy, rightHand, () => {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletInDirection)(state, enemy, rightHand.theta, 1.5 * window.BASE_ENEMY_BULLET_SPEED);\r\n                });\r\n            }\r\n            if (rightHand.modeTime >= 2400 && rightHand.modeTime <= 2800) {\r\n                rightHand.theta -= 2 * Math.PI / 3 / 400 * window.FRAME_LENGTH;\r\n                attackOnCooldown(state, enemy, rightHand, () => {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletInDirection)(state, enemy, rightHand.theta, 1.5 * window.BASE_ENEMY_BULLET_SPEED);\r\n                });\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n        renderKnife(context, state, enemy, -20, -20, enemy.params.leftHand);\r\n        renderKnife(context, state, enemy, 20, 20, enemy.params.rightHand);\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/bandit.ts?");

/***/ }),

/***/ "./app/enemies/bat.ts":
/*!****************************!*\
  !*** ./app/enemies/bat.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bat: () => (/* binding */ bat)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nfunction updateSonarBullet(state, bullet) {\r\n    const amplitude = Math.min(50, bullet.time / 30);\r\n    if (bullet.amplitude < 0) {\r\n        bullet.amplitude = -amplitude;\r\n    }\r\n    else {\r\n        bullet.amplitude = amplitude;\r\n    }\r\n    (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateSimpleBullet)(state, bullet);\r\n}\r\nconst bat = {\r\n    name: 'Bat',\r\n    statFactors: {\r\n        armor: 2,\r\n        damage: 0.75,\r\n        speed: 0.3,\r\n    },\r\n    initialParams: {},\r\n    radius: 24,\r\n    portalChance: 0.05,\r\n    portalDungeonType: 'cave',\r\n    update(state, enemy) {\r\n        const aggroRadius = 300;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        const isAggro = distance2 <= aggroRadius * aggroRadius;\r\n        if (isAggro) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.turnTowardsTarget)(state, enemy, state.hero);\r\n            // Try to stay a certain distance from the player.\r\n            if (distance2 <= 190 * 190) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, Math.atan2(y, x) + Math.PI);\r\n            }\r\n            else if (distance2 >= 210 * 210) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, Math.atan2(y, x));\r\n            }\r\n        }\r\n        else {\r\n            if (enemy.mode === 'choose') {\r\n                if (enemy.modeTime >= 200) {\r\n                    enemy.theta = Math.random() * 2 * Math.PI;\r\n                    enemy.setMode('move');\r\n                }\r\n            }\r\n            else if (enemy.mode === 'move') {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy);\r\n                if (enemy.modeTime >= 600) {\r\n                    enemy.setMode('choose');\r\n                }\r\n            }\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            if (isAggro) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 0.6 * window.BASE_ENEMY_BULLET_SPEED * Math.cos(enemy.theta), 0.6 * window.BASE_ENEMY_BULLET_SPEED * Math.sin(enemy.theta), {\r\n                    duration: 2000, amplitude: 10, frequency: 6,\r\n                    update: updateSonarBullet,\r\n                });\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 0.6 * window.BASE_ENEMY_BULLET_SPEED * Math.cos(enemy.theta), 0.6 * window.BASE_ENEMY_BULLET_SPEED * Math.sin(enemy.theta), {\r\n                    duration: 2000, amplitude: -10, frequency: 6,\r\n                    update: updateSonarBullet,\r\n                });\r\n            }\r\n            else {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 1.2 * window.BASE_ENEMY_BULLET_SPEED, { amplitude: 20, frequency: 5 });\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 1.2 * window.BASE_ENEMY_BULLET_SPEED, { amplitude: -20, frequency: 5 });\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x + 0.25 * enemy.radius * Math.cos(enemy.theta),\r\n            y: enemy.y + 0.25 * enemy.radius * Math.sin(enemy.theta),\r\n            radius: enemy.radius / 5,\r\n        }, enemy.baseColor);\r\n        context.save();\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.translate(enemy.x, enemy.y);\r\n        context.rotate(enemy.theta);\r\n        // left wing\r\n        context.moveTo(enemy.radius / 4, 0);\r\n        context.arcTo(enemy.radius / 4, enemy.radius, enemy.radius * Math.cos(Math.PI / 6), enemy.radius * Math.sin(Math.PI / 6), enemy.radius / 2);\r\n        context.arc(0, 0, enemy.radius, Math.PI / 6, 2 * Math.PI / 3);\r\n        //context.lineTo(enemy.radius * Math.cos(4 * Math.PI / 3), enemy.radius * Math.sin(4 * Math.PI / 3))\r\n        // Bottom arcs\r\n        context.lineTo(-enemy.radius / 4, enemy.radius / 2);\r\n        context.lineTo(enemy.radius / 2 * Math.cos(5 * Math.PI / 6), enemy.radius / 2 * Math.sin(5 * Math.PI / 6));\r\n        context.lineTo(-enemy.radius / 4, 0);\r\n        context.lineTo(enemy.radius / 2 * Math.cos(7 * Math.PI / 6), enemy.radius / 2 * Math.sin(7 * Math.PI / 6));\r\n        context.lineTo(-enemy.radius / 4, -enemy.radius / 2);\r\n        context.lineTo(enemy.radius / 2 * Math.cos(4 * Math.PI / 3), enemy.radius / 2 * Math.sin(4 * Math.PI / 3));\r\n        // This seems like it should work, but it looks terrible for some reason\r\n        /*context.arcTo(\r\n            -enemy.radius / 4, enemy.radius / 2,\r\n            enemy.radius / 2 * Math.cos(5 * Math.PI / 6), enemy.radius / 2 * Math.sin(5 * Math.PI / 6),\r\n            enemy.radius / 6\r\n        );\r\n        context.arcTo(\r\n            -enemy.radius / 4, 0,\r\n            enemy.radius / 2 * Math.cos(7 * Math.PI / 6), enemy.radius / 2 * Math.sin(7 * Math.PI / 6),\r\n            enemy.radius / 6\r\n        );\r\n        context.arcTo(\r\n            -enemy.radius / 4, -enemy.radius / 2,\r\n            enemy.radius / 2 * Math.cos(4 * Math.PI / 3), enemy.radius / 2 * Math.sin(4 * Math.PI / 3),\r\n            enemy.radius / 6\r\n        );*/\r\n        // right wing\r\n        context.arc(0, 0, enemy.radius, 4 * Math.PI / 3, 11 * Math.PI / 6);\r\n        context.arcTo(enemy.radius / 4, -enemy.radius, enemy.radius / 4, 0, enemy.radius / 2);\r\n        context.fill();\r\n        context.restore();\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/bat.ts?");

/***/ }),

/***/ "./app/enemies/chest.ts":
/*!******************************!*\
  !*** ./app/enemies/chest.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chest: () => (/* binding */ chest)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n\r\nconst chest = {\r\n    name: 'Chest',\r\n    statFactors: {},\r\n    initialParams: {},\r\n    dropChance: 1,\r\n    uniqueMultiplier: 5,\r\n    experienceFactor: 0,\r\n    radius: 24,\r\n    update(state, enemy) {\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { ...enemy, radius: 20 }, 'pink');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { ...enemy, radius: 6 }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/chest.ts?");

/***/ }),

/***/ "./app/enemies/clam.ts":
/*!*****************************!*\
  !*** ./app/enemies/clam.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clam: () => (/* binding */ clam),\n/* harmony export */   giantClam: () => (/* binding */ giantClam)\n/* harmony export */ });\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n\r\n\r\n\r\nconst clam = {\r\n    name: 'Clam',\r\n    statFactors: {\r\n        attacksPerSecond: 1.25,\r\n        damage: 0.8,\r\n        maxLife: 2,\r\n        armor: 5,\r\n    },\r\n    initialParams: { shotIndex: 0 },\r\n    dropChance: 2 * window.BASE_DROP_CHANCE,\r\n    uniqueMultiplier: 2,\r\n    experienceFactor: 2,\r\n    radius: 32,\r\n    portalChance: 0.2,\r\n    portalDungeonType: 'reef',\r\n    update(state, enemy) {\r\n        if (enemy.mode === 'closed' || enemy.mode === 'choose') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.turnTowardsTarget)(state, enemy, state.hero);\r\n            enemy.mode = 'closed';\r\n            enemy.armor = enemy.baseArmor * 10;\r\n            return;\r\n        }\r\n        else {\r\n            enemy.armor = enemy.baseArmor / 10;\r\n        }\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.turnTowardsTarget)(state, enemy, state.hero, 0.1);\r\n        if (enemy.mode === 'opening') {\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 1.2 * window.BASE_ENEMY_BULLET_SPEED, { damage: 1.5 * enemy.damage, radius: 1.5 * window.BASE_ENEMY_BULLET_RADIUS });\r\n            }\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('open');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'closing') {\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('closed');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, enemy.theta, Math.PI, 6 + (enemy.params.shotIndex % 2), window.BASE_ENEMY_BULLET_SPEED);\r\n            enemy.params.shotIndex++;\r\n        }\r\n        if (enemy.modeTime >= 3000) {\r\n            enemy.setMode('closing');\r\n        }\r\n    },\r\n    onDamage(state, enemy) {\r\n        if (enemy.mode === 'closed' && enemy.modeTime >= 500) {\r\n            enemy.setMode('opening');\r\n        }\r\n    },\r\n    render: renderClam,\r\n};\r\nconst giantClam = {\r\n    ...clam,\r\n    name: 'Giant Clam',\r\n    statFactors: {\r\n        attacksPerSecond: 1,\r\n        damage: 0.8,\r\n        maxLife: 0.75 * window.BOSS_MAX_LIFE_FACTOR,\r\n        armor: 4,\r\n    },\r\n    dropChance: 1,\r\n    uniqueMultiplier: 20,\r\n    experienceFactor: 20,\r\n    radius: 50,\r\n    portalChance: 0,\r\n    update(state, enemy) {\r\n        // Constantly shoots small novas to hurt players that get too close.\r\n        if (state.fieldTime % 200 === 0) {\r\n            const healthPercentage = (enemy.maxLife - enemy.life) / enemy.maxLife;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootCirclingBullet)(state, enemy, 0, enemy.radius + 5 * Math.floor(healthPercentage * 10));\r\n            //const even = (state.fieldTime % 1000) === 0;\r\n            //shootBulletCircle(state, enemy, even ? 0 : Math.PI / 20, 20, 40, {duration: 600});\r\n        }\r\n        if (enemy.mode === 'closed' || enemy.mode === 'choose') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.turnTowardsTarget)(state, enemy, state.hero);\r\n            enemy.mode = 'closed';\r\n            enemy.armor = enemy.baseArmor * 10;\r\n            return;\r\n        }\r\n        else {\r\n            enemy.armor = enemy.baseArmor / 10;\r\n        }\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.turnTowardsTarget)(state, enemy, state.hero, 0.1);\r\n        if (enemy.mode === 'opening') {\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, enemy.theta, Math.PI / 3, 3, 1.2 * window.BASE_ENEMY_BULLET_SPEED, { radius: 1.5 * window.BASE_ENEMY_BULLET_RADIUS, damage: 1.5 * enemy.damage });\r\n            }\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('open');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'closing') {\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('closed');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.life <= enemy.maxLife / 2) {\r\n            if (state.fieldTime % 200 === 0) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 1.2 * window.BASE_ENEMY_BULLET_SPEED, { damage: 1.5 * enemy.damage, radius: 1.5 * window.BASE_ENEMY_BULLET_RADIUS });\r\n            }\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, enemy.theta, Math.PI, 6 + (enemy.params.shotIndex % 4), window.BASE_ENEMY_BULLET_SPEED, { duration: 2000 });\r\n            enemy.params.shotIndex++;\r\n        }\r\n        if (enemy.modeTime >= 4000) {\r\n            enemy.setMode('closing');\r\n        }\r\n    },\r\n    getEnchantment(state, enemy) {\r\n        return (0,app_enchantments__WEBPACK_IMPORTED_MODULE_0__.getPowerEnchantment)(state, enemy.level);\r\n    },\r\n};\r\nfunction renderClamArc(context, r, p) {\r\n    context.beginPath();\r\n    context.strokeStyle = 'black';\r\n    context.moveTo(0, r);\r\n    if (p === 0.5) {\r\n        context.lineTo(0, -r);\r\n        context.stroke();\r\n        return;\r\n    }\r\n    let sign = 1;\r\n    if (p > 0.5) {\r\n        p = (p - 0.5) * 2;\r\n    }\r\n    else {\r\n        p = (0.5 - p) * 2;\r\n        sign = -1;\r\n    }\r\n    const steps = 10;\r\n    for (let i = 1; i <= steps; i++) {\r\n        const y = r * Math.cos(Math.PI * i / steps); //r - 2 * r * i / steps;\r\n        const x = Math.sqrt(r * r - y * y) * p * sign;\r\n        context.lineTo(x, y);\r\n    }\r\n    context.stroke();\r\n}\r\nfunction renderClam(context, state, enemy) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'black');\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { ...enemy, radius: 5 }, enemy.baseColor);\r\n    context.save();\r\n    context.translate(enemy.x, enemy.y);\r\n    context.rotate(enemy.theta);\r\n    context.fillStyle = enemy.baseColor;\r\n    context.lineWidth = 1;\r\n    context.strokeStyle = 'black';\r\n    if (enemy.mode === 'opening' || enemy.mode === 'closing') {\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.arc(0, 0, enemy.radius, Math.PI / 2, 3 * Math.PI / 2);\r\n        if ((enemy.modeTime >= 200 && enemy.mode === 'closing') || (enemy.modeTime <= 200 && enemy.mode === 'opening')) {\r\n            // 3/4 closed\r\n            context.arc(-enemy.radius, 0, Math.sqrt(2) * enemy.radius, 5 * Math.PI / 3, 1 * Math.PI / 3, false);\r\n            context.fill();\r\n            for (let i = 1; i < 6; i++) {\r\n                renderClamArc(context, enemy.radius, 2 * i / 6 / 3);\r\n            }\r\n        }\r\n        else {\r\n            // 1/2 closed\r\n            context.lineTo(0, -enemy.radius);\r\n            context.fill();\r\n            for (let i = 1; i < 6; i++) {\r\n                renderClamArc(context, enemy.radius, i / 6 / 2);\r\n            }\r\n        }\r\n    }\r\n    else if (enemy.mode === 'open') {\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.arc(0, 0, enemy.radius, Math.PI / 2, 3 * Math.PI / 2);\r\n        context.arc(enemy.radius, 0, Math.sqrt(2) * enemy.radius, 4 * Math.PI / 3, 2 * Math.PI / 3, true);\r\n        context.fill();\r\n        for (let i = 1; i < 6; i++) {\r\n            renderClamArc(context, enemy.radius, i / 6 / 3);\r\n        }\r\n    }\r\n    else {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { ...enemy, x: 0, y: 0 }, enemy.baseColor);\r\n        for (let i = 1; i < 6; i++) {\r\n            renderClamArc(context, enemy.radius, i / 6);\r\n        }\r\n    }\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, { x: 0, y: 0, radius: enemy.radius }, undefined, 'black');\r\n    context.restore();\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/clam.ts?");

/***/ }),

/***/ "./app/enemies/crab.ts":
/*!*****************************!*\
  !*** ./app/enemies/crab.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crab: () => (/* binding */ crab)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n\r\n\r\n\r\n\r\nconst crab = {\r\n    name: 'Crab',\r\n    statFactors: {\r\n        attacksPerSecond: 1,\r\n    },\r\n    initialParams: {},\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        enemy.theta = Math.PI / 2;\r\n        const aggroRadius = 400;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        const isAggro = distance2 <= aggroRadius * aggroRadius;\r\n        if (enemy.mode === 'choose') {\r\n            enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_3__[\"default\"].element(['moveLeft', 'moveRight', 'pause', 'pause']));\r\n            /*if (isAggro) {\r\n                if (y < 30) {\r\n                    enemy.setMode('moveUp');\r\n                } else {\r\n                    enemy.setMode(Random.element(['moveLeft', 'moveRight', 'pause']));\r\n                }\r\n            } else {\r\n                enemy.setMode(Random.element(['moveUp', 'moveDown', 'moveLeft', 'moveRight', 'pause', 'pause']));\r\n            }*/\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveUp') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInDirection)(state, enemy, -Math.PI / 2, enemy.speed / 2);\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('choose');\r\n            }\r\n            if (isAggro && enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletAtHero)(state, enemy, window.BASE_ENEMY_BULLET_SPEED, { radius: 1.5 * window.BASE_ENEMY_BULLET_RADIUS, damage: 2 * enemy.damage });\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveDown') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInDirection)(state, enemy, Math.PI / 2, enemy.speed / 2);\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveLeft') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInDirection)(state, enemy, Math.PI, 1.1 * enemy.speed);\r\n            if (enemy.x < enemy.disc.x && (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.isEnemyOffDisc)(state, enemy)) {\r\n                enemy.mode = 'moveRight';\r\n            }\r\n        }\r\n        if (enemy.mode === 'moveRight') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInDirection)(state, enemy, 0, 1.1 * enemy.speed);\r\n            if (enemy.x > enemy.disc.x && (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.isEnemyOffDisc)(state, enemy)) {\r\n                enemy.mode = 'moveLeft';\r\n            }\r\n        }\r\n        if (enemy.mode === 'pause') {\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n        if (enemy.modeTime % 1500 === 0) {\r\n            const duration = 500;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletArc)(state, enemy, 0, Math.PI / 8, 3, enemy.mode === 'moveRight' ? 1.5 * window.BASE_ENEMY_BULLET_SPEED : window.BASE_ENEMY_BULLET_SPEED, { duration });\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletArc)(state, enemy, Math.PI, Math.PI / 8, 3, enemy.mode === 'moveLeft' ? 1.5 * window.BASE_ENEMY_BULLET_SPEED : window.BASE_ENEMY_BULLET_SPEED, { duration });\r\n        }\r\n        if (isAggro && enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            //shootEnemyBullet(state, enemy, 100, 0);\r\n            //shootEnemyBullet(state, enemy, -100, 0);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletAtHero)(state, enemy, window.BASE_ENEMY_BULLET_SPEED, { radius: 1.5 * window.BASE_ENEMY_BULLET_RADIUS, damage: 2 * enemy.damage, duration: 2000 });\r\n        }\r\n        if (enemy.modeTime >= 1000) {\r\n            enemy.setMode('choose');\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, enemy.baseColor);\r\n        context.strokeStyle = 'black';\r\n        context.fillStyle = 'black';\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 30 }, 'black');\r\n        context.beginPath();\r\n        context.lineWidth = 10;\r\n        const frame = ((enemy.time / 200) | 0) % 2;\r\n        const clawTheta = frame ? Math.PI / 12 : -Math.PI / 12;\r\n        const legDelta = frame ? 10 : -10;\r\n        context.moveTo(-25, 50);\r\n        context.lineTo(-50, 120);\r\n        context.moveTo(10, 40);\r\n        context.lineTo(-10, 100 + legDelta);\r\n        context.lineTo(20, 140 + legDelta);\r\n        context.moveTo(30, 30);\r\n        context.lineTo(20, 80 - legDelta);\r\n        context.lineTo(50, 110 - legDelta);\r\n        context.moveTo(-25, -50);\r\n        context.lineTo(-50, -120);\r\n        context.moveTo(10, -40);\r\n        context.lineTo(-10, -100 + legDelta);\r\n        context.lineTo(20, -140 + legDelta);\r\n        context.moveTo(30, -30);\r\n        context.lineTo(20, -80 - legDelta);\r\n        context.lineTo(50, -110 - legDelta);\r\n        context.stroke();\r\n        context.beginPath();\r\n        context.arc(-50, 120, 25, -Math.PI - clawTheta, Math.PI / 2 + clawTheta);\r\n        context.lineTo(-50, 120);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.arc(-50, -120, 25, -Math.PI / 2 + clawTheta, Math.PI - clawTheta);\r\n        context.lineTo(-50, -120);\r\n        context.fill();\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/crab.ts?");

/***/ }),

/***/ "./app/enemies/dragon.ts":
/*!*******************************!*\
  !*** ./app/enemies/dragon.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   swampDragon: () => (/* binding */ swampDragon)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_disc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/disc */ \"./app/utils/disc.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst swampDragon = {\r\n    name: 'Swamp Dragon',\r\n    statFactors: {\r\n        maxLife: 2,\r\n        armor: 1.5,\r\n        speed: 1.5,\r\n    },\r\n    dropChance: 2 * window.BASE_DROP_CHANCE,\r\n    uniqueMultiplier: 2,\r\n    experienceFactor: 2,\r\n    initialParams: {},\r\n    radius: 36,\r\n    update(state, enemy) {\r\n        if (enemy.mode === 'choose') {\r\n            if (enemy.disc !== state.hero.disc) {\r\n                // There is a bug where sometimes adjacent discs are not connected,\r\n                // so we manually check if this disc is touching the hero's disc as a workaround.\r\n                if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.doCirclesIntersect)(enemy.disc, state.hero.disc)) {\r\n                    enemy.params.nextDisc = state.hero.disc;\r\n                }\r\n                else {\r\n                    enemy.params.nextDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_1__.findClosestDiscToDisc)(state.hero.disc, enemy.disc.links);\r\n                }\r\n                enemy.setMode('chase');\r\n                return;\r\n            }\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy.disc, state.hero);\r\n            if (distance2 <= (enemy.disc.radius / 2) ** 2) {\r\n                enemy.setMode('circle');\r\n            }\r\n            else {\r\n                enemy.setMode('moveToCenter');\r\n            }\r\n        }\r\n        if (enemy.mode === 'chase') {\r\n            if (!enemy.params.nextDisc) {\r\n                enemy.setMode('choose');\r\n                return;\r\n            }\r\n            if (enemy.disc === enemy.params.nextDisc) {\r\n                enemy.setMode('choose');\r\n            }\r\n            else {\r\n                const disc = enemy.disc, nextDisc = enemy.params.nextDisc;\r\n                if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.doCirclesIntersect)(enemy, nextDisc)) {\r\n                    // Move to the center of the next disc until assigned to this disc.\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyToTargetWithoutTurning)(state, enemy, nextDisc);\r\n                }\r\n                else {\r\n                    // Move to the connecting point between the current and next disc.\r\n                    // The denominator here should technically be the distance between discs.\r\n                    const p = disc.radius / (disc.radius + nextDisc.radius);\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyToTargetWithoutTurning)(state, enemy, {\r\n                        x: disc.x + p * (nextDisc.x - disc.x),\r\n                        y: disc.y + p * (nextDisc.y - disc.y),\r\n                    });\r\n                }\r\n            }\r\n            // This probably won't happen, but just in case, switch back to choose to try\r\n            // and get unstuck.\r\n            if (enemy.modeTime >= 5000) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n        if (enemy.mode === 'moveToCenter') {\r\n            if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyToTargetWithoutTurning)(state, enemy, enemy.disc)) {\r\n                enemy.setMode('centerAttack');\r\n            }\r\n        }\r\n        if (enemy.mode === 'circle') {\r\n            const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n            const discTheta = Math.atan2(y, x);\r\n            if (distance2 > (0.75 * enemy.disc.radius) ** 2) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, discTheta + Math.PI / 3, enemy.speed);\r\n            }\r\n            else if (distance2 < (0.5 * enemy.disc.radius) ** 2) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, discTheta + 2 * Math.PI / 3, enemy.speed);\r\n            }\r\n            else {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, discTheta + Math.PI / 2, enemy.speed);\r\n            }\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                //shootBulletArc(state, enemy, discTheta, Math.PI / 3, 3, 0.5 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                //    duration: 2000,\r\n                //});\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, discTheta, 2 * Math.PI / 3, 3, 2 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                    warningTime: 1500,\r\n                    duration: 1500,\r\n                    friction: 0.8,\r\n                    radius: 1 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                    onDeath(state, bullet) {\r\n                        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 6, 0.5 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                            baseX: bullet.x,\r\n                            baseY: bullet.y,\r\n                            x: bullet.x,\r\n                            y: bullet.y,\r\n                            duration: 3000,\r\n                        });\r\n                    },\r\n                });\r\n            }\r\n            if (enemy.disc !== state.hero.disc && enemy.modeTime >= 2000) {\r\n                enemy.setMode('chase');\r\n            }\r\n            else if (enemy.modeTime >= 5000) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n        if (enemy.mode === 'centerAttack') {\r\n            /* if (enemy.modeTime % 500 === 0) {\r\n                 shootBulletCircle(state, enemy, Math.random() * 2 * Math.PI, 10, 0.5 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                     duration: 3000,\r\n                 });\r\n             }*/\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHeroHeading)(state, enemy, 2 * window.BASE_ENEMY_BULLET_SPEED, 0.2, {\r\n                    warningTime: 1500,\r\n                    duration: 1500,\r\n                    friction: 0.8,\r\n                    radius: 1.5 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                    onDeath(state, bullet) {\r\n                        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 10, 0.8 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                            baseX: bullet.x,\r\n                            baseY: bullet.y,\r\n                            x: bullet.x,\r\n                            y: bullet.y,\r\n                            duration: 3000,\r\n                        });\r\n                        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 6, 0.5 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                            baseX: bullet.x,\r\n                            baseY: bullet.y,\r\n                            x: bullet.x,\r\n                            y: bullet.y,\r\n                            duration: 3000,\r\n                        });\r\n                    },\r\n                });\r\n            }\r\n            if (enemy.disc !== state.hero.disc && enemy.modeTime >= 2000) {\r\n                enemy.setMode('chase');\r\n            }\r\n            else if (enemy.modeTime >= 5000) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.moveTo(-45, -50);\r\n        context.lineTo(-45, -90);\r\n        context.lineTo(-15, -50);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.moveTo(45, -50);\r\n        context.lineTo(45, -90);\r\n        context.lineTo(15, -50);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.moveTo(0, 10);\r\n        context.lineTo(-80, -60);\r\n        context.lineTo(-80, 60);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.moveTo(0, 10);\r\n        context.lineTo(80, -60);\r\n        context.lineTo(80, 60);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.moveTo(-45, -50);\r\n        context.lineTo(-10, 75);\r\n        context.lineTo(10, 75);\r\n        context.lineTo(45, -50);\r\n        context.fill();\r\n        context.lineWidth = 5;\r\n        context.strokeStyle = 'black';\r\n        context.stroke();\r\n        context.fillStyle = 'black';\r\n        context.beginPath();\r\n        context.arc(-15, -20, 10, Math.PI / 3, 4 * Math.PI / 3);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.arc(15, -20, 10, -Math.PI / 3, 2 * Math.PI / 3);\r\n        context.fill();\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/dragon.ts?");

/***/ }),

/***/ "./app/enemies/ent.ts":
/*!****************************!*\
  !*** ./app/enemies/ent.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ent: () => (/* binding */ ent)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\nconst ent = {\r\n    name: 'Ent',\r\n    statFactors: {\r\n        attacksPerSecond: 0.5,\r\n        maxLife: 2,\r\n        armor: 2,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 2 * window.BASE_DROP_CHANCE,\r\n    uniqueMultiplier: 2,\r\n    experienceFactor: 2,\r\n    radius: 32,\r\n    portalChance: 0.2,\r\n    portalDungeonType: 'tree',\r\n    update(state, enemy) {\r\n        if (state.fieldTime % 500 === 0) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootCirclingBullet)(state, enemy, 0, enemy.radius + 120, {\r\n                warningTime: 500,\r\n                vTheta: Math.PI / 2,\r\n                duration: 2500\r\n            });\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootCirclingBullet)(state, enemy, Math.PI, enemy.radius + 120, {\r\n                vTheta: Math.PI / 2,\r\n                warningTime: 500,\r\n                duration: 2500\r\n            });\r\n        }\r\n        const aggroRadius = 600;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletAtHero)(state, enemy, 0.8 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                duration: 2000,\r\n                damage: 3 * enemy.damage,\r\n                radius: 2 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                onDeath(state, bullet) {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 6, window.BASE_ENEMY_BULLET_SPEED, {\r\n                        baseX: bullet.x,\r\n                        baseY: bullet.y,\r\n                        x: bullet.x,\r\n                        y: bullet.y,\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.moveTo(0, -100);\r\n        context.lineTo(100 * Math.cos(1 * Math.PI / 3), 100 * Math.sin(1 * Math.PI / 3));\r\n        context.lineTo(100 * Math.cos(2 * Math.PI / 3), 100 * Math.sin(2 * Math.PI / 3));\r\n        context.fill();\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: -60, radius: 40 }, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: -40, y: -30, radius: 40 }, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 40, y: -30, radius: 40 }, enemy.baseColor);\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/ent.ts?");

/***/ }),

/***/ "./app/enemies/lord.ts":
/*!*****************************!*\
  !*** ./app/enemies/lord.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lord: () => (/* binding */ lord),\n/* harmony export */   lordsMinion: () => (/* binding */ lordsMinion)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\nconst lord = {\r\n    name: 'Lord',\r\n    statFactors: {\r\n        maxLife: 2.5,\r\n        damage: 1,\r\n        attacksPerSecond: 0.4,\r\n        speed: 0.4,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 2 * window.BASE_DROP_CHANCE,\r\n    uniqueMultiplier: 2,\r\n    experienceFactor: 5,\r\n    radius: 28,\r\n    portalChance: 0.2,\r\n    portalDungeonType: 'tree',\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const aggroRadius = 600;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        enemy.x += enemy.speed * Math.cos(enemy.theta) * window.FRAME_LENGTH / 1000;\r\n        enemy.y += enemy.speed * Math.sin(enemy.theta) * window.FRAME_LENGTH / 1000;\r\n        enemy.minions = enemy.minions.filter(m => m.life > 0);\r\n        const maxMinions = Math.min(5, 2 + Math.floor(enemy.level / 3));\r\n        if (enemy.attackCooldown <= state.fieldTime && enemy.minions.length < maxMinions) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            for (const theta of [enemy.theta + Math.PI / 2, enemy.theta - Math.PI / 2]) {\r\n                const minion = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.createEnemy)(state, enemy.x + enemy.radius * Math.cos(theta), enemy.y + enemy.radius * Math.sin(theta), lordsMinion, enemy.level, enemy.disc);\r\n                minion.theta = theta;\r\n                enemy.minions.push(minion);\r\n                minion.master = enemy;\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\nfunction turnTowardsTarget(state, enemy, target) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, target);\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n}\r\nconst lordsMinion = {\r\n    name: 'Peasant',\r\n    statFactors: {\r\n        maxLife: 0.5,\r\n        armor: 0,\r\n        attacksPerSecond: 0.5,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 0,\r\n    experienceFactor: 0.1,\r\n    radius: 20,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const master = enemy.master && enemy.master.life > 0 ? enemy.master : undefined;\r\n        const aggroRadius = 400;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 <= aggroRadius * aggroRadius) {\r\n            // Leash back to master for a bit after attacking.\r\n            if (master && enemy.attackCooldown - state.fieldTime > 400) {\r\n                // Enemy moves in its current direction unless it gets too far from the master.\r\n                const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, master);\r\n                if (distance2 >= 300 * 300) {\r\n                    turnTowardsTarget(state, enemy, master);\r\n                }\r\n            }\r\n            else {\r\n                // Chase the player when it can attack soon.\r\n                turnTowardsTarget(state, enemy, state.hero);\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInCurrentDirection)(state, enemy);\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootEnemyBullet)(state, enemy, window.BASE_ENEMY_BULLET_SPEED * Math.cos(enemy.theta), window.BASE_ENEMY_BULLET_SPEED * Math.sin(enemy.theta));\r\n            }\r\n        }\r\n        else if (master) {\r\n            // Enemy moves in its current direction unless it gets too far from the master.\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, master);\r\n            if (distance2 >= 200 * 200) {\r\n                turnTowardsTarget(state, enemy, master);\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInCurrentDirection)(state, enemy);\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x + 12 * Math.cos(enemy.theta),\r\n            y: enemy.y + 12 * Math.sin(enemy.theta),\r\n            radius: 2,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 2,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/lord.ts?");

/***/ }),

/***/ "./app/enemies/playerTurret.ts":
/*!*************************************!*\
  !*** ./app/enemies/playerTurret.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   playerTurret: () => (/* binding */ playerTurret)\n/* harmony export */ });\n/* harmony import */ var app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/uniqueEnchantmentHash */ \"./app/uniqueEnchantmentHash.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\n// Currently player minions are just invulnerable enemies that shoot player bullets.\r\nconst playerTurret = {\r\n    name: 'Player Turret',\r\n    statFactors: {},\r\n    initialParams: { duration: 2000 },\r\n    dropChance: 0,\r\n    experienceFactor: 0,\r\n    radius: 20,\r\n    isInvulnerable: true,\r\n    update(state, enemy) {\r\n        var _a, _b;\r\n        const closestEnemy = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getClosestElement)(enemy, state.enemies.filter(e => (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_2__.isEnemyTargetable)(state, e)));\r\n        const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, closestEnemy);\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        const weapon = state.hero.equipment.weapon;\r\n        const attacksPerSecond = weapon.getAttacksPerSecond(state, weapon) * state.hero.attacksPerSecond;\r\n        // Life falls to 0 over the turrets duration so the lifebar serves as a timer.\r\n        enemy.life = enemy.maxLife * Math.max(0, 1 - enemy.time / enemy.params.duration);\r\n        const attackCooldownDuration = 1000 / attacksPerSecond;\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + attackCooldownDuration;\r\n        }\r\n        const attackTime = attackCooldownDuration - (enemy.attackCooldown - state.fieldTime);\r\n        for (const shot of weapon.getShots(state, weapon)) {\r\n            const shotTime = attackCooldownDuration * ((_a = shot.timingOffset) !== null && _a !== void 0 ? _a : 0);\r\n            if (shotTime >= attackTime - window.FRAME_LENGTH / 2 && shotTime < attackTime + window.FRAME_LENGTH / 2) {\r\n                // Setting the source here is a little hacky and might have unpredictable results in some cases.\r\n                const bullet = shot.generateBullet(state, \r\n                // Fake hero standing where the turret is.\r\n                { ...state.hero, x: enemy.x, y: enemy.y, theta: enemy.theta }, weapon, closestEnemy || { x: enemy.x + 200 * Math.cos(enemy.theta), y: enemy.y + 200 * Math.sin(enemy.theta) });\r\n                if (!bullet) {\r\n                    continue;\r\n                }\r\n                for (const enchantment of state.hero.uniqueEnchantments) {\r\n                    const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_0__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n                    (_b = definition.modifyBullet) === null || _b === void 0 ? void 0 : _b.call(definition, state, enchantment, bullet);\r\n                    // Turret bullets should not grant charge.\r\n                    bullet.chargeGain = 0;\r\n                }\r\n                state.heroBullets.push(bullet);\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 20 * Math.cos(enemy.theta),\r\n            y: enemy.y + 20 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/playerTurret.ts?");

/***/ }),

/***/ "./app/enemies/scorpion.ts":
/*!*********************************!*\
  !*** ./app/enemies/scorpion.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scorpion: () => (/* binding */ scorpion)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst scorpion = {\r\n    name: 'Scorpion',\r\n    statFactors: { speed: 0.5 },\r\n    initialParams: { heading: 0 },\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        if (enemy.mode === 'choose') {\r\n            const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n            // Choose a heading that is generally towards the center of the current disc.\r\n            enemy.params.heading = Math.atan2(y, x) + (0.5 - Math.random()) * Math.PI / 3;\r\n            enemy.setMode('move');\r\n        }\r\n        if (enemy.mode === 'move') {\r\n            if (enemy.modeTime >= 1000) {\r\n                enemy.setMode('attack');\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.turnTowardsDirection)(state, enemy, enemy.params.heading);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, enemy.params.heading, enemy.speed);\r\n            if (enemy.modeTime >= 500 && (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.isEnemyPositionInvalid)(state, enemy)) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n        if (enemy.mode === 'attack') {\r\n            const aggroRadius = 300;\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n            if (distance2 <= aggroRadius * aggroRadius) {\r\n                if (enemy.modeTime <= 600) {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.turnTowardsHeroHeading)(state, enemy, 400, 0.2);\r\n                }\r\n                if (enemy.modeTime >= 1000 && enemy.attackCooldown <= state.fieldTime) {\r\n                    enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                    const power = Math.min(1, enemy.level / 90);\r\n                    const arcSize = 2 * Math.PI / 3 + Math.PI / 3 * power;\r\n                    const bulletCount = Math.floor(3 + 3 * power);\r\n                    const maxPoolSize = 40 + 40 * power;\r\n                    // This slows down quickly, and doesn't damage until after 500ms.\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, enemy.theta, arcSize, bulletCount, 2 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                        warningTime: 500,\r\n                        duration: 3000,\r\n                        friction: 0.95,\r\n                        damageOverTime: 0.5 * enemy.damage,\r\n                        update: (state, bullet) => {\r\n                            (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateSimpleBullet)(state, bullet);\r\n                            if (bullet.warningTime <= 0) {\r\n                                bullet.vx = bullet.vy = 0;\r\n                                bullet.radius = Math.min(bullet.radius * 1.1, maxPoolSize);\r\n                            }\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= 1500) {\r\n                enemy.params.heading = enemy.theta;\r\n                enemy.setMode('move');\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 10, y: 0, radius: 45 }, enemy.baseColor);\r\n        context.fillStyle = enemy.baseColor;\r\n        // Top Claw\r\n        context.beginPath();\r\n        context.arc(40, -36, 35, Math.PI, 2 * Math.PI);\r\n        context.fill();\r\n        // Bottom Claw\r\n        context.beginPath();\r\n        context.arc(40, 36, 35, 0, Math.PI);\r\n        context.fill();\r\n        // Tail\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: -40, y: 0, radius: 15 }, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: -60, y: -16, radius: 15 }, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: -65, y: -37, radius: 15 }, enemy.baseColor);\r\n        // Stinger\r\n        context.beginPath();\r\n        context.arc(-45, -60, 20, 3 * Math.PI / 4, 7 * Math.PI / 4);\r\n        context.fill();\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/scorpion.ts?");

/***/ }),

/***/ "./app/enemies/skeleton.ts":
/*!*********************************!*\
  !*** ./app/enemies/skeleton.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   skeleton: () => (/* binding */ skeleton)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst boneBullet = {\r\n    duration: 3000,\r\n    update(state, bullet) {\r\n        if (bullet.time <= 600) {\r\n            (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateHeroSeekingBullet)(state, bullet);\r\n        }\r\n        else {\r\n            (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateSimpleBullet)(state, bullet);\r\n        }\r\n    }\r\n};\r\nconst skeleton = {\r\n    name: 'Skeleton',\r\n    statFactors: {},\r\n    initialParams: { heading: 0 },\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        if (enemy.mode === 'choose') {\r\n            const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n            // Choose a heading that is generally towards the center of the current disc.\r\n            enemy.params.heading = Math.atan2(y, x) + (0.5 - Math.random()) * Math.PI / 3;\r\n            enemy.setMode('move');\r\n        }\r\n        if (enemy.mode === 'move') {\r\n            if (enemy.modeTime >= 1000) {\r\n                enemy.setMode('attack');\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, enemy.params.heading, enemy.speed);\r\n            if (enemy.modeTime >= 500 && (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.isEnemyPositionInvalid)(state, enemy)) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n        if (enemy.mode === 'attack') {\r\n            const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n            const aggroRadius = 500;\r\n            if (distance2 <= aggroRadius ** 2 && enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                const closeRadius = 300;\r\n                if (distance2 < closeRadius * closeRadius) {\r\n                    const theta = Math.atan2(y, x);\r\n                    const speed = 0.8 * window.BASE_ENEMY_BULLET_SPEED;\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, speed * Math.cos(theta + 5 * Math.PI / 6), speed * Math.sin(theta + 5 * Math.PI / 6), boneBullet);\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, speed * Math.cos(theta - 5 * Math.PI / 6), speed * Math.sin(theta - 5 * Math.PI / 6), boneBullet);\r\n                }\r\n                else {\r\n                    // This slows down quickly, and doesn't damage until after 500ms.\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHeroHeading)(state, enemy, 2 * window.BASE_ENEMY_BULLET_SPEED, 0.2, {\r\n                        warningTime: 1500,\r\n                        duration: 1500,\r\n                        friction: 0.8,\r\n                        radius: 1.5 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                        onDeath(state, bullet) {\r\n                            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 6, 0.5 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                                baseX: bullet.x,\r\n                                baseY: bullet.y,\r\n                                x: bullet.x,\r\n                                y: bullet.y,\r\n                                duration: 3000,\r\n                            });\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= 1000) {\r\n                if (Math.random() < 0.5) {\r\n                    // 50% chance to choose a new direction.\r\n                    enemy.setMode('choose');\r\n                }\r\n                else {\r\n                    enemy.setMode('move');\r\n                }\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: -25, radius: 70 }, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 55, radius: 40 }, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: -30, y: -10, radius: 20 }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 30, y: -10, radius: 20 }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 20, radius: 10 }, 'black');\r\n        context.beginPath();\r\n        context.lineWidth = 5;\r\n        context.strokeStyle = 'black';\r\n        context.arc(0, -25, 73, Math.PI / 3, 2 * Math.PI / 3);\r\n        context.arc(0, -25, 87, 2 * Math.PI / 3, Math.PI / 3, true);\r\n        context.arc(0, -25, 100, Math.PI / 3, 2 * Math.PI / 3);\r\n        for (let i = 0; i <= 3; i++) {\r\n            const theta = Math.PI / 3 + (i + 1) * Math.PI / 3 / 5;\r\n            context.moveTo(73 * Math.cos(theta), -25 + 73 * Math.sin(theta));\r\n            context.lineTo(100 * Math.cos(theta), -25 + 100 * Math.sin(theta));\r\n        }\r\n        context.stroke();\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/skeleton.ts?");

/***/ }),

/***/ "./app/enemies/slime.ts":
/*!******************************!*\
  !*** ./app/enemies/slime.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   greatSlime: () => (/* binding */ greatSlime),\n/* harmony export */   megaSlime: () => (/* binding */ megaSlime),\n/* harmony export */   miniSlime: () => (/* binding */ miniSlime),\n/* harmony export */   slime: () => (/* binding */ slime)\n/* harmony export */ });\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n\r\n\r\n\r\n\r\nconst slime = {\r\n    name: 'Slime',\r\n    statFactors: {\r\n        attacksPerSecond: 0.5,\r\n        maxLife: 1.6,\r\n        armor: 0,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 1.5 * window.BASE_DROP_CHANCE,\r\n    experienceFactor: 1.5,\r\n    radius: 24,\r\n    portalChance: 0.1,\r\n    portalDungeonType: 'cave',\r\n    update(state, enemy) {\r\n        updateSlimeMovement(state, enemy);\r\n    },\r\n    onDeath(state, enemy) {\r\n        const count = Math.round(2 + Math.random());\r\n        for (let i = 0; i < count; i++) {\r\n            const theta = state.fieldTime / 500 + i * 2 * Math.PI / count;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, enemy.x + enemy.radius * Math.cos(theta), enemy.y + enemy.radius * Math.sin(theta), miniSlime, enemy.level, enemy.disc);\r\n        }\r\n    },\r\n    onHit(state, enemy) {\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 12, 1.2 * window.BASE_ENEMY_BULLET_SPEED);\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'black');\r\n        const count = Math.max(3, Math.ceil((enemy.radius - 8) / 8));\r\n        for (let i = 0; i < count; i++) {\r\n            const theta = state.fieldTime / 4000 + i * 2 * Math.PI / count;\r\n            const p = (1 + Math.sin(state.fieldTime / 500 + i * 2 * Math.PI / 3)) / 2;\r\n            const maxDistance = enemy.radius / 4;\r\n            const minDistance = enemy.radius / 10;\r\n            const distance = minDistance + p * (maxDistance - minDistance);\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n                x: enemy.x + distance * Math.cos(theta),\r\n                y: enemy.y + distance * Math.sin(theta),\r\n                radius: 3 * enemy.radius / 4\r\n            }, enemy.baseColor);\r\n        }\r\n    }\r\n};\r\nfunction updateSlimeMovement(state, enemy) {\r\n    if (enemy.mode === 'choose') {\r\n        if (enemy.modeTime > 400) {\r\n            enemy.theta = Math.random() * 2 * Math.PI;\r\n            enemy.vx = 200 * Math.cos(enemy.theta);\r\n            enemy.vy = 200 * Math.sin(enemy.theta);\r\n            enemy.setMode('dash');\r\n        }\r\n    }\r\n    if (enemy.mode === 'dash') {\r\n        enemy.x += enemy.vx * window.FRAME_LENGTH / 1000;\r\n        enemy.y += enemy.vy * window.FRAME_LENGTH / 1000;\r\n        enemy.vx *= 0.97;\r\n        enemy.vy *= 0.97;\r\n        if (enemy.modeTime >= enemy.radius * 40) {\r\n            enemy.setMode('choose');\r\n        }\r\n    }\r\n}\r\nconst greatSlime = {\r\n    ...slime,\r\n    name: 'Great Slime',\r\n    statFactors: {\r\n        attacksPerSecond: 0.5,\r\n        maxLife: 2.4,\r\n        damage: 1.5,\r\n        armor: 0,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 2 * window.BASE_DROP_CHANCE,\r\n    uniqueMultiplier: 2,\r\n    portalChance: 0,\r\n    experienceFactor: 2,\r\n    radius: 32,\r\n    onDeath(state, enemy) {\r\n        const count = 2;\r\n        for (let i = 0; i < count; i++) {\r\n            const theta = state.fieldTime / 500 + i * 2 * Math.PI / count;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, enemy.x + enemy.radius * Math.cos(theta), enemy.y + enemy.radius * Math.sin(theta), slime, enemy.level, enemy.disc);\r\n        }\r\n    },\r\n    onHit(state, enemy) {\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, 1.2 * window.BASE_ENEMY_BULLET_SPEED, { radius: 2 * window.BASE_ENEMY_BULLET_RADIUS });\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 12, 1.2 * window.BASE_ENEMY_BULLET_SPEED);\r\n        }\r\n    },\r\n};\r\nconst megaSlime = {\r\n    ...slime,\r\n    name: 'Mega Slime',\r\n    statFactors: {\r\n        attacksPerSecond: 0.5,\r\n        maxLife: window.BOSS_MAX_LIFE_FACTOR,\r\n        damage: 1.25,\r\n        armor: 1,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 1,\r\n    portalChance: 0,\r\n    uniqueMultiplier: 20,\r\n    experienceFactor: 20,\r\n    radius: 40,\r\n    getEnchantment(state, enemy) {\r\n        return (0,app_enchantments__WEBPACK_IMPORTED_MODULE_0__.getInsightEnchantment)(state, enemy.level);\r\n    },\r\n    update(state, enemy) {\r\n        updateSlimeMovement(state, enemy);\r\n        if (enemy.mode === 'dash' && enemy.modeTime === 0) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, 2 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                warningTime: 800,\r\n                duration: 3000,\r\n                friction: 0.5,\r\n                damageOverTime: 1.25 * enemy.damage,\r\n                update: (state, bullet) => {\r\n                    (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_2__.updateSimpleBullet)(state, bullet);\r\n                    if (bullet.warningTime <= 0) {\r\n                        bullet.vx = bullet.vy = 0;\r\n                        bullet.radius++;\r\n                    }\r\n                },\r\n            });\r\n            //shootBulletAtHero(state, enemy, 1.5 * window.BASE_ENEMY_BULLET_SPEED, {damage: 1.5 * enemy.damage, radius: 2 * window.BASE_ENEMY_BULLET_RADIUS});\r\n        }\r\n        if (enemy.mode === 'choose' && enemy.modeTime === 0) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 12, 1.2 * window.BASE_ENEMY_BULLET_SPEED, { duration: 2000 });\r\n        }\r\n    },\r\n    onDeath(state, enemy) {\r\n        const count = 2;\r\n        for (let i = 0; i < count; i++) {\r\n            const theta = state.fieldTime / 500 + i * 2 * Math.PI / count;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.createEnemy)(state, enemy.x + enemy.radius * Math.cos(theta), enemy.y + enemy.radius * Math.sin(theta), greatSlime, enemy.level, enemy.disc);\r\n        }\r\n    },\r\n    onHit(state, enemy) {\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            for (let i = 0; i < 3; i++) {\r\n                const speed = 0.3 * window.BASE_ENEMY_BULLET_SPEED + i * 0.3 * window.BASE_ENEMY_BULLET_SPEED;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 6, speed, { duration: 2000 });\r\n            }\r\n        }\r\n    },\r\n};\r\nconst miniSlime = {\r\n    ...slime,\r\n    name: 'Mini Slime',\r\n    statFactors: {\r\n        maxLife: 0.8,\r\n        armor: 0,\r\n    },\r\n    initialParams: {},\r\n    portalChance: 0,\r\n    dropChance: 0,\r\n    experienceFactor: 0.1,\r\n    radius: 16,\r\n    onDeath(state, enemy) {\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletCircle)(state, enemy, 0, 6, window.BASE_ENEMY_BULLET_SPEED);\r\n    },\r\n    onHit(state, enemy) {\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootBulletAtHero)(state, enemy, window.BASE_ENEMY_BULLET_SPEED);\r\n        }\r\n    },\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/slime.ts?");

/***/ }),

/***/ "./app/enemies/snake.ts":
/*!******************************!*\
  !*** ./app/enemies/snake.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   snake: () => (/* binding */ snake)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst snake = {\r\n    name: 'Snake',\r\n    statFactors: {},\r\n    initialParams: { heading: 0 },\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        if (enemy.mode === 'choose') {\r\n            const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n            // Choose a heading that is generally towards the center of the current disc.\r\n            enemy.params.heading = Math.atan2(y, x) + (0.5 - Math.random()) * Math.PI / 3;\r\n            enemy.setMode('move');\r\n        }\r\n        if (enemy.mode === 'move') {\r\n            if (enemy.modeTime >= 1000) {\r\n                enemy.setMode('attack');\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, enemy.params.heading, enemy.speed);\r\n            if (enemy.modeTime >= 500 && (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.isEnemyPositionInvalid)(state, enemy)) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n        if (enemy.mode === 'attack') {\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                const closeRadius = 300;\r\n                const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n                if (distance2 > closeRadius * closeRadius) {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 1.5 * window.BASE_ENEMY_BULLET_SPEED, { amplitude: 20, frequency: 3 });\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 1.5 * window.BASE_ENEMY_BULLET_SPEED, { amplitude: -20, frequency: 3 });\r\n                }\r\n                else {\r\n                    // This slows down quickly, and doesn't damage until after 500ms.\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHeroHeading)(state, enemy, 2 * window.BASE_ENEMY_BULLET_SPEED, 0.2, {\r\n                        warningTime: 500,\r\n                        duration: 2000,\r\n                        friction: 0.95,\r\n                        damageOverTime: enemy.damage,\r\n                        update: (state, bullet) => {\r\n                            (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateSimpleBullet)(state, bullet);\r\n                            if (bullet.warningTime <= 0) {\r\n                                bullet.vx = bullet.vy = 0;\r\n                                bullet.radius++;\r\n                            }\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= 1000) {\r\n                enemy.setMode('move');\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n        context.fillStyle = enemy.baseColor;\r\n        // Top of mouth\r\n        context.beginPath();\r\n        context.arc(0, 0, 100, -Math.PI, 0);\r\n        const topMouthCurve = (v) => {\r\n            const theta = 0 * (1 - v) + (v) * -Math.PI;\r\n            return {\r\n                x: 100 * Math.cos(theta),\r\n                y: (100 - 30 * Math.sin(v * Math.PI)) * Math.sin(theta),\r\n            };\r\n        };\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.parametricCurve)(context, [0, 1], 10, topMouthCurve);\r\n        context.fill();\r\n        // Teeth\r\n        context.beginPath();\r\n        context.moveTo(-80, -80);\r\n        context.lineTo(-50, 30);\r\n        context.lineTo(-20, -80);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.moveTo(80, -80);\r\n        context.lineTo(50, 30);\r\n        context.lineTo(20, -80);\r\n        context.fill();\r\n        // Top of mouth outline\r\n        context.beginPath();\r\n        context.lineWidth = 5;\r\n        context.strokeStyle = 'black';\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.parametricCurve)(context, [0, 1], 10, topMouthCurve);\r\n        context.stroke();\r\n        // Bottom of mouth\r\n        context.beginPath();\r\n        context.arc(0, 0, 100, -2 * Math.PI, -Math.PI);\r\n        const bottomMouthCurve = (v) => {\r\n            const theta = -Math.PI * (1 - v) + v * -2 * Math.PI;\r\n            return {\r\n                x: 100 * Math.cos(theta),\r\n                y: (100 - 30 * Math.sin(v * Math.PI)) * Math.sin(theta),\r\n            };\r\n        };\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.parametricCurve)(context, [0, 1], 10, bottomMouthCurve);\r\n        context.fill();\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/snake.ts?");

/***/ }),

/***/ "./app/enemies/sniper.ts":
/*!*******************************!*\
  !*** ./app/enemies/sniper.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sniper: () => (/* binding */ sniper)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\nconst sniper = {\r\n    name: 'Sniper',\r\n    statFactors: {\r\n        attacksPerSecond: 0.5,\r\n        maxLife: 0.5,\r\n        armor: 0.5,\r\n        damage: 2,\r\n        speed: 0.4,\r\n    },\r\n    initialParams: {},\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        const aggroRadius = 800;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.turnTowardsTarget)(state, enemy, state.hero);\r\n        const targetRadius = 600;\r\n        // Try to stay a certain distance from the player.\r\n        if (distance2 <= (targetRadius - 100) ** 2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInDirection)(state, enemy, Math.atan2(y, x) + Math.PI);\r\n        }\r\n        else if (distance2 >= (targetRadius + 100) ** 2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.moveEnemyInDirection)(state, enemy, Math.atan2(y, x));\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletAtHero)(state, enemy, 1.5 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                duration: 2000,\r\n                radius: 1.2 * window.BASE_ENEMY_BULLET_RADIUS,\r\n            });\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, enemy.baseColor);\r\n        context.fillStyle = 'black';\r\n        // Tail\r\n        context.beginPath();\r\n        context.moveTo(100 * Math.cos(5 * Math.PI / 6), 100 * Math.sin(5 * Math.PI / 6));\r\n        context.lineTo(100 * Math.cos(7 * Math.PI / 6), 100 * Math.sin(7 * Math.PI / 6));\r\n        context.lineTo(-50, 0);\r\n        context.fill();\r\n        // Line\r\n        context.lineWidth = 10;\r\n        context.strokeStyle = 'black';\r\n        context.beginPath();\r\n        context.moveTo(-80, 0);\r\n        context.lineTo(90, 0);\r\n        context.stroke();\r\n        // Head\r\n        context.beginPath();\r\n        context.moveTo(30, 50);\r\n        context.lineTo(100, 0);\r\n        context.lineTo(30, -50);\r\n        context.lineTo(60, 0);\r\n        context.fill();\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/sniper.ts?");

/***/ }),

/***/ "./app/enemies/squid.ts":
/*!******************************!*\
  !*** ./app/enemies/squid.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   squid: () => (/* binding */ squid)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\nconst squid = {\r\n    name: 'Squid',\r\n    statFactors: {},\r\n    initialParams: {},\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        enemy.vx = (enemy.vx || 0);\r\n        enemy.vy = (enemy.vy || 0);\r\n        const aggroRadius = 300;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        const isAggro = distance2 <= aggroRadius * aggroRadius;\r\n        if (enemy.mode === 'choose') {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.turnTowardsTarget)(state, enemy, isAggro ? state.hero : enemy.disc, 0.1);\r\n            // Slowly \"fall\" forwards wiggling a bit from side to side\r\n            const sideValue = Math.sin(state.fieldTime / 500);\r\n            enemy.vx += 4 * Math.cos(enemy.theta) + 0.2 * sideValue * Math.cos(enemy.theta + Math.PI / 2);\r\n            enemy.vy += 4 * Math.sin(enemy.theta) + 0.2 * sideValue * Math.sin(enemy.theta + Math.PI / 2);\r\n            const mag = Math.sqrt(enemy.vx * enemy.vx + enemy.vy * enemy.vy);\r\n            if (mag > 50) {\r\n                enemy.vx *= 50 / mag;\r\n                enemy.vy *= 50 / mag;\r\n            }\r\n            const delay = isAggro ? 1000 : 2000;\r\n            if (enemy.modeTime >= delay && Math.random() < 0.05) {\r\n                enemy.setMode('burst');\r\n            }\r\n            enemy.x += enemy.vx * window.FRAME_LENGTH / 1000;\r\n            enemy.y += enemy.vy * window.FRAME_LENGTH / 1000;\r\n            return;\r\n        }\r\n        if (enemy.mode === 'burst') {\r\n            for (let i = 0; i < 4; i++) {\r\n                const randomDirection = enemy.theta + (Math.random() - 0.5) * Math.PI / 4;\r\n                const randomSpread = Math.PI / 12 + Math.random() * Math.PI / 3;\r\n                const speed = 0.8 * window.BASE_ENEMY_BULLET_SPEED + i * 0.2 * window.BASE_ENEMY_BULLET_SPEED;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletArc)(state, enemy, randomDirection, randomSpread, 3, speed);\r\n            }\r\n            // Bursts backwards.\r\n            enemy.vx = -200 * Math.cos(enemy.theta);\r\n            enemy.vy = -200 * Math.sin(enemy.theta);\r\n            enemy.setMode('glide');\r\n            return;\r\n        }\r\n        if (enemy.mode === 'glide') {\r\n            enemy.vx *= 0.98;\r\n            enemy.vy *= 0.98;\r\n            enemy.x += enemy.vx * window.FRAME_LENGTH / 1000;\r\n            enemy.y += enemy.vy * window.FRAME_LENGTH / 1000;\r\n            if (enemy.modeTime >= 500 && Math.random() < 0.05) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n    },\r\n    render: renderSquid,\r\n};\r\nfunction renderSquid(context, state, enemy) {\r\n    const tentacleDirection = ((enemy.modeTime % 800) < 400) ? -1 : 1;\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, 'black');\r\n    context.save();\r\n    context.translate(enemy.x, enemy.y);\r\n    context.rotate(enemy.theta);\r\n    // \"Body\"\r\n    context.fillStyle = enemy.baseColor;\r\n    context.beginPath();\r\n    context.arc(0, 0, enemy.radius, Math.PI / 2, 3 * Math.PI / 2);\r\n    context.lineTo(0, -enemy.radius);\r\n    context.fill();\r\n    // Tentacles\r\n    context.strokeStyle = enemy.baseColor;\r\n    context.lineWidth = 4;\r\n    context.beginPath();\r\n    // Top tentacle\r\n    context.moveTo(0, -enemy.radius / 2);\r\n    context.arcTo(enemy.radius / 4, -enemy.radius / 2 + tentacleDirection * enemy.radius / 4, enemy.radius / 2, -enemy.radius / 2, enemy.radius / 4);\r\n    // Middle tentacle\r\n    context.moveTo(0, 0);\r\n    context.arcTo(enemy.radius / 4, 0 + tentacleDirection * enemy.radius / 4, enemy.radius / 2, 0, enemy.radius / 4);\r\n    context.arcTo(3 * enemy.radius / 4, 0 - tentacleDirection * enemy.radius / 4, enemy.radius, 0, enemy.radius / 4);\r\n    // Bottom tentacle\r\n    context.moveTo(0, enemy.radius / 2);\r\n    context.arcTo(enemy.radius / 4, enemy.radius / 2 + tentacleDirection * enemy.radius / 4, enemy.radius / 2, enemy.radius / 2, enemy.radius / 4);\r\n    context.stroke();\r\n    context.restore();\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/squid.ts?");

/***/ }),

/***/ "./app/enemies/swampThing.ts":
/*!***********************************!*\
  !*** ./app/enemies/swampThing.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   swampThing: () => (/* binding */ swampThing)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n\r\n\r\n\r\nconst slowBulletStats = {\r\n    radius: 2 * window.BASE_ENEMY_BULLET_RADIUS,\r\n    duration: 2000,\r\n    slowEffect: { effect: 0.5, duration: 1500 },\r\n    render(context, state, bullet) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, bullet, '#A82', '#860');\r\n    },\r\n};\r\nconst swampThing = {\r\n    name: 'Swamp Thing',\r\n    statFactors: {\r\n        speed: 1.5,\r\n    },\r\n    initialParams: {\r\n        targetX: 0,\r\n        targetY: 0,\r\n    },\r\n    radius: 30,\r\n    update(state, enemy) {\r\n        if (enemy.mode === 'choose' && enemy.modeTime >= 500) {\r\n            const aggroRadius = 500;\r\n            const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__.getTargetVector)(enemy, state.hero);\r\n            if (distance2 > aggroRadius * aggroRadius) {\r\n                return;\r\n            }\r\n            enemy.theta = Math.atan2(y, x);\r\n            enemy.params.targetX = state.hero.x + state.hero.vx * 500 / 1000 + 24 * (0.5 - Math.random());\r\n            enemy.params.targetY = state.hero.y + state.hero.vy * 500 / 1000 + 24 * (0.5 - Math.random());\r\n            enemy.setMode('shrink');\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletCircle)(state, enemy, enemy.theta, 6, window.BASE_ENEMY_BULLET_SPEED, slowBulletStats);\r\n        }\r\n        if (enemy.mode === 'shrink') {\r\n            enemy.isInvulnerable = true;\r\n            enemy.radius = Math.max(enemy.radius * 0.95, 2);\r\n            if (enemy.radius <= 4) {\r\n                enemy.setMode('rush');\r\n            }\r\n        }\r\n        if (enemy.mode === 'rush') {\r\n            if (enemy.modeTime % 100 === 0) {\r\n                state.enemyBullets.push({\r\n                    ...(0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.getBaseEnemyBullet)(state, enemy),\r\n                    damageOverTime: enemy.damage,\r\n                    radius: enemy.radius,\r\n                    duration: 2000,\r\n                    slowEffect: { effect: 0.5, duration: window.FRAME_LENGTH },\r\n                    update(state, bullet) {\r\n                        if (bullet.radius < 50) {\r\n                            bullet.radius += 1;\r\n                        }\r\n                    },\r\n                    renderFloorBefore(context, state, bullet) {\r\n                        context.save();\r\n                        context.globalAlpha *= Math.min(1, (bullet.duration - bullet.time) / 200);\r\n                        context.lineWidth = 2;\r\n                        context.beginPath();\r\n                        context.arc(bullet.x, bullet.y, bullet.radius, 0, 2 * Math.PI);\r\n                        context.strokeStyle = '#860';\r\n                        context.stroke();\r\n                        context.restore();\r\n                    },\r\n                    renderFloor(context, state, bullet) {\r\n                        context.save();\r\n                        context.globalAlpha *= Math.min(1, (bullet.duration - bullet.time) / 200);\r\n                        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, bullet, '#A82');\r\n                        context.restore();\r\n                    },\r\n                    render(context, state, bullet) {\r\n                    }\r\n                });\r\n            }\r\n            if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyToTarget)(state, enemy, { x: enemy.params.targetX, y: enemy.params.targetY })) {\r\n                enemy.setMode('grow');\r\n            }\r\n            if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.isEnemyOffDisc)(state, enemy) && enemy.modeTime >= 1000) {\r\n                enemy.setMode('grow');\r\n            }\r\n        }\r\n        if (enemy.mode === 'grow') {\r\n            enemy.radius = Math.min(enemy.radius * 1.05, 30);\r\n            if (enemy.radius >= 30) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletCircle)(state, enemy, enemy.theta, 6, window.BASE_ENEMY_BULLET_SPEED, slowBulletStats);\r\n                enemy.isInvulnerable = false;\r\n                enemy.setMode('attack');\r\n            }\r\n        }\r\n        if (enemy.mode === 'attack') {\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, window.BASE_ENEMY_BULLET_SPEED, {\r\n                    duration: 2000,\r\n                });\r\n            }\r\n            if (enemy.modeTime >= 2000) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        // fillCircle(context, {x: 0, y: 0, radius: 100}, 'black');\r\n        const offset = (enemy.time % 1000) / 1000;\r\n        const ringCount = 3;\r\n        for (let i = 0; i < ringCount; i++) {\r\n            const p = (offset + i / (ringCount + 1)) % 1;\r\n            context.save();\r\n            context.globalAlpha *= (1 - p) * enemy.radius / 30 / ringCount;\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: p * 100 }, enemy.baseColor);\r\n            context.restore();\r\n        }\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/swampThing.ts?");

/***/ }),

/***/ "./app/enemies/tornado.ts":
/*!********************************!*\
  !*** ./app/enemies/tornado.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dustDevil: () => (/* binding */ dustDevil),\n/* harmony export */   tornado: () => (/* binding */ tornado)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nfunction updateSpiralBullet(state, bullet) {\r\n    bullet.orbitRadius = Math.min(100, (bullet.orbitRadius || 0) + 1);\r\n    (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateCirclingBullet)(state, bullet);\r\n}\r\nconst cycloneBullet = {\r\n    warningTime: 3000,\r\n    duration: 3000,\r\n    radius: 0.5 * window.BASE_ENEMY_BULLET_RADIUS,\r\n    friction: 0.25,\r\n    update(state, bullet) {\r\n        (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateSimpleBullet)(state, bullet);\r\n        const spiralDuration = 1500;\r\n        if (bullet.time % 100 === 0 /*&& bullet.time < bullet.duration - spiralDuration*/) {\r\n            const parity = bullet.time % 200 === 100;\r\n            const theta = Math.PI * bullet.time / 600 + (parity ? Math.PI : 0);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootCirclingBullet)(state, bullet.source, theta, 0, {\r\n                anchor: bullet,\r\n                duration: spiralDuration,\r\n                orbitRadius: 5,\r\n                radius: 0.8 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                vTheta: 3 * Math.PI,\r\n                update: updateSpiralBullet,\r\n            });\r\n        }\r\n    }\r\n};\r\nconst tornado = {\r\n    name: 'Tornado',\r\n    statFactors: {\r\n        attacksPerSecond: 0.5,\r\n        damage: 0.8,\r\n        speed: 0.8,\r\n    },\r\n    initialParams: { heading: 0 },\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        // Circle around the middle third of the disc.\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n        const discTheta = Math.atan2(y, x);\r\n        if (distance2 > (0.66 * enemy.disc.radius) ** 2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, discTheta + Math.PI / 3);\r\n        }\r\n        else if (distance2 < (0.33 * enemy.disc.radius) ** 2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, discTheta + 2 * Math.PI / 3);\r\n        }\r\n        else {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, discTheta + Math.PI / 2);\r\n        }\r\n        const aggroRadius = 500;\r\n        const heroDistance2 = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero).distance2;\r\n        if (heroDistance2 <= aggroRadius * aggroRadius) {\r\n            if (enemy.modeTime >= 1000 && enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                // const power = Math.min(1, enemy.level / 90);\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 1.5 * window.BASE_ENEMY_BULLET_SPEED, cycloneBullet);\r\n            }\r\n        }\r\n        if (heroDistance2 <= 800 * 800) {\r\n            if (enemy.modeTime % 200 === 0) {\r\n                const parity = enemy.modeTime % 400 === 200;\r\n                const theta = Math.PI * enemy.modeTime / 600 + (parity ? Math.PI : 0);\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootCirclingBullet)(state, enemy, theta, 0, {\r\n                    duration: 2000,\r\n                    orbitRadius: 5,\r\n                    radius: 0.8 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                    vTheta: 3 * Math.PI,\r\n                    update(state, bullet) {\r\n                        bullet.orbitRadius = Math.min(60, (bullet.orbitRadius || 0) + 1);\r\n                        (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateCirclingBullet)(state, bullet);\r\n                    },\r\n                });\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        const p = (enemy.time % 800) / 800;\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n        context.strokeStyle = enemy.baseColor;\r\n        context.lineWidth = 4;\r\n        context.beginPath();\r\n        const theta = p * 2 * Math.PI;\r\n        const dTheta = 2 * Math.PI / 10;\r\n        for (let i = 0; i < 8; i++) {\r\n            context.beginPath();\r\n            const curveTheta = 0.28 * Math.PI * (8 - i) / 8;\r\n            const y = 100 - 200 * Math.sin(curveTheta);\r\n            //const w = 0.75 * Math.sqrt(10000 - y * y);\r\n            const w = 200 - 200 * Math.cos(curveTheta);\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.drawOval)(context, { x: w / 3 * Math.cos(theta + i * dTheta), y: y + 15, w, h: w / 4 });\r\n            context.stroke();\r\n        }\r\n    }),\r\n};\r\nconst miniCycloneBullet = {\r\n    warningTime: 1500,\r\n    duration: 1500,\r\n    radius: 0.5 * window.BASE_ENEMY_BULLET_RADIUS,\r\n    friction: 0.25,\r\n    update(state, bullet) {\r\n        (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateSimpleBullet)(state, bullet);\r\n        const spiralDuration = 1000;\r\n        if (bullet.time % 100 === 0 /*&& bullet.time < bullet.duration - spiralDuration*/) {\r\n            const parity = bullet.time % 200 === 100;\r\n            const theta = Math.PI * bullet.time / 600 + (parity ? Math.PI : 0);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootCirclingBullet)(state, bullet.source, theta, 0, {\r\n                anchor: bullet,\r\n                duration: spiralDuration,\r\n                orbitRadius: 5,\r\n                radius: 0.8 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                vTheta: 3 * Math.PI,\r\n                update: updateSpiralBullet,\r\n            });\r\n        }\r\n    }\r\n};\r\nconst dustDevil = {\r\n    name: 'Dust Devil',\r\n    statFactors: {\r\n        attacksPerSecond: 0.75,\r\n        damage: 0.75,\r\n        speed: 0.8,\r\n    },\r\n    initialParams: { heading: 0 },\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, enemy.params.heading);\r\n        if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.isEnemyPositionInvalid)(state, enemy)) {\r\n            const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n            // Choose a heading that is generally towards the center of the current disc.\r\n            enemy.params.heading = Math.atan2(y, x) + (0.5 - Math.random()) * Math.PI / 3;\r\n        }\r\n        const aggroRadius = 350;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 <= aggroRadius * aggroRadius) {\r\n            enemy.params.heading;\r\n            if (enemy.modeTime >= 1000 && enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                // const power = Math.min(1, enemy.level / 90);\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletAtHero)(state, enemy, 1.5 * window.BASE_ENEMY_BULLET_SPEED, miniCycloneBullet);\r\n            }\r\n        }\r\n        if (distance2 <= 500 * 500) {\r\n            // Change heading to the hero any time they are in range.\r\n            enemy.params.heading = Math.atan2(y, x);\r\n            if (enemy.modeTime % 200 === 0) {\r\n                const parity = enemy.modeTime % 400 === 200;\r\n                const theta = Math.PI * enemy.modeTime / 600 + (parity ? Math.PI : 0);\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootCirclingBullet)(state, enemy, theta, 0, {\r\n                    duration: 1500,\r\n                    orbitRadius: 5,\r\n                    radius: 0.8 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                    vTheta: 3 * Math.PI,\r\n                    update(state, bullet) {\r\n                        bullet.orbitRadius = Math.min(40, (bullet.orbitRadius || 0) + 1);\r\n                        (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateCirclingBullet)(state, bullet);\r\n                    },\r\n                });\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        const p = (enemy.time % 800) / 800;\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n        context.strokeStyle = enemy.baseColor;\r\n        context.lineWidth = 4;\r\n        context.beginPath();\r\n        const theta = p * 2 * Math.PI;\r\n        const dTheta = 2 * Math.PI / 10;\r\n        for (let i = 0; i < 8; i++) {\r\n            context.beginPath();\r\n            const curveTheta = 0.28 * Math.PI * (8 - i) / 8;\r\n            const y = 100 - 200 * Math.sin(curveTheta);\r\n            //const w = 0.75 * Math.sqrt(10000 - y * y);\r\n            const w = 200 - 200 * Math.cos(curveTheta);\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.drawOval)(context, { x: w / 3 * Math.cos(theta + i * dTheta), y: y, w: 15 + (i % 2) * 5, h: w / 4 });\r\n            context.stroke();\r\n        }\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/tornado.ts?");

/***/ }),

/***/ "./app/enemies/turret.ts":
/*!*******************************!*\
  !*** ./app/enemies/turret.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   turret: () => (/* binding */ turret)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\nconst turret = {\r\n    name: 'Turret',\r\n    statFactors: {\r\n        maxLife: 2,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n        armor: 2,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 2 * window.BASE_DROP_CHANCE,\r\n    uniqueMultiplier: 2,\r\n    experienceFactor: 2,\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        const aggroRadius = 400;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            enemy.theta += 0.01;\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            for (let i = 0; i < 3; i++) {\r\n                const theta = enemy.theta - Math.PI / 6 + Math.PI / 6 * i;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootEnemyBullet)(state, enemy, window.BASE_ENEMY_BULLET_SPEED * Math.cos(theta), window.BASE_ENEMY_BULLET_SPEED * Math.sin(theta), { duration: 2000 });\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 20,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 15,\r\n        }, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x + 20 * Math.cos(enemy.theta),\r\n            y: enemy.y + 20 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/turret.ts?");

/***/ }),

/***/ "./app/enemies/urchin.ts":
/*!*******************************!*\
  !*** ./app/enemies/urchin.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   reefUrchin: () => (/* binding */ reefUrchin),\n/* harmony export */   urchin: () => (/* binding */ urchin)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\nconst urchin = {\r\n    name: 'Urchin',\r\n    statFactors: {\r\n        maxLife: 1.5,\r\n        armor: 1.5,\r\n        attacksPerSecond: 0.5,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 1.5 * window.BASE_DROP_CHANCE,\r\n    uniqueMultiplier: 2,\r\n    experienceFactor: 2,\r\n    radius: 24,\r\n    portalChance: 0.2,\r\n    portalDungeonType: 'reef',\r\n    update(state, enemy) {\r\n        const aggroRadius = 600;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        enemy.theta += 0.01;\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        if (enemy.modeTime % 200 === 0 && (enemy.modeTime % 2000) <= 1200) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletCircle)(state, enemy, enemy.theta, 3, 0.6 * window.BASE_ENEMY_BULLET_SPEED, { duration: 2000 });\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletAtHero)(state, enemy, window.BASE_ENEMY_BULLET_SPEED);\r\n        }\r\n    },\r\n    onDeath(state, enemy) {\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootBulletCircle)(state, enemy, enemy.theta, 12, 2 * window.BASE_ENEMY_BULLET_SPEED, { damage: enemy.damage * 2 });\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, enemy.baseColor);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta + 2 * Math.PI / 3),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta + 2 * Math.PI / 3),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta - 2 * Math.PI / 3),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta - 2 * Math.PI / 3),\r\n            radius: 5,\r\n        }, 'black');\r\n        context.strokeStyle = 'black';\r\n        context.beginPath();\r\n        context.lineWidth = 2;\r\n        for (let i = 0; i < 12; i++) {\r\n            const theta = 2 * Math.PI * i / 12;\r\n            const dx = Math.cos(theta), dy = Math.sin(theta);\r\n            context.moveTo(enemy.x + 20 * dx, enemy.y + 20 * dy);\r\n            context.lineTo(enemy.x + (26 + i % 2) * dx, enemy.y + (26 + i % 2) * dy);\r\n        }\r\n        context.stroke();\r\n    }\r\n};\r\nconst reefUrchin = {\r\n    ...urchin,\r\n    portalChance: 0,\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/urchin.ts?");

/***/ }),

/***/ "./app/enemies/wolf.ts":
/*!*****************************!*\
  !*** ./app/enemies/wolf.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wolf: () => (/* binding */ wolf)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_disc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/disc */ \"./app/utils/disc.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\n\r\nconst wolf = {\r\n    name: 'Wolf Man',\r\n    statFactors: { speed: 1.2 },\r\n    initialParams: { heading: 0 },\r\n    radius: 24,\r\n    update(state, enemy) {\r\n        if (enemy.mode === 'choose') {\r\n            const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, state.hero);\r\n            const aggroRadius = 600;\r\n            if (distance2 >= aggroRadius ** 2) {\r\n                return;\r\n            }\r\n            if (enemy.disc === state.hero.disc || (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.doCirclesIntersect)(enemy, state.hero.disc)) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.turnTowardsDirection)(state, enemy, Math.atan2(y, x));\r\n                if (distance2 >= 200 * 200) {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyInDirection)(state, enemy);\r\n                }\r\n                else if (enemy.modeTime >= 500) {\r\n                    if (Math.random() < 0.5) {\r\n                        enemy.setMode('prepareLunge');\r\n                    }\r\n                    else {\r\n                        enemy.setMode('snap');\r\n                    }\r\n                }\r\n            }\r\n            else if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.doCirclesIntersect)(enemy.disc, state.hero.disc)) {\r\n                const { x, y } = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.getConnectionPoint)(enemy.disc, state.hero.disc);\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.turnTowardsDirection)(state, enemy, Math.atan2(y - enemy.y, x - enemy.x));\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyInDirection)(state, enemy);\r\n            }\r\n            else {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyInDirection)(state, enemy);\r\n                if ((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.isEnemyPositionInvalid)(state, enemy)) {\r\n                    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_4__.getTargetVector)(enemy, enemy.disc);\r\n                    enemy.theta = Math.atan2(y, x) + (0.5 - Math.random()) * Math.PI / 3;\r\n                }\r\n            }\r\n        }\r\n        if (enemy.mode === 'prepareLunge') {\r\n            if (enemy.modeTime < 400) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.turnTowardsTarget)(state, enemy, state.hero);\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyInDirection)(state, enemy, enemy.theta + Math.PI, enemy.speed / 3);\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode('lunge');\r\n            }\r\n        }\r\n        if (enemy.mode === 'lunge') {\r\n            // Lunge attack with 4 parallel bullets around the wolf\r\n            if (enemy.modeTime <= 600) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.moveEnemyInDirection)(state, enemy, enemy.theta, 2 * enemy.speed);\r\n            }\r\n            if (enemy.modeTime === 200) {\r\n                for (let i = 0; i < 5; i++) {\r\n                    const vForward = { x: Math.cos(enemy.theta), y: Math.sin(enemy.theta) };\r\n                    const vUp = { x: Math.cos(enemy.theta - Math.PI / 2), y: Math.sin(enemy.theta - Math.PI / 2) };\r\n                    const theta = -Math.PI / 2 + i / 4 * Math.PI;\r\n                    const speed = 2 * enemy.speed + 50;\r\n                    const cos = Math.cos(theta);\r\n                    const sin = Math.sin(theta);\r\n                    const x = enemy.x + 60 * vForward.x * cos + 40 * vUp.x * sin;\r\n                    const y = enemy.y + 60 * vForward.y * cos + 40 * vUp.y * sin;\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootEnemyBullet)(state, enemy, speed * Math.cos(enemy.theta), speed * Math.sin(enemy.theta), {\r\n                        duration: 500,\r\n                        x, baseX: x,\r\n                        y, baseY: y,\r\n                    });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= 1500) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n        if (enemy.mode === 'snap') {\r\n            // Snapping attack with 6 spinning bullets 3 to a side, snapping together. 400ms tell before they move.\r\n            if (enemy.modeTime === 200 || enemy.modeTime === 600) {\r\n                const numTeeth = 4;\r\n                const maxRange = 160;\r\n                const teethSpacing = maxRange / numTeeth;\r\n                const warningTime = 400;\r\n                const snapTime = 100;\r\n                const snapAngle = Math.PI / 6;\r\n                for (let i = 1; i <= numTeeth; i++) {\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootCirclingBullet)(state, enemy, enemy.theta - snapAngle, i * teethSpacing, {\r\n                        warningTime: warningTime,\r\n                        duration: warningTime + snapTime,\r\n                        vTheta: 0,\r\n                        update(state, bullet) {\r\n                            (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateCirclingBullet)(state, bullet);\r\n                            if (bullet.warningTime <= 0) {\r\n                                bullet.vTheta = snapAngle * 1000 / snapTime;\r\n                            }\r\n                        }\r\n                    });\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.shootCirclingBullet)(state, enemy, enemy.theta + snapAngle, (i + 0.5) * teethSpacing, {\r\n                        warningTime: warningTime,\r\n                        duration: warningTime + snapTime,\r\n                        vTheta: 0,\r\n                        update(state, bullet) {\r\n                            (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_1__.updateCirclingBullet)(state, bullet);\r\n                            if (bullet.warningTime <= 0) {\r\n                                bullet.vTheta = -snapAngle * 1000 / snapTime;\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (enemy.modeTime >= 1500) {\r\n                enemy.setMode('choose');\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_3__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        const mouthCenter = { x: -30, y: 0 };\r\n        context.moveTo(mouthCenter.x, mouthCenter.y);\r\n        let frame = ((enemy.time % 400) / 200) | 0;\r\n        if (enemy.mode === 'snap') {\r\n            if (enemy.modeTime <= 600) {\r\n                frame = 3;\r\n            }\r\n            else if (enemy.modeTime >= 1000) {\r\n                frame = 0;\r\n            }\r\n            else {\r\n                frame = 2 + (((enemy.modeTime - 600) % 400) / 200) | 0;\r\n            }\r\n        }\r\n        else if (enemy.mode === 'prepareLunge') {\r\n            frame = 1;\r\n        }\r\n        else if (enemy.mode === 'lunge') {\r\n            if (enemy.modeTime <= 600) {\r\n                frame = 2;\r\n            }\r\n            else {\r\n                frame = 0;\r\n            }\r\n        }\r\n        const mouthAngle = [Math.PI / 24, Math.PI / 12, Math.PI / 6, Math.PI / 3][frame];\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.drawArc)(context, { x: 0, y: 0, radius: 90 }, mouthAngle, 2 * Math.PI - mouthAngle);\r\n        context.fill();\r\n        // Teeth\r\n        //context.fillStyle = 'red';\r\n        const bottomPoint = { x: 90 * Math.cos(mouthAngle), y: 90 * Math.sin(mouthAngle) };\r\n        const topPoint = { x: 90 * Math.cos(mouthAngle), y: 90 * Math.sin(-mouthAngle) };\r\n        for (let i = 0; i < 3; i++) {\r\n            const p = (4 - i) / 4 - 0.1;\r\n            context.save();\r\n            context.translate(mouthCenter.x + p * (bottomPoint.x - mouthCenter.x), mouthCenter.y + p * (bottomPoint.y - mouthCenter.y));\r\n            context.rotate(Math.atan2(bottomPoint.y - mouthCenter.y, bottomPoint.x - mouthCenter.x));\r\n            context.beginPath();\r\n            context.moveTo(-8, 0);\r\n            context.lineTo(8, 0);\r\n            context.lineTo(0, -32);\r\n            context.fill();\r\n            context.restore();\r\n            context.save();\r\n            context.translate(mouthCenter.x + p * (topPoint.x - mouthCenter.x), mouthCenter.y + p * (topPoint.y - mouthCenter.y));\r\n            context.rotate(Math.atan2(topPoint.y - mouthCenter.y, topPoint.x - mouthCenter.x));\r\n            context.beginPath();\r\n            context.moveTo(-8, 0);\r\n            context.lineTo(8, 0);\r\n            context.lineTo(0, 32);\r\n            context.fill();\r\n            context.restore();\r\n        }\r\n        // Black eye\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: -20, y: -50, radius: 15 }, 'black');\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/wolf.ts?");

/***/ }),

/***/ "./app/events/thrivingReef.ts":
/*!************************************!*\
  !*** ./app/events/thrivingReef.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   thrivingReef: () => (/* binding */ thrivingReef)\n/* harmony export */ });\n/* harmony import */ var app_enemies_crab__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enemies/crab */ \"./app/enemies/crab.ts\");\n/* harmony import */ var app_enemies_urchin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enemies/urchin */ \"./app/enemies/urchin.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst thrivingReef = {\r\n    name: 'Thriving Reef',\r\n    statFactors: {\r\n        attacksPerSecond: 0.5,\r\n        maxLife: window.EVENT_BOSS_MAX_LIFE_FACTOR * 0.75,\r\n        armor: 2,\r\n    },\r\n    initialParams: { attackTheta: 0 },\r\n    dropChance: 0,\r\n    uniqueMultiplier: 20,\r\n    experienceFactor: 20,\r\n    radius: 80,\r\n    portalChance: 1,\r\n    portalDungeonType: 'pearlTrove',\r\n    initialize(state, enemy) {\r\n        const disc = enemy.disc;\r\n        // Add holes to reef's disc.\r\n        for (let i = 0; i < 5; i++) {\r\n            const theta = -Math.PI / 2 + 2 * Math.PI * i / 5;\r\n            disc.holes.push({\r\n                x: disc.x + 3 / 5 * disc.radius * Math.cos(theta),\r\n                y: disc.y + 3 / 5 * disc.radius * Math.sin(theta),\r\n                topEdgeColor: disc.topEdgeColor,\r\n                bottomEdgeColor: disc.bottomEdgeColor,\r\n                radius: disc.radius / 5\r\n            });\r\n            // Add urchins between the holes\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(state, disc.x + 3 / 5 * disc.radius * Math.cos(theta + Math.PI), disc.y + 3 / 5 * disc.radius * Math.sin(theta + Math.PI), app_enemies_urchin__WEBPACK_IMPORTED_MODULE_1__.reefUrchin, enemy.level, disc);\r\n        }\r\n    },\r\n    update(state, enemy) {\r\n        const bulletShieldTime = enemy.time % 2000;\r\n        // The reef generates two circles of spinning bullets around it that move in\r\n        // opposite directions and have clustered bullets with gapbs between them.\r\n        if (bulletShieldTime < 1200) {\r\n            if (bulletShieldTime % 200 === 0) {\r\n                for (let i = 0; i < 5; i++) {\r\n                    const theta = -Math.PI / 2 + 2 * Math.PI * i / 5;\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.shootCirclingBullet)(state, enemy, 0, 2 * enemy.disc.radius / 5, {\r\n                        warningTime: 500,\r\n                        theta,\r\n                        vTheta: 2 * Math.PI / 5 / 2,\r\n                        duration: 2500\r\n                    });\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.shootCirclingBullet)(state, enemy, Math.PI, 4 * enemy.disc.radius / 5, {\r\n                        warningTime: 500,\r\n                        theta,\r\n                        vTheta: -2 * Math.PI / 10 / 2,\r\n                        duration: 2500\r\n                    });\r\n                    (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.shootCirclingBullet)(state, enemy, Math.PI, 4 * enemy.disc.radius / 5, {\r\n                        warningTime: 500,\r\n                        theta: theta + 2 * Math.PI / 10,\r\n                        vTheta: -2 * Math.PI / 10 / 2,\r\n                        duration: 2500\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        if (enemy.time % 5000 === 20) {\r\n            state.enemyBullets.push({\r\n                ...(0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.getBaseEnemyBullet)(state, enemy),\r\n                damageOverTime: 5 * enemy.damage,\r\n                radius: enemy.radius,\r\n                duration: 5000,\r\n            });\r\n        }\r\n        const disc = enemy.disc;\r\n        if (enemy.mode === 'choose' && enemy.life <= 0.9 * enemy.maxLife) {\r\n            enemy.setMode('phase1');\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(state, disc.x, disc.y - 80, app_enemies_crab__WEBPACK_IMPORTED_MODULE_0__.crab, enemy.level, disc, { warningTime: 1000 });\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(state, disc.x, disc.y + 80, app_enemies_crab__WEBPACK_IMPORTED_MODULE_0__.crab, enemy.level, disc, { warningTime: 1000 });\r\n        }\r\n        else if (enemy.mode === 'phase1' && enemy.life <= 0.7 * enemy.maxLife) {\r\n            enemy.setMode('phase2');\r\n        }\r\n        else if (enemy.mode === 'phase2' && enemy.life <= 0.5 * enemy.maxLife) {\r\n            enemy.setMode('phase3');\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(state, disc.x, disc.y - 80, app_enemies_crab__WEBPACK_IMPORTED_MODULE_0__.crab, enemy.level, disc, { warningTime: 1000 });\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(state, disc.x, disc.y + 80, app_enemies_crab__WEBPACK_IMPORTED_MODULE_0__.crab, enemy.level, disc, { warningTime: 1000 });\r\n        }\r\n        else if (enemy.mode === 'phase3' && enemy.life <= 0.3 * enemy.maxLife) {\r\n            enemy.setMode('phase4');\r\n        }\r\n        else if (enemy.mode === 'phase4' && enemy.life <= 0.1 * enemy.maxLife) {\r\n            enemy.setMode('phase5');\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(state, disc.x, disc.y - 80, app_enemies_crab__WEBPACK_IMPORTED_MODULE_0__.crab, enemy.level, disc, { warningTime: 1000 });\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(state, disc.x, disc.y + 80, app_enemies_crab__WEBPACK_IMPORTED_MODULE_0__.crab, enemy.level, disc, { warningTime: 1000 });\r\n        }\r\n        const aggroRadius = 600;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            if (enemy.mode === 'choose' || enemy.mode === 'phase1') {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.shootBulletAtHero)(state, enemy, 0.8 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                    duration: 2000,\r\n                    damage: 2 * enemy.damage,\r\n                    radius: 2 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                });\r\n            }\r\n            else if (enemy.mode === 'phase2' || enemy.mode === 'phase3') {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.shootBulletCircle)(state, enemy, enemy.params.attackTheta, 12, 0.8 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                    duration: 2000\r\n                });\r\n                enemy.params.attackTheta += Math.PI / 24;\r\n            }\r\n            else if (enemy.mode === 'phase3' || enemy.mode === 'phase4') {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.shootBulletAtHero)(state, enemy, 0.8 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                    duration: 2000,\r\n                    damage: 3 * enemy.damage,\r\n                    radius: 2 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                    onDeath(state, bullet) {\r\n                        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 6, window.BASE_ENEMY_BULLET_SPEED, {\r\n                            baseX: bullet.x,\r\n                            baseY: bullet.y,\r\n                            x: bullet.x,\r\n                            y: bullet.y,\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.shootBulletAtHero)(state, enemy, 0.8 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                    duration: 2000,\r\n                    damage: 3 * enemy.damage,\r\n                    radius: 2 * window.BASE_ENEMY_BULLET_RADIUS,\r\n                    update(state, bullet) {\r\n                        (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_3__.updateSimpleBullet)(state, bullet);\r\n                        if (bullet.time % 500 === 0) {\r\n                            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.shootBulletCircle)(state, enemy, Math.random() * 2 * Math.PI, 6, 0.5 * window.BASE_ENEMY_BULLET_SPEED, {\r\n                                baseX: bullet.x,\r\n                                baseY: bullet.y,\r\n                                x: bullet.x,\r\n                                y: bullet.y,\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    },\r\n    render: (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.renderNormalizedEnemy)((context, state, enemy) => {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, { x: 0, y: 0, radius: 100 }, 'black');\r\n        context.fillStyle = enemy.baseColor;\r\n        context.beginPath();\r\n        context.moveTo(100, 0);\r\n        for (let i = 1; i <= 5; i++) {\r\n            const theta = 4 * Math.PI * i / 5;\r\n            context.lineTo(100 * Math.cos(theta), 100 * Math.sin(theta));\r\n        }\r\n        context.fill();\r\n        for (let i = 1; i <= 5; i++) {\r\n            const theta = 4 * Math.PI * i / 5 + Math.PI;\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_2__.fillCircle)(context, {\r\n                x: 65 * Math.cos(theta),\r\n                y: 65 * Math.sin(theta),\r\n                radius: 30,\r\n            }, enemy.baseColor);\r\n        }\r\n    }),\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/events/thrivingReef.ts?");

/***/ }),

/***/ "./app/initialize.ts":
/*!***************************!*\
  !*** ./app/initialize.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeGame: () => (/* binding */ initializeGame)\n/* harmony export */ });\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n\r\n\r\n\r\nfunction initializeGame(state) {\r\n    (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__.bindMouseListeners)();\r\n    (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__.addContextMenuListeners)();\r\n    (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.addKeyboardListeners)();\r\n    (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-loading').style.display = 'none';\r\n    (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-gameContent').style.display = '';\r\n    state.gameHasBeenInitialized = true;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/initialize.ts?");

/***/ }),

/***/ "./app/inventory.ts":
/*!**************************!*\
  !*** ./app/inventory.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getHoverInventorySlot: () => (/* binding */ getHoverInventorySlot),\n/* harmony export */   getInventorySlots: () => (/* binding */ getInventorySlots),\n/* harmony export */   getSelectedInventorySlot: () => (/* binding */ getSelectedInventorySlot),\n/* harmony export */   getSelectedItem: () => (/* binding */ getSelectedItem),\n/* harmony export */   getSelectedItemArray: () => (/* binding */ getSelectedItemArray),\n/* harmony export */   updateInventory: () => (/* binding */ updateInventory)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n\r\n\r\n\r\n\r\n\r\nconst slotSpacing = window.SLOT_SIZE + window.SLOT_PADDING;\r\nconst weaponSlot = {\r\n    x: window.SLOT_PADDING,\r\n    y: window.CANVAS_HEIGHT - slotSpacing,\r\n    w: window.SLOT_SIZE,\r\n    h: window.SLOT_SIZE,\r\n};\r\nconst armorSlot = {\r\n    x: window.SLOT_PADDING,\r\n    y: window.CANVAS_HEIGHT - 2 * slotSpacing,\r\n    w: window.SLOT_SIZE,\r\n    h: window.SLOT_SIZE,\r\n};\r\nfunction getInventorySlots(state) {\r\n    const slots = [\r\n        {\r\n            ...weaponSlot,\r\n            item: state.hero.equipment.weapon,\r\n        },\r\n        {\r\n            ...armorSlot,\r\n            item: state.hero.equipment.armor,\r\n        },\r\n    ];\r\n    let slotCount = state.paused ? 10 : 4;\r\n    let y = window.CANVAS_HEIGHT - 3 * slotSpacing;\r\n    for (let i = 0; i < slotCount; i++) {\r\n        const x = window.CANVAS_WIDTH - (i + 1) * slotSpacing;\r\n        slots.push({\r\n            x,\r\n            y,\r\n            w: window.SLOT_SIZE,\r\n            h: window.SLOT_SIZE,\r\n            item: state.hero.enchantments[i],\r\n        });\r\n        slots.push({\r\n            x,\r\n            y: y + slotSpacing,\r\n            w: window.SLOT_SIZE,\r\n            h: window.SLOT_SIZE,\r\n            item: state.hero.weapons[i],\r\n        });\r\n        slots.push({\r\n            x,\r\n            y: y + 2 * slotSpacing,\r\n            w: window.SLOT_SIZE,\r\n            h: window.SLOT_SIZE,\r\n            item: state.hero.armors[i],\r\n        });\r\n    }\r\n    return slots;\r\n}\r\nfunction getSelectedItemArray(state) {\r\n    if (state.menuRow === 0) {\r\n        return state.hero.enchantments;\r\n    }\r\n    if (state.menuRow === 1) {\r\n        return state.hero.weapons;\r\n    }\r\n    return state.hero.armors;\r\n}\r\nfunction getSelectedItem(state) {\r\n    if (state.menuEquipmentSelected) {\r\n        if (state.menuRow === 0) {\r\n            return state.hero.equipment.armor;\r\n        }\r\n        return state.hero.equipment.weapon;\r\n    }\r\n    return getSelectedItemArray(state)[getFixedMenuColumn(state)];\r\n}\r\nfunction getSelectedInventorySlot(state) {\r\n    const item = getSelectedItem(state);\r\n    if (item) {\r\n        return getInventorySlots(state).find(s => s.item === item);\r\n    }\r\n    // If not item is selected, return an empty slot that makes sense, either the\r\n    // empty equipment slot, or the right most slot in that inventory row.\r\n    if (state.menuEquipmentSelected) {\r\n        if (state.menuRow === 0) {\r\n            return armorSlot;\r\n        }\r\n        return weaponSlot;\r\n    }\r\n    return {\r\n        x: window.CANVAS_WIDTH - slotSpacing,\r\n        y: window.CANVAS_HEIGHT - 3 * slotSpacing + state.menuRow * slotSpacing,\r\n        w: window.SLOT_SIZE,\r\n        h: window.SLOT_SIZE,\r\n    };\r\n}\r\nfunction removeEnchantment(state, enchantment) {\r\n    const index = state.hero.enchantments.indexOf(enchantment);\r\n    if (index < 0) {\r\n        return false;\r\n    }\r\n    state.hero.enchantments.splice(index, 1);\r\n    return true;\r\n}\r\nfunction activateItem(state, item) {\r\n    // Cannot use items while in the middle of a skill.\r\n    if (state.hero.roll || state.hero.guardSkill.duration || state.hero.attackChargeLevel > 1) {\r\n        return;\r\n    }\r\n    const activeEnchantment = state.hero.activeEnchantment;\r\n    delete state.hero.activeEnchantment;\r\n    if (activeEnchantment) {\r\n        if (item.type !== 'enchantment') {\r\n            if ((0,app_enchantments__WEBPACK_IMPORTED_MODULE_1__.applyEnchantmentToEquipment)(activeEnchantment, item)) {\r\n                removeEnchantment(state, activeEnchantment);\r\n                (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.setDerivedHeroStats)(state);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (item.type === 'weapon') {\r\n        const index = state.hero.weapons.indexOf(item);\r\n        if (index >= 0) {\r\n            // Reset charge on changing weapons.\r\n            state.hero.chargingLevel = 1;\r\n            state.hero.attackChargeLevel = 1;\r\n            state.hero.attackChargeDuration = 0;\r\n            state.hero.weapons[index] = state.hero.equipment.weapon;\r\n            state.hero.equipment.weapon = item;\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.setDerivedHeroStats)(state);\r\n        }\r\n    }\r\n    else if (item.type === 'armor') {\r\n        const index = state.hero.armors.indexOf(item);\r\n        if (index >= 0) {\r\n            if (state.hero.equipment.armor) {\r\n                state.hero.armors[index] = state.hero.equipment.armor;\r\n            }\r\n            else {\r\n                state.hero.armors.splice(index, 1);\r\n            }\r\n            state.hero.equipment.armor = item;\r\n            state.hero.guardSkill = {\r\n                cooldownTime: 0,\r\n                charges: 0,\r\n                time: 0,\r\n            };\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.setDerivedHeroStats)(state);\r\n        }\r\n    }\r\n    else if (item.type === 'enchantment') {\r\n        state.hero.activeEnchantment = item;\r\n    }\r\n}\r\nfunction sellItem(state, item) {\r\n    // cancel enchantment when selling an item.\r\n    delete state.hero.activeEnchantment;\r\n    if (item.type === 'weapon') {\r\n        const index = state.hero.weapons.indexOf(item);\r\n        if (index >= 0) {\r\n            state.hero.weapons.splice(index, 1);\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.gainItemExperience)(state, item);\r\n        }\r\n    }\r\n    else if (item.type === 'armor') {\r\n        const index = state.hero.armors.indexOf(item);\r\n        if (index >= 0) {\r\n            state.hero.armors.splice(index, 1);\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.gainItemExperience)(state, item);\r\n        }\r\n    }\r\n    else if (item.type === 'enchantment') {\r\n        if (removeEnchantment(state, item)) {\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.gainItemExperience)(state, item);\r\n        }\r\n    }\r\n}\r\nfunction getFixedMenuColumn(state) {\r\n    // Keep the column in bounds as the number of items changes.\r\n    const itemArray = getSelectedItemArray(state);\r\n    return Math.max(0, Math.min(itemArray.length - 1, state.menuColumn));\r\n}\r\nfunction getHoverInventorySlot(state) {\r\n    for (const slot of getInventorySlots(state)) {\r\n        if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.isPointInRect)(slot, state.mouse)) {\r\n            return slot;\r\n        }\r\n    }\r\n}\r\nfunction updateInventory(state) {\r\n    var _a;\r\n    if (state.isUsingKeyboard) {\r\n        const hoverItem = (_a = getHoverInventorySlot(state)) === null || _a === void 0 ? void 0 : _a.item;\r\n        if (hoverItem) {\r\n            if (state.mouse.wasPressed) {\r\n                state.hero.isShooting = false;\r\n                activateItem(state, hoverItem);\r\n            }\r\n            else if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL)) {\r\n                sellItem(state, hoverItem);\r\n            }\r\n        }\r\n        else if (state.mouse.wasPressed) {\r\n            // Active enchantment is cleared if the mouse is clicked off an item.\r\n            delete state.hero.activeEnchantment;\r\n        }\r\n    }\r\n    else if (state.isUsingXbox && state.paused) {\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP)) {\r\n            state.menuRow--;\r\n        }\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN)) {\r\n            state.menuRow++;\r\n        }\r\n        if (state.menuEquipmentSelected) {\r\n            state.menuRow = (state.menuRow + 2) % 2;\r\n        }\r\n        else {\r\n            state.menuRow = (state.menuRow + 3) % 3;\r\n        }\r\n        const itemArray = getSelectedItemArray(state);\r\n        if (state.menuEquipmentSelected) {\r\n            if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT)) {\r\n                state.menuEquipmentSelected = false;\r\n                state.menuColumn = 0;\r\n            }\r\n            else if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT)) {\r\n                state.menuEquipmentSelected = false;\r\n                state.menuColumn = Math.min(9, Math.max(0, itemArray.length - 1));\r\n            }\r\n        }\r\n        else {\r\n            if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT)) {\r\n                // Items are displayed right to left, so this is inverted.\r\n                state.menuColumn++;\r\n                if (state.menuColumn >= itemArray.length) {\r\n                    state.menuEquipmentSelected = true;\r\n                    state.menuRow = 0;\r\n                }\r\n            }\r\n            else if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT)) {\r\n                // Items are displayed right to left, so this is inverted.\r\n                state.menuColumn--;\r\n                if (state.menuColumn < 0) {\r\n                    state.menuEquipmentSelected = true;\r\n                    state.menuRow = 0;\r\n                }\r\n            }\r\n            state.menuColumn = getFixedMenuColumn(state);\r\n        }\r\n        const selectedItem = getSelectedItem(state);\r\n        if (!selectedItem) {\r\n            return;\r\n        }\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE)) {\r\n            activateItem(state, selectedItem);\r\n        }\r\n        else if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL)) {\r\n            sellItem(state, selectedItem);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/inventory.ts?");

/***/ }),

/***/ "./app/loot.ts":
/*!*********************!*\
  !*** ./app/loot.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkToDropBasicLoot: () => (/* binding */ checkToDropBasicLoot),\n/* harmony export */   dropArmorLoot: () => (/* binding */ dropArmorLoot),\n/* harmony export */   dropEnchantmentLoot: () => (/* binding */ dropEnchantmentLoot),\n/* harmony export */   dropWeaponLoot: () => (/* binding */ dropWeaponLoot),\n/* harmony export */   rollArmor: () => (/* binding */ rollArmor),\n/* harmony export */   rollWeapon: () => (/* binding */ rollWeapon)\n/* harmony export */ });\n/* harmony import */ var app_armor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/armor */ \"./app/armor.ts\");\n/* harmony import */ var app_uniqueEnchantments__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/uniqueEnchantments */ \"./app/uniqueEnchantments.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_item__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/item */ \"./app/utils/item.ts\");\n/* harmony import */ var app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/rollWithMissBonus */ \"./app/utils/rollWithMissBonus.ts\");\n/* harmony import */ var app_render_renderInventory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/render/renderInventory */ \"./app/render/renderInventory.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction rollEnchantmentSlots(state, item) {\r\n    item.enchantmentSlots = [];\r\n    item.bonusEnchantmentSlots = [];\r\n    (0,app_utils_item__WEBPACK_IMPORTED_MODULE_3__.addEnchantmentSlot)(item);\r\n    if (item.level >= 5 && (0,app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_4__.rollWithMissBonus)(state, 'twoSockets', 0.1)) {\r\n        (0,app_utils_item__WEBPACK_IMPORTED_MODULE_3__.addEnchantmentSlot)(item);\r\n        if (item.level >= 20 && (0,app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_4__.rollWithMissBonus)(state, 'threeSockets', 0.1)) {\r\n            (0,app_utils_item__WEBPACK_IMPORTED_MODULE_3__.addEnchantmentSlot)(item);\r\n            if (item.level >= 50 && (0,app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_4__.rollWithMissBonus)(state, 'fourSockets', 0.1)) {\r\n                (0,app_utils_item__WEBPACK_IMPORTED_MODULE_3__.addEnchantmentSlot)(item);\r\n            }\r\n        }\r\n    }\r\n}\r\n// Rolls for a randomly generated armor item given type+level.\r\nfunction rollArmor(state, armorType, level, uniqueMultiplier) {\r\n    const armor = (0,app_utils_item__WEBPACK_IMPORTED_MODULE_3__.generateArmor)(armorType, level);\r\n    rollEnchantmentSlots(state, armor);\r\n    (0,app_uniqueEnchantments__WEBPACK_IMPORTED_MODULE_1__.checkToAddGlobalUniqueEnchantments)(state, armor, uniqueMultiplier);\r\n    (0,app_utils_item__WEBPACK_IMPORTED_MODULE_3__.applyUniqueItemEnchantments)(armor);\r\n    return armor;\r\n}\r\n// Rolls for a randomly generated armor item given type+level.\r\nfunction rollWeapon(state, weaponType, level, uniqueMultiplier) {\r\n    const weapon = (0,app_utils_item__WEBPACK_IMPORTED_MODULE_3__.generateWeapon)(weaponType, level);\r\n    rollEnchantmentSlots(state, weapon);\r\n    (0,app_uniqueEnchantments__WEBPACK_IMPORTED_MODULE_1__.checkToAddGlobalUniqueEnchantments)(state, weapon, uniqueMultiplier);\r\n    (0,app_utils_item__WEBPACK_IMPORTED_MODULE_3__.applyUniqueItemEnchantments)(weapon);\r\n    return weapon;\r\n}\r\nfunction checkToDropBasicLoot(state, source) {\r\n    var _a;\r\n    if ((0,app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_4__.rollWithMissBonus)(state, 'dropItem', ((_a = source.definition.dropChance) !== null && _a !== void 0 ? _a : window.BASE_DROP_CHANCE) + state.hero.dropChance)) {\r\n        let targetLevel = source.level;\r\n        let bonusLevelChance = state.hero.dropChance;\r\n        if (bonusLevelChance > 0) {\r\n            while ((0,app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_4__.rollWithMissBonus)(state, 'playerBonusItemLevel', bonusLevelChance)) {\r\n                targetLevel++;\r\n                bonusLevelChance--;\r\n            }\r\n        }\r\n        while ((0,app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_4__.rollWithMissBonus)(state, 'defaultBonusItemLevel', 0.1)) {\r\n            targetLevel++;\r\n        }\r\n        targetLevel = Math.min(100, targetLevel);\r\n        if ((0,app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_4__.rollWithMissBonus)(state, 'dropArmor', 0.25)) {\r\n            dropArmorLoot(state, source, targetLevel);\r\n        }\r\n        else {\r\n            dropWeaponLoot(state, source, targetLevel);\r\n        }\r\n    }\r\n}\r\nfunction dropArmorLoot(state, source, level) {\r\n    var _a;\r\n    if (!source.disc) {\r\n        return;\r\n    }\r\n    const armorType = app_utils_Random__WEBPACK_IMPORTED_MODULE_7__[\"default\"].element(app_armor__WEBPACK_IMPORTED_MODULE_0__.armorTypes);\r\n    const armor = rollArmor(state, armorType, level, (_a = source.definition.uniqueMultiplier) !== null && _a !== void 0 ? _a : 1);\r\n    if (!armor) {\r\n        return;\r\n    }\r\n    source.disc.loot.push({\r\n        type: 'armor',\r\n        x: source.x,\r\n        y: source.y,\r\n        disc: source.disc,\r\n        radius: 12,\r\n        armor,\r\n        activate(state) {\r\n            state.hero.armors.push(this.armor);\r\n        },\r\n        render(context, state) {\r\n            if (this === state.activeLoot) {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_5__.renderArmorLong)(context, this.x, this.y, this.armor);\r\n            }\r\n            else {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_5__.renderArmorShort)(context, this.x, this.y, this.armor);\r\n            }\r\n        },\r\n        sell() {\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_2__.gainItemExperience)(state, this.armor);\r\n        }\r\n    });\r\n}\r\nfunction dropWeaponLoot(state, source, level) {\r\n    var _a;\r\n    if (!source.disc) {\r\n        return;\r\n    }\r\n    const weaponType = app_utils_Random__WEBPACK_IMPORTED_MODULE_7__[\"default\"].element(app_weapons__WEBPACK_IMPORTED_MODULE_6__.weaponTypes);\r\n    const weapon = rollWeapon(state, weaponType, level, (_a = source.definition.uniqueMultiplier) !== null && _a !== void 0 ? _a : 1);\r\n    if (!weapon) {\r\n        return;\r\n    }\r\n    source.disc.loot.push({\r\n        type: 'weapon',\r\n        x: source.x,\r\n        y: source.y,\r\n        disc: source.disc,\r\n        radius: 12,\r\n        weapon,\r\n        activate(state) {\r\n            state.hero.weapons.push(this.weapon);\r\n        },\r\n        render(context, state) {\r\n            if (this === state.activeLoot) {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_5__.renderWeaponLong)(context, this.x, this.y, this.weapon);\r\n            }\r\n            else {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_5__.renderWeaponShort)(context, this.x, this.y, this.weapon);\r\n            }\r\n        },\r\n        sell() {\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_2__.gainItemExperience)(state, this.weapon);\r\n        }\r\n    });\r\n}\r\nfunction dropEnchantmentLoot(state, disc, { x, y }, enchantment) {\r\n    if (!disc) {\r\n        return;\r\n    }\r\n    disc.loot.push({\r\n        type: 'enchantment',\r\n        disc,\r\n        x,\r\n        y,\r\n        radius: 12,\r\n        enchantment,\r\n        activate(state) {\r\n            state.hero.enchantments.push(this.enchantment);\r\n        },\r\n        render(context, state) {\r\n            if (this === state.activeLoot) {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_5__.renderEnchantmentLong)(context, this.x, this.y, this.enchantment);\r\n            }\r\n            else {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_5__.renderEnchantmentShort)(context, this.x, this.y, this.enchantment);\r\n            }\r\n        },\r\n        sell() {\r\n            (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_2__.gainItemExperience)(state, this.enchantment);\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/loot.ts?");

/***/ }),

/***/ "./app/render/renderGame.ts":
/*!**********************************!*\
  !*** ./app/render/renderGame.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   render: () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_render_renderHUD__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderHUD */ \"./app/render/renderHUD.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_guardSkill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/guardSkill */ \"./app/utils/guardSkill.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nfunction render(context, state) {\r\n    var _a, _b, _c, _d, _e, _f, _g, _h;\r\n    context.fillStyle = '#000';\r\n    context.fillRect(0, 0, window.CANVAS_WIDTH, window.CANVAS_HEIGHT);\r\n    context.save();\r\n    context.translate(window.FIELD_CENTER.x - state.hero.x, window.FIELD_CENTER.y - state.hero.y);\r\n    state.visibleDiscs.sort((A, B) => A.y - B.y);\r\n    const normalDiscs = state.visibleDiscs.filter(d => !d.boss);\r\n    const bossDiscs = state.visibleDiscs.filter(d => d.boss);\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDiscEdge1(context, disc);\r\n    }\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDiscEdge2(context, disc);\r\n    }\r\n    for (const disc of normalDiscs) {\r\n        renderDisc(context, disc);\r\n        renderDiscCenter(context, disc);\r\n    }\r\n    //for (const disc of normalDiscs) {\r\n    //}\r\n    // Render tops of boss discs over other discs to make the arena edge clear.\r\n    for (const disc of bossDiscs) {\r\n        renderDisc(context, disc);\r\n    }\r\n    for (const disc of bossDiscs) {\r\n        renderDiscCenter(context, disc);\r\n    }\r\n    for (const hole of state.holes) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, hole, 'black');\r\n        let theta = Math.atan2(discDepth / 4, Math.sqrt(hole.radius ** 2 - discDepth ** 2 / 16));\r\n        context.fillStyle = (_a = hole.topEdgeColor) !== null && _a !== void 0 ? _a : '#BBB';\r\n        context.beginPath();\r\n        context.arc(hole.x, hole.y - 2, hole.radius, 0, -Math.PI, true);\r\n        //context.lineTo(hole.x - hole.radius, hole.y + discDepth / 2);\r\n        //125 0.1606906529519106\r\n        // 75 0.26993279583340346\r\n        // 100 0.2013579207903308\r\n        //console.log(hole.radius, theta);\r\n        context.arc(hole.x, hole.y + discDepth / 2, hole.radius, -Math.PI + theta, -theta);\r\n        context.fill();\r\n        context.beginPath();\r\n        context.fillStyle = (_b = hole.bottomEdgeColor) !== null && _b !== void 0 ? _b : '#888';\r\n        context.arc(hole.x, hole.y + discDepth / 2 - 2, hole.radius, -theta, -Math.PI + theta, true);\r\n        theta = Math.atan2(discDepth / 2, Math.sqrt(hole.radius ** 2 - discDepth ** 2 / 4));\r\n        //context.lineTo(hole.x - hole.radius, hole.y + discDepth);\r\n        context.arc(hole.x, hole.y + discDepth, hole.radius, -Math.PI + theta, -theta);\r\n        context.fill();\r\n        /*context.save();\r\n            context.globalAlpha *= 0.4;\r\n            context.fillStyle = 'black'\r\n            context.beginPath();\r\n            context.arc(hole.x, hole.y, hole.radius, -Math.PI / 2, Math.PI / 6, true);\r\n            context.fill();\r\n        context.restore();*/\r\n    }\r\n    for (const portal of state.portals) {\r\n        renderPortal(context, state, portal);\r\n    }\r\n    if ((_d = (_c = state.hero) === null || _c === void 0 ? void 0 : _c.disc) === null || _d === void 0 ? void 0 : _d.boss) {\r\n        context.save();\r\n        context.translate(-(window.FIELD_CENTER.x - state.hero.x), -(window.FIELD_CENTER.y - state.hero.y));\r\n        context.globalAlpha *= 0.6;\r\n        context.fillStyle = '#000';\r\n        context.fillRect(0, 0, window.CANVAS_WIDTH, window.CANVAS_HEIGHT);\r\n        context.restore();\r\n        renderDisc(context, state.hero.disc);\r\n        renderDiscCenter(context, state.hero.disc);\r\n    }\r\n    for (const bullet of state.enemyBullets) {\r\n        (_e = bullet.renderFloorBefore) === null || _e === void 0 ? void 0 : _e.call(bullet, context, state, bullet);\r\n    }\r\n    for (const bullet of state.enemyBullets) {\r\n        (_f = bullet.renderFloor) === null || _f === void 0 ? void 0 : _f.call(bullet, context, state, bullet);\r\n    }\r\n    for (const loot of state.loot) {\r\n        if (loot === state.activeLoot) {\r\n            continue;\r\n        }\r\n        loot.render(context, state);\r\n    }\r\n    for (const bullet of state.heroBullets) {\r\n        renderHeroBullet(context, bullet);\r\n    }\r\n    (_g = state.activeLoot) === null || _g === void 0 ? void 0 : _g.render(context, state);\r\n    for (const enemy of state.enemies) {\r\n        enemy.definition.render(context, state, enemy);\r\n    }\r\n    for (const enemy of state.enemies) {\r\n        renderEnemyLifebar(context, enemy);\r\n    }\r\n    for (const bullet of state.enemyBullets) {\r\n        if (bullet.render) {\r\n            (_h = bullet.render) === null || _h === void 0 ? void 0 : _h.call(bullet, context, state, bullet);\r\n        }\r\n        else {\r\n            renderEnemyBullet(context, bullet);\r\n        }\r\n    }\r\n    renderHero(context, state, state.hero);\r\n    for (const fieldText of state.fieldText) {\r\n        renderFieldText(context, fieldText);\r\n    }\r\n    context.restore();\r\n    context.beginPath();\r\n    context.rect(0, 0, window.CANVAS_WIDTH, window.CANVAS_HEIGHT);\r\n    context.arc(window.FIELD_CENTER.x, window.FIELD_CENTER.y, state.sightRadius, 0, 2 * Math.PI, true);\r\n    context.fillStyle = '#000';\r\n    context.fill();\r\n    if (state.isUsingXbox) {\r\n        const [dx, dy] = (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_2__.getRightAnalogDeltas)(state);\r\n        /*const x = window.FIELD_CENTER.x + dx * 100, y = window.FIELD_CENTER.y + dy * 100;\r\n        context.beginPath();\r\n        context.arc(x, y, 15, 0, 2 * Math.PI, true);\r\n        context.strokeStyle = 'blue';\r\n        context.stroke();*/\r\n        /*context.beginPath();\r\n        context.arc(x, y, 2, 0, 2 * Math.PI, true);\r\n        context.fillStyle = 'blue';\r\n        context.fill();*/\r\n        context.save();\r\n        context.beginPath();\r\n        context.setLineDash([10, 15]);\r\n        context.strokeStyle = 'blue';\r\n        context.moveTo(window.FIELD_CENTER.x, window.FIELD_CENTER.y);\r\n        context.lineTo(window.SIGHT_RADIUS * dx + window.FIELD_CENTER.x, window.SIGHT_RADIUS * dy + window.FIELD_CENTER.y);\r\n        context.stroke();\r\n        context.restore();\r\n    }\r\n    (0,app_render_renderHUD__WEBPACK_IMPORTED_MODULE_1__.renderHUD)(context, state);\r\n}\r\nfunction renderPortal(context, state, portal) {\r\n    const isActive = !state.activeLoot && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.doCirclesIntersect)(state.hero, portal);\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, portal, isActive ? '#BBB' : '#666');\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { ...portal, radius: portal.radius * 0.9 }, '#000');\r\n    context.fillStyle = isActive ? '#FFF' : '#88F';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'center';\r\n    context.font = '16px sans-serif';\r\n    if (portal.dungeon) {\r\n        context.fillText(`Level ` + portal.dungeon.level, portal.x, portal.y - 10);\r\n        context.fillText(portal.name, portal.x, portal.y + 10);\r\n    }\r\n    else {\r\n        context.fillText(portal.name, portal.x, portal.y);\r\n    }\r\n}\r\nfunction renderEnemyLifebar(context, enemy) {\r\n    if (enemy.life < enemy.maxLife && !enemy.isInvulnerable) {\r\n        let color = '#0F0';\r\n        if (enemy.life <= enemy.maxLife / 4) {\r\n            color = '#F00';\r\n        }\r\n        else if (enemy.life <= enemy.maxLife / 2) {\r\n            color = '#F80';\r\n        }\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.renderBar)(context, { x: enemy.x - 15, y: enemy.y - enemy.radius - 8, w: 30, h: 6 }, enemy.life / enemy.maxLife, color);\r\n    }\r\n}\r\nfunction renderEnemyBullet(context, bullet) {\r\n    const baseColor = bullet.damageOverTime ? '#CF4' : 'red';\r\n    let fill = baseColor;\r\n    if (bullet.damageOverTime) {\r\n        fill = context.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bullet.radius);\r\n        fill.addColorStop(0, '#CF4');\r\n        fill.addColorStop(0.8, 'red');\r\n    }\r\n    if (bullet.warningTime > 0) {\r\n        context.fillStyle = 'red';\r\n        context.beginPath();\r\n        context.arc(bullet.x, bullet.y, bullet.radius, 0, 2 * Math.PI);\r\n        context.arc(bullet.x, bullet.y, bullet.radius - 2, 0, 2 * Math.PI, true);\r\n        context.fill();\r\n    }\r\n    else {\r\n        if (bullet.radius > 15) {\r\n            context.save();\r\n            context.globalAlpha *= Math.max(0.3, 0.8 - (bullet.radius - 15) / 45);\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, bullet, fill);\r\n            context.restore();\r\n        }\r\n        else {\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, bullet, fill);\r\n        }\r\n        if (bullet.damageOverTime) {\r\n            context.lineWidth = 1;\r\n            context.arc(bullet.x, bullet.y, bullet.radius, 0, 2 * Math.PI);\r\n            context.strokeStyle = baseColor;\r\n            context.stroke();\r\n        }\r\n    }\r\n}\r\nfunction renderHeroBullet(context, bullet) {\r\n    const baseColor = bullet.damageOverTime ? '#4FC' : 'green';\r\n    if (bullet.warningTime > 0) {\r\n        context.fillStyle = baseColor;\r\n        context.beginPath();\r\n        context.arc(bullet.x, bullet.y, bullet.radius, 0, 2 * Math.PI);\r\n        context.arc(bullet.x, bullet.y, bullet.radius - 2, 0, 2 * Math.PI, true);\r\n        context.fill();\r\n    }\r\n    else {\r\n        if (bullet.radius > 15) {\r\n            context.save();\r\n            context.globalAlpha *= Math.max(0.2, 0.9 - (bullet.radius - 15) / 45);\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, bullet, baseColor);\r\n            context.restore();\r\n        }\r\n        else {\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, bullet, baseColor);\r\n        }\r\n    }\r\n    context.beginPath();\r\n    context.lineWidth = 1;\r\n    context.strokeStyle = 'white';\r\n    context.arc(bullet.x, bullet.y, bullet.radius, 0, 2 * Math.PI);\r\n    context.stroke();\r\n}\r\nfunction renderHero(context, state, hero) {\r\n    const { armor, weapon } = hero.equipment;\r\n    if (hero.attackChargeDuration > 0 && hero.attackChargeLevel >= 2) {\r\n        // While charged attack still applies, draw an orange halo.\r\n        context.save();\r\n        context.globalAlpha *= (0.6 + 0.15 * Math.sin(state.fieldTime / 100));\r\n        const chargeRadius = hero.radius * 1.3;\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: hero.x, y: hero.y, radius: chargeRadius }, 'orange');\r\n        context.restore();\r\n    }\r\n    else if (hero.chargingLevel >= 2) {\r\n        context.save();\r\n        const color = hero.chargingLevel >= 2 ? 'red' : 'orange';\r\n        context.globalAlpha *= (0.45 + 0.15 * Math.sin(state.fieldTime / 100));\r\n        const chargeRadius = 2 * Math.floor(hero.chargingLevel);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: hero.x, y: hero.y, radius: hero.radius + chargeRadius }, color);\r\n        context.restore();\r\n    }\r\n    context.save();\r\n    if (hero.life <= 0) {\r\n        context.globalAlpha *= 0.5;\r\n    }\r\n    else if (hero.recentDamageTaken) {\r\n        const fadeAmount = 0.2 + 0.3 * hero.recentDamageTaken / (hero.maxLife / 2);\r\n        //context.globalAlpha *= (1 - fadeAmount / 2 + fadeAmount * Math.sin(state.fieldTime / 80));\r\n        context.globalAlpha *= (1 - fadeAmount);\r\n    }\r\n    let heroColor = 'blue';\r\n    if (hero.guardSkill.duration && armor.armorType === 'heavyArmor') {\r\n        heroColor = 'lightBlue';\r\n    }\r\n    if (hero.roll) {\r\n        context.globalAlpha *= 0.5;\r\n    }\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, hero, heroColor);\r\n    context.beginPath();\r\n    context.strokeStyle = 'lightblue';\r\n    context.lineWidth = 3;\r\n    if (armor.armorType === 'heavyArmor') {\r\n        context.lineWidth = 5;\r\n    }\r\n    else if (armor.armorType === 'lightArmor') {\r\n        context.lineWidth = 1;\r\n    }\r\n    context.arc(hero.x, hero.y, hero.radius * 0.8, 0, 2 * Math.PI);\r\n    context.stroke();\r\n    // window.TODO: use right analog stick deltas if playing with game pad instead of state.mouse for target.\r\n    const target = {\r\n        x: state.hero.x + state.mouse.x - window.FIELD_CENTER.x,\r\n        y: state.hero.y + state.mouse.y - window.FIELD_CENTER.y,\r\n    };\r\n    if (weapon.weaponType === 'wand') {\r\n        const bullet = weapon.getShots(state, weapon)[0].generateBullet(state, hero, weapon, target);\r\n        if (bullet) {\r\n            const mx = hero.x + state.mouse.x - window.FIELD_CENTER.x, my = hero.y + state.mouse.y - window.FIELD_CENTER.y;\r\n            const dx = bullet.x - mx, dy = bullet.y - my;\r\n            const radius = Math.sqrt(dx * dx + dy * dy);\r\n            context.beginPath();\r\n            context.lineWidth = 1;\r\n            context.strokeStyle = 'white';\r\n            context.arc(mx, my, radius, 0, 2 * Math.PI);\r\n            context.stroke();\r\n        }\r\n    }\r\n    else if (weapon.weaponType === 'morningStar') {\r\n        const bullet = weapon.getShots(state, weapon)[0].generateBullet(state, hero, weapon, target);\r\n        if (bullet) {\r\n            const dx = bullet.x - hero.x, dy = bullet.y - hero.y;\r\n            const radius = Math.sqrt(dx * dx + dy * dy);\r\n            context.beginPath();\r\n            context.lineWidth = 1;\r\n            context.strokeStyle = 'white';\r\n            context.arc(hero.x, hero.y, radius, 0, 2 * Math.PI);\r\n            context.stroke();\r\n        }\r\n    }\r\n    else {\r\n        for (const shot of weapon.getShots(state, weapon)) {\r\n            const bullet = shot.generateBullet(state, hero, hero.equipment.weapon, target);\r\n            if (!bullet) {\r\n                continue;\r\n            }\r\n            bullet.x += bullet.vx / 20;\r\n            bullet.y += bullet.vy / 20;\r\n            //bullet.radius /= 2;\r\n            context.beginPath();\r\n            context.lineWidth = 1;\r\n            context.strokeStyle = 'white';\r\n            context.arc(bullet.x, bullet.y, bullet.radius, 0, 2 * Math.PI);\r\n            context.stroke();\r\n            //fillCircle(context, bullet, 'black');\r\n        }\r\n    }\r\n    if (hero.guardSkill.duration && armor.armorType === 'mediumArmor') {\r\n        context.globalAlpha *= 0.5;\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, (0,app_utils_guardSkill__WEBPACK_IMPORTED_MODULE_4__.getDispersionCircle)(state), 'orange');\r\n    }\r\n    context.restore();\r\n    const shaveRadius = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_5__.getHeroShaveRadius)(state);\r\n    if (shaveRadius > 0) {\r\n        context.save();\r\n        context.beginPath();\r\n        context.lineWidth = 0;\r\n        context.setLineDash([5, 10]);\r\n        context.strokeStyle = 'blue';\r\n        context.arc(hero.x, hero.y, hero.radius + shaveRadius, 0, 2 * Math.PI);\r\n        context.stroke();\r\n        context.restore();\r\n    }\r\n}\r\nfunction renderFieldText(context, fieldText) {\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'center';\r\n    let size = 20;\r\n    if (fieldText.time < 300) {\r\n        size = 50 - 25 * fieldText.time / 300;\r\n    }\r\n    context.font = `${size}px bold sans-serif`;\r\n    if (fieldText.borderColor) {\r\n        context.fillStyle = fieldText.borderColor;\r\n        /*context.fillText(fieldText.text, fieldText.x - 1, fieldText.y - 1);\r\n        context.fillText(fieldText.text, fieldText.x - 1, fieldText.y + 1);\r\n        context.fillText(fieldText.text, fieldText.x + 1, fieldText.y - 1);\r\n        context.fillText(fieldText.text, fieldText.x + 1, fieldText.y + 1);*/\r\n        context.fillText(fieldText.text, fieldText.x - 1, fieldText.y);\r\n        context.fillText(fieldText.text, fieldText.x + 1, fieldText.y);\r\n        context.fillText(fieldText.text, fieldText.x, fieldText.y + 1);\r\n        context.fillText(fieldText.text, fieldText.x, fieldText.y - 1);\r\n    }\r\n    /*if (fieldText.borderColor) {\r\n        context.strokeStyle = fieldText.borderColor;\r\n        context.strokeText(fieldText.text, fieldText.x, fieldText.y);\r\n    }*/\r\n    if (fieldText.color) {\r\n        context.fillStyle = fieldText.color;\r\n        context.fillText(fieldText.text, fieldText.x, fieldText.y);\r\n    }\r\n}\r\nconst discDepth = 40;\r\nfunction renderDiscEdge1(context, disc) {\r\n    var _a;\r\n    context.fillStyle = (_a = disc.bottomEdgeColor) !== null && _a !== void 0 ? _a : '#888';\r\n    //context.fillRect(disc.x - disc.radius, disc.y, disc.radius * 2, discDepth);\r\n    context.beginPath();\r\n    //context.moveTo(disc.x - disc.radius, disc.y);\r\n    //context.lineTo(disc.x - disc.radius, disc.y + discDepth);\r\n    context.arc(disc.x, disc.y + discDepth, disc.radius, 0, Math.PI);\r\n    //context.lineTo(disc.x + disc.radius, disc.y);\r\n    context.fill();\r\n}\r\nfunction renderDiscEdge2(context, disc) {\r\n    var _a;\r\n    context.fillStyle = (_a = disc.topEdgeColor) !== null && _a !== void 0 ? _a : '#BBB';\r\n    //context.fillRect(disc.x - disc.radius, disc.y, disc.radius * 2, discDepth / 2);\r\n    context.beginPath();\r\n    //context.moveTo(disc.x - disc.radius, disc.y);\r\n    //context.lineTo(disc.x - disc.radius, disc.y + discDepth / 2);\r\n    context.arc(disc.x, disc.y + discDepth / 2, disc.radius, 0, Math.PI);\r\n    //context.lineTo(disc.x + disc.radius, disc.y);\r\n    context.fill();\r\n}\r\nfunction renderDisc(context, disc) {\r\n    var _a;\r\n    context.fillStyle = disc.boss ? '#FBB' : (_a = disc.color) !== null && _a !== void 0 ? _a : '#DDD';\r\n    context.beginPath();\r\n    context.arc(disc.x, disc.y, disc.radius, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\nfunction renderDiscCenter(context, disc) {\r\n    var _a;\r\n    context.fillStyle = disc.boss ? '#FCC' : (_a = disc.centerColor) !== null && _a !== void 0 ? _a : '#FFF';\r\n    context.beginPath();\r\n    context.arc(disc.x, disc.y, disc.radius / 2, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderGame.ts?");

/***/ }),

/***/ "./app/render/renderGeometry.ts":
/*!**************************************!*\
  !*** ./app/render/renderGeometry.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawArc: () => (/* binding */ drawArc),\n/* harmony export */   drawOval: () => (/* binding */ drawOval),\n/* harmony export */   drawRect: () => (/* binding */ drawRect),\n/* harmony export */   fillCircle: () => (/* binding */ fillCircle),\n/* harmony export */   parametricCurve: () => (/* binding */ parametricCurve),\n/* harmony export */   renderBar: () => (/* binding */ renderBar)\n/* harmony export */ });\nfunction fillCircle(context, circle, color, strokeColor) {\r\n    context.beginPath();\r\n    context.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);\r\n    if (color) {\r\n        context.fillStyle = color;\r\n        context.fill();\r\n    }\r\n    if (strokeColor) {\r\n        context.strokeStyle = strokeColor;\r\n        context.stroke();\r\n    }\r\n}\r\nfunction drawArc(context, { x, y, radius }, startTheta = 0, endTheta = 2 * Math.PI, reverse = false) {\r\n    context.arc(x, y, radius, startTheta, endTheta, reverse);\r\n}\r\nfunction drawOval(context, { x, y, w, h }, startTheta = 0, endTheta = 2 * Math.PI, reverse = false) {\r\n    context.save();\r\n    context.translate(x, y);\r\n    context.scale(w, h);\r\n    context.arc(0, 0, 1, startTheta, endTheta, reverse);\r\n    context.restore();\r\n}\r\nfunction drawRect(context, { x, y, w, h }, reverse = false) {\r\n    if (reverse) {\r\n        context.moveTo(x, y);\r\n        context.lineTo(x, y + h);\r\n        context.lineTo(x + w, y + h);\r\n        context.lineTo(x + w, y);\r\n    }\r\n    else {\r\n        context.rect(x, y, w, h);\r\n    }\r\n}\r\nfunction renderBar(context, { x, y, w, h }, p, fillColor, backColor) {\r\n    if (backColor) {\r\n        context.fillStyle = backColor;\r\n        context.fillRect(x, y, w, h);\r\n    }\r\n    context.fillStyle = fillColor;\r\n    context.fillRect(x, y, w * Math.max(0, Math.min(1, p)), h);\r\n}\r\nfunction parametricCurve(context, range, steps, getPoint) {\r\n    const p = getPoint(range[0]);\r\n    context.moveTo(p.x, p.y);\r\n    for (let i = 1; i <= steps; i++) {\r\n        const p = getPoint(range[0] + i * (range[1] - range[0]) / steps);\r\n        context.lineTo(p.x, p.y);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderGeometry.ts?");

/***/ }),

/***/ "./app/render/renderHUD.ts":
/*!*********************************!*\
  !*** ./app/render/renderHUD.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEquipmentTypeLabel: () => (/* binding */ getEquipmentTypeLabel),\n/* harmony export */   renderHUD: () => (/* binding */ renderHUD),\n/* harmony export */   renderMinimap: () => (/* binding */ renderMinimap),\n/* harmony export */   renderProficiencyDetails: () => (/* binding */ renderProficiencyDetails)\n/* harmony export */ });\n/* harmony import */ var app_inventory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/inventory */ \"./app/inventory.ts\");\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_render_renderInventory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/render/renderInventory */ \"./app/render/renderInventory.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_combat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/combat */ \"./app/utils/combat.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_guardSkill__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/guardSkill */ \"./app/utils/guardSkill.ts\");\n/* harmony import */ var app_armor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/armor */ \"./app/armor.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n/* harmony import */ var app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/coreCalculations */ \"./app/utils/coreCalculations.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst minimapSize = 500;\r\nconst smallMapRect = { x: window.CANVAS_WIDTH - 160, y: 10, w: 150, h: 150 };\r\nconst largeMapRect = { x: (window.CANVAS_WIDTH - 400) / 2, y: (window.CANVAS_HEIGHT - 400) / 2, w: 400, h: 400 };\r\nconst [mapCanvas, mapContext] = (0,app_utils_canvas__WEBPACK_IMPORTED_MODULE_3__.createCanvasAndContext)(minimapSize, minimapSize);\r\nconst mapScale = 15;\r\nfunction renderMinimap(state) {\r\n    var _a;\r\n    mapContext.fillStyle = '#000';\r\n    mapContext.fillRect(0, 0, minimapSize, minimapSize);\r\n    mapContext.save();\r\n    mapContext.translate(minimapSize / 2, minimapSize / 2);\r\n    mapContext.scale(1 / mapScale, 1 / mapScale);\r\n    mapContext.translate(-state.hero.x, -state.hero.y);\r\n    for (const disc of state.visibleDiscs) {\r\n        /* mapContext.fillStyle = disc.boss ? '#FBB' : (disc.color ?? '#DDD');\r\n         mapContext.beginPath();\r\n         mapContext.arc(disc.x, disc.y, disc.radius, 0, 2 * Math.PI);\r\n         mapContext.fill();*/\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(mapContext, disc, disc.boss ? '#FBB' : ((_a = disc.color) !== null && _a !== void 0 ? _a : '#DDD'));\r\n    }\r\n    for (const hole of state.holes) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(mapContext, hole, 'black');\r\n    }\r\n    window.CELL_SIZE;\r\n    // Debug code to draw world cell boundaries.\r\n    /*mapContext.lineWidth = 4;\r\n    mapContext.strokeStyle = 'red';\r\n    for (const cell of state.activeCells) {\r\n        mapContext.strokeRect(cell.x * window.CELL_SIZE, (cell.y + 1) * -CELL_SIZE, window.CELL_SIZE, window.CELL_SIZE);\r\n    }*/\r\n    mapContext.restore();\r\n}\r\nfunction getEquipmentTypeLabel(type) {\r\n    if (type === 'lightArmor' || type === 'mediumArmor' || type === 'heavyArmor') {\r\n        return app_armor__WEBPACK_IMPORTED_MODULE_7__.armorTypeLabels[type];\r\n    }\r\n    return app_weapons__WEBPACK_IMPORTED_MODULE_8__.weaponTypeLabels[type];\r\n}\r\nfunction renderHUD(context, state) {\r\n    var _a;\r\n    if (state.paused) {\r\n        context.save();\r\n        context.globalAlpha *= 0.6;\r\n        context.fillStyle = 'black';\r\n        context.fillRect(0, 0, window.CANVAS_WIDTH, window.CANVAS_HEIGHT);\r\n        context.restore();\r\n    }\r\n    const minimapRect = state.paused ? largeMapRect : smallMapRect;\r\n    renderMinimap(state);\r\n    context.fillStyle = '#999';\r\n    context.fillRect(minimapRect.x - 2, minimapRect.y - 2, minimapRect.w + 4, minimapRect.h + 4);\r\n    context.fillStyle = 'black';\r\n    context.fillRect(minimapRect.x, minimapRect.y, minimapRect.w, minimapRect.h);\r\n    context.drawImage(mapCanvas, minimapSize / 2 - minimapRect.w / 2, minimapSize / 2 - minimapRect.h / 2, minimapRect.w, minimapRect.h, minimapRect.x, minimapRect.y, minimapRect.w, minimapRect.h);\r\n    context.fillStyle = '#08F';\r\n    context.strokeStyle = 'white';\r\n    context.fillRect(minimapRect.x + minimapRect.w / 2 - 3, minimapRect.y + minimapRect.h / 2 - 3, 6, 6);\r\n    context.strokeRect(minimapRect.x + minimapRect.w / 2 - 3, minimapRect.y + minimapRect.h / 2 - 3, 6, 6);\r\n    context.fillStyle = 'red';\r\n    for (const enemy of state.enemies) {\r\n        const x = minimapRect.x + minimapRect.w / 2 + (enemy.x - state.hero.x) / mapScale;\r\n        const y = minimapRect.y + minimapRect.w / 2 + (enemy.y - state.hero.y) / mapScale;\r\n        if (x > minimapRect.x + 2 && x < minimapRect.x + minimapRect.w - 2 &&\r\n            y > minimapRect.y + 2 && y < minimapRect.y + minimapRect.h - 2) {\r\n            context.fillRect(x - 2, y - 2, 4, 4);\r\n        }\r\n    }\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'top';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    if (state.hero.disc) {\r\n        context.fillText(state.hero.disc.name, minimapRect.x, minimapRect.y + minimapRect.h + 8);\r\n        context.fillText(`Level ${state.hero.disc.level}`, minimapRect.x, minimapRect.y + minimapRect.h + 26);\r\n    }\r\n    if (state.paused) {\r\n        const instructions = [\r\n            'Press ENTER to pause/unpause.',\r\n            '',\r\n            'Use WASD to move.',\r\n            'Move mouse to aim.',\r\n            'Hold left click to shoot.',\r\n            '',\r\n            'Press SPACE to use a life potion.',\r\n            'Potions and life refill on level up.',\r\n            '',\r\n            'Press F to pick up items.',\r\n            'Pess X to sell an item for XP.',\r\n            '',\r\n            'Inventory items:',\r\n            '  Left click an item equip it.',\r\n            '  Press X on an item to sell it for XP.',\r\n            '  Left click an enchantment',\r\n            '  then click an armor or weapon.',\r\n            '',\r\n            'Gain charge as you hit enemies.',\r\n            'Right click to use charge.',\r\n            '',\r\n            'Enemies can drop portals.',\r\n            'Press F to enter a portal.',\r\n            'Middle click to escape a dungeon.',\r\n            '',\r\n            'On entering/leaving a dungeon:',\r\n            '  Progress is saved',\r\n            '  Life and potions are restored.',\r\n            '',\r\n            'Go North for harder monsters.',\r\n        ];\r\n        let y = 20;\r\n        for (const line of instructions) {\r\n            context.fillText(line, window.CANVAS_WIDTH - 280, y);\r\n            y += 20;\r\n        }\r\n    }\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'top';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    context.fillText('Level ' + state.hero.level, 5, 5);\r\n    context.fillText('Armor ', 100, 5);\r\n    if (state.hero.armor < state.hero.baseArmor) {\r\n        context.fillStyle = '#AAA';\r\n    }\r\n    else if (state.hero.armor > state.hero.baseArmor) {\r\n        context.fillStyle = '#AFA';\r\n    }\r\n    context.fillText('' + (state.hero.armor | 0), 100 + context.measureText('Armor ').width, 5);\r\n    const lifeRect = { x: 5, y: 30, h: 20, w: 200 };\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, lifeRect, state.hero.life / state.hero.maxLife, 'green', '#888');\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    context.fillText(Math.ceil(state.hero.life) + ' / ' + state.hero.maxLife, lifeRect.x + 2, lifeRect.y + lifeRect.h / 2 + 2);\r\n    const experienceRect = { x: 5, y: lifeRect.y + lifeRect.h + 5, h: 10, w: 200 };\r\n    const requiredExperience = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_9__.getExperienceForNextLevel)(state.hero.level);\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, experienceRect, state.hero.experience / requiredExperience, 'orange', '#888');\r\n    let hoveredProficiencyType;\r\n    let y = window.CANVAS_HEIGHT - 25;\r\n    let x = window.SLOT_SIZE + 2 * window.SLOT_PADDING;\r\n    const { armor, weapon } = state.hero.equipment;\r\n    const weaponXpRect = { x, y, h: 10, w: 160 };\r\n    const weaponProficiency = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.getProficiency)(state, weapon.weaponType);\r\n    const weaponMastery = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.getMastery)(state, weapon.weaponType);\r\n    const requiredWeaponXp = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_9__.getExperienceForNextEquipmentLevel)(weaponProficiency.level);\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, weaponXpRect, weaponProficiency.experience / requiredWeaponXp, 'orange', '#888');\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    let weaponProficiencyLabel = app_weapons__WEBPACK_IMPORTED_MODULE_8__.weaponTypeLabels[weapon.weaponType] + ' skill ' + weaponProficiency.level;\r\n    if (weaponMastery) {\r\n        weaponProficiencyLabel += ' (+' + weaponMastery + ')';\r\n    }\r\n    context.fillText(weaponProficiencyLabel, x, y - 8);\r\n    if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.isPointInRect)({ x, y: window.CANVAS_HEIGHT - 40, h: 30, w: 160 }, state.mouse)) {\r\n        hoveredProficiencyType = weapon.weaponType;\r\n    }\r\n    if (state.paused) {\r\n        let y = 200;\r\n        for (const type of [...app_armor__WEBPACK_IMPORTED_MODULE_7__.armorTypes, ...app_weapons__WEBPACK_IMPORTED_MODULE_8__.weaponTypes]) {\r\n            const xpRect = { x: 5, y, h: 10, w: 160 };\r\n            const proficiency = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.getProficiency)(state, type);\r\n            const mastery = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.getMastery)(state, type);\r\n            const requiredWeaponXp = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_9__.getExperienceForNextEquipmentLevel)(proficiency.level);\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, xpRect, proficiency.experience / requiredWeaponXp, 'orange', '#888');\r\n            context.fillStyle = 'white';\r\n            context.textBaseline = 'middle';\r\n            context.textAlign = 'left';\r\n            context.font = '16px sans-serif';\r\n            let proficiencyLabel = getEquipmentTypeLabel(type);\r\n            proficiencyLabel += ' skill ' + proficiency.level;\r\n            if (mastery) {\r\n                proficiencyLabel += ' (+' + mastery + ')';\r\n            }\r\n            context.fillText(proficiencyLabel, 10, y - 8);\r\n            if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.isPointInRect)({ x: xpRect.x, y: y - 20, h: 30, w: 160 }, state.mouse)) {\r\n                hoveredProficiencyType = type;\r\n            }\r\n            y += 35;\r\n        }\r\n    }\r\n    y -= (window.SLOT_SIZE + window.SLOT_PADDING);\r\n    const armorXpRect = { x, y, h: 10, w: 160 };\r\n    const armorProficiency = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.getProficiency)(state, armor.armorType);\r\n    const armorMastery = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.getMastery)(state, armor.armorType);\r\n    const requireArmorXp = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_9__.getExperienceForNextEquipmentLevel)(armorProficiency.level);\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, armorXpRect, armorProficiency.experience / requireArmorXp, 'orange', '#888');\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    let armorProficiencyLabel = app_armor__WEBPACK_IMPORTED_MODULE_7__.armorTypeLabels[armor.armorType] + ' skill ' + weaponProficiency.level;\r\n    if (armorMastery) {\r\n        armorProficiencyLabel += ' (+' + armorMastery + ')';\r\n    }\r\n    context.fillText(armorProficiencyLabel, x, y - 8);\r\n    if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.isPointInRect)({ x, y: window.CANVAS_HEIGHT - 40 - (window.SLOT_SIZE + window.SLOT_PADDING), h: 30, w: 160 }, state.mouse)) {\r\n        hoveredProficiencyType = armor.armorType;\r\n    }\r\n    context.strokeStyle = 'red';\r\n    context.fillStyle = 'red';\r\n    for (let i = 0; i < window.BASE_MAX_POTIONS; i++) {\r\n        if (i < state.hero.potions) {\r\n            context.fillRect(5 + i * 15, experienceRect.y + experienceRect.h + 5, 10, 15);\r\n        }\r\n        context.strokeRect(5 + i * 15, experienceRect.y + experienceRect.h + 5, 10, 15);\r\n    }\r\n    const chargeRect = { x: 25, y: experienceRect.y + experienceRect.h + 30, h: 8, w: 140 };\r\n    context.fillStyle = 'white';\r\n    if (state.hero.attackChargeLevel > 1) {\r\n        context.fillText('' + ((state.hero.attackChargeLevel | 0) - 1), 5, chargeRect.y + chargeRect.h / 2 + 1);\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, chargeRect, state.hero.attackChargeDuration / state.hero.totalChargeDuration, 'red', 'white');\r\n    }\r\n    else {\r\n        context.fillText('' + ((state.hero.chargingLevel | 0) - 1), 5, chargeRect.y + chargeRect.h / 2 + 1);\r\n        //const isFull = state.hero.chargingLevel >= getMaxChargeLevel(state);\r\n        if ((state.hero.chargingLevel | 0) > 1) {\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, chargeRect, 1, 'red', 'white');\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, chargeRect, state.hero.chargingLevel % 1, 'purple');\r\n        }\r\n        else {\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, chargeRect, state.hero.chargingLevel % 1, 'purple', 'white');\r\n        }\r\n    }\r\n    const guardChargeRect = { x: chargeRect.x, y: chargeRect.y + 20, h: 8, w: 140 };\r\n    context.fillStyle = 'white';\r\n    context.fillText('' + state.hero.guardSkill.charges, 5, guardChargeRect.y + guardChargeRect.h / 2 + 1);\r\n    if (state.hero.guardSkill.charges >= 1) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, guardChargeRect, 1, 'lightblue', 'white');\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, guardChargeRect, state.hero.guardSkill.cooldownTime / (0,app_utils_guardSkill__WEBPACK_IMPORTED_MODULE_6__.getGuardSkillCooldownTime)(state), 'blue');\r\n    }\r\n    else {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, guardChargeRect, state.hero.guardSkill.cooldownTime / (0,app_utils_guardSkill__WEBPACK_IMPORTED_MODULE_6__.getGuardSkillCooldownTime)(state), 'blue', 'white');\r\n    }\r\n    const boss = (_a = state.hero.disc) === null || _a === void 0 ? void 0 : _a.boss;\r\n    if (!state.paused && boss) {\r\n        const lifeRect = { x: 210, y: window.CANVAS_HEIGHT - 60, h: 24, w: window.CANVAS_WIDTH - 420 };\r\n        let color = '#0F0';\r\n        if (boss.life <= boss.maxLife / 4) {\r\n            color = '#F00';\r\n        }\r\n        else if (boss.life <= boss.maxLife / 2) {\r\n            color = '#F80';\r\n        }\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_1__.renderBar)(context, lifeRect, boss.life / boss.maxLife, color, '#444');\r\n        context.fillStyle = 'white';\r\n        context.textBaseline = 'middle';\r\n        context.textAlign = 'left';\r\n        context.font = '20px sans-serif';\r\n        context.fillText(boss.definition.name +\r\n            ' ' + (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_4__.abbreviateHealth)(Math.ceil(boss.life)) + ' / ' + (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_4__.abbreviateHealth)(boss.maxLife), lifeRect.x + 2, lifeRect.y + lifeRect.h / 2 + 2);\r\n    }\r\n    let hoverItem = undefined;\r\n    for (const slot of (0,app_inventory__WEBPACK_IMPORTED_MODULE_0__.getInventorySlots)(state)) {\r\n        (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_2__.renderInventorySlot)(context, state, slot);\r\n        if (state.isUsingKeyboard && slot.item && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.isPointInRect)(slot, state.mouse)) {\r\n            hoverItem = slot.item;\r\n        }\r\n    }\r\n    if (state.paused && state.isUsingXbox) {\r\n        (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_2__.renderSelectedInventorySlot)(context, state);\r\n        hoverItem = (0,app_inventory__WEBPACK_IMPORTED_MODULE_0__.getSelectedItem)(state);\r\n    }\r\n    if (hoverItem) {\r\n        let equippedItem;\r\n        if (hoverItem.type === 'weapon') {\r\n            equippedItem = state.hero.equipment.weapon;\r\n        }\r\n        if (hoverItem.type === 'armor') {\r\n            equippedItem = state.hero.equipment.armor;\r\n        }\r\n        if (state.isUsingXbox) {\r\n            const slot = (0,app_inventory__WEBPACK_IMPORTED_MODULE_0__.getSelectedInventorySlot)(state);\r\n            if (slot) {\r\n                (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_2__.renderItemDetails)(context, state, hoverItem, slot, equippedItem);\r\n            }\r\n        }\r\n        else {\r\n            (0,app_render_renderInventory__WEBPACK_IMPORTED_MODULE_2__.renderItemDetails)(context, state, hoverItem, state.mouse, equippedItem);\r\n        }\r\n    }\r\n    if (hoveredProficiencyType) {\r\n        renderProficiencyDetails(context, state, hoveredProficiencyType, state.mouse);\r\n    }\r\n}\r\nconst minDetailsWidth = 200;\r\nconst minDetailsHeight = 50;\r\nfunction renderProficiencyDetails(context, state, type, { x, y }) {\r\n    const proficiency = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.getProficiency)(state, type).level;\r\n    const mastery = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.getMastery)(state, type);\r\n    const totalProficiency = proficiency + mastery;\r\n    let w = minDetailsWidth, h = minDetailsHeight;\r\n    let textLines = [\r\n        `${getEquipmentTypeLabel(type)} Proficiency Bonuses:`,\r\n        '',\r\n    ];\r\n    if (type === 'lightArmor') {\r\n        textLines = [\r\n            `For ${getEquipmentTypeLabel(type).toLowerCase()}s:`,\r\n            `    ${totalProficiency}% increased cooldown speed for dash`,\r\n            '',\r\n            `For any armor:`,\r\n        ];\r\n    }\r\n    else if (type === 'mediumArmor') {\r\n        textLines = [\r\n            `For ${getEquipmentTypeLabel(type).toLowerCase()}s:`,\r\n            `    ${totalProficiency}% increased radius of bullet dispersion`,\r\n            '',\r\n            `For any armor:`,\r\n        ];\r\n    }\r\n    else if (type === 'heavyArmor') {\r\n        textLines = [\r\n            `For ${getEquipmentTypeLabel(type).toLowerCase()}s:`,\r\n            `    ${totalProficiency}% increased duration of shield`,\r\n            '',\r\n            `For any armor:`,\r\n        ];\r\n    }\r\n    else {\r\n        const damageIncrease = (100 * Math.pow(1.05, totalProficiency) - 100).toFixed(0);\r\n        textLines = [\r\n            ...textLines,\r\n            `For ${getEquipmentTypeLabel(type).toLowerCase()}s:`,\r\n            `    ${damageIncrease}% increased damage`,\r\n            `    ${totalProficiency}% increased attack speed`,\r\n            '',\r\n            `For all weapons:`,\r\n        ];\r\n    }\r\n    if (type === 'bow') {\r\n        textLines.push(`    ${(totalProficiency / 10).toFixed(1)}% additional critical strike chance`);\r\n    }\r\n    else if (type === 'dagger') {\r\n        textLines.push(`    ${totalProficiency}% increased attack speed`);\r\n    }\r\n    else if (type === 'katana') {\r\n        textLines.push(`    ${totalProficiency}% increased critical damage`);\r\n    }\r\n    else if (type === 'morningStar') {\r\n        textLines.push(`    ${totalProficiency}% increased effect of armor shred`);\r\n    }\r\n    else if (type === 'wand') {\r\n        textLines.push(`    ${totalProficiency}% increased charge attack damage`);\r\n    }\r\n    else if (type === 'sword') {\r\n        textLines.push(`    ${totalProficiency}% increased damage`);\r\n    }\r\n    else if (type === 'lightArmor') {\r\n        textLines.push(`    ${totalProficiency}% increased bullet shave radius`);\r\n    }\r\n    else if (type === 'mediumArmor') {\r\n        textLines.push(`    ${totalProficiency}% increased life`);\r\n    }\r\n    else if (type === 'heavyArmor') {\r\n        textLines.push(`    ${totalProficiency}% increased armor`);\r\n    }\r\n    const lineWidths = [];\r\n    for (const line of textLines) {\r\n        const lineWidth = context.measureText(line).width;\r\n        w = Math.max(w, lineWidth + 20);\r\n        lineWidths.push(lineWidth);\r\n    }\r\n    h = Math.max(h, textLines.length * 20 + 20);\r\n    x = Math.max(10, Math.min(window.CANVAS_WIDTH - 10 - w, x - w / 2));\r\n    y = Math.max(10, Math.min(window.CANVAS_HEIGHT - 10 - h, y - h - 10));\r\n    context.fillStyle = 'white';\r\n    context.fillRect(x, y, w, h);\r\n    context.fillStyle = 'black';\r\n    context.fillRect(x + 2, y + 2, w - 4, h - 4);\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'top';\r\n    context.textAlign = 'left';\r\n    context.font = `16px sans-serif`;\r\n    for (let i = 0; i < textLines.length; i++) {\r\n        const line = textLines[i];\r\n        context.fillText(line, x + 10, y + 10 + 20 * i);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderHUD.ts?");

/***/ }),

/***/ "./app/render/renderInventory.ts":
/*!***************************************!*\
  !*** ./app/render/renderInventory.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getItemName: () => (/* binding */ getItemName),\n/* harmony export */   renderArmorLong: () => (/* binding */ renderArmorLong),\n/* harmony export */   renderArmorShort: () => (/* binding */ renderArmorShort),\n/* harmony export */   renderEnchantmentLong: () => (/* binding */ renderEnchantmentLong),\n/* harmony export */   renderEnchantmentShort: () => (/* binding */ renderEnchantmentShort),\n/* harmony export */   renderInventorySlot: () => (/* binding */ renderInventorySlot),\n/* harmony export */   renderItemDetails: () => (/* binding */ renderItemDetails),\n/* harmony export */   renderSelectedInventorySlot: () => (/* binding */ renderSelectedInventorySlot),\n/* harmony export */   renderWeaponLong: () => (/* binding */ renderWeaponLong),\n/* harmony export */   renderWeaponShort: () => (/* binding */ renderWeaponShort)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGeometry */ \"./app/render/renderGeometry.ts\");\n/* harmony import */ var app_render_renderText__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderText */ \"./app/render/renderText.ts\");\n/* harmony import */ var app_armor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/armor */ \"./app/armor.ts\");\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_inventory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/inventory */ \"./app/inventory.ts\");\n/* harmony import */ var app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/uniqueEnchantmentHash */ \"./app/uniqueEnchantmentHash.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction renderInventorySlot(context, state, { x, y, w, h, item }) {\r\n    context.fillStyle = 'white';\r\n    context.beginPath();\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.drawRect)(context, { x, y, w, h });\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.drawRect)(context, { x: x + 2, y: y + 2, w: w - 4, h: h - 4 }, true);\r\n    context.fill();\r\n    if ((item === null || item === void 0 ? void 0 : item.type) === 'armor') {\r\n        renderArmorShort(context, x + w / 2, y + h / 2, item);\r\n    }\r\n    if ((item === null || item === void 0 ? void 0 : item.type) === 'enchantment') {\r\n        renderEnchantmentShort(context, x + w / 2, y + h / 2, item);\r\n        if (state.hero.activeEnchantment === item) {\r\n            context.save();\r\n            context.globalAlpha *= 0.6;\r\n            context.fillStyle = 'white';\r\n            context.fillRect(x, y, w, h);\r\n            context.restore();\r\n        }\r\n    }\r\n    if ((item === null || item === void 0 ? void 0 : item.type) === 'weapon') {\r\n        renderWeaponShort(context, x + w / 2, y + h / 2, item);\r\n    }\r\n}\r\nfunction renderSelectedInventorySlot(context, state) {\r\n    const slot = (0,app_inventory__WEBPACK_IMPORTED_MODULE_4__.getSelectedInventorySlot)(state);\r\n    if (!slot) {\r\n        return;\r\n    }\r\n    const { x, y, w, h } = slot;\r\n    context.fillStyle = 'blue';\r\n    context.beginPath();\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.drawRect)(context, { x, y, w, h });\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.drawRect)(context, { x: x + 2, y: y + 2, w: w - 4, h: h - 4 }, true);\r\n    context.fill();\r\n}\r\nfunction renderArmorLong(context, x, y, armor) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x, y, radius: 12 }, '#88F');\r\n    renderItemSlots(context, x, y, armor);\r\n    const label = getItemName(armor);\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_1__.embossText)(context, label, x, y + 2, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction renderArmorShort(context, x, y, armor) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x, y, radius: 12 }, '#88F');\r\n    renderItemSlots(context, x, y, armor);\r\n    const label = armor.armorType.charAt(0).toUpperCase() + armor.level;\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_1__.embossText)(context, label, x, y + 2, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction renderEnchantmentLong(context, x, y, enchantment) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x, y, radius: 12 }, '#8F8');\r\n    const label = app_enchantments__WEBPACK_IMPORTED_MODULE_3__.enchantmentStrengthLabels[enchantment.strength] + ' ' + enchantment.name + ' enchantment';\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_1__.embossText)(context, label, x, y + 2, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction renderEnchantmentShort(context, x, y, enchantment) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x, y, radius: 12 }, '#8F8');\r\n    const label = enchantment.name.charAt(0).toUpperCase() + enchantment.strength;\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_1__.embossText)(context, label, x, y + 2, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction renderWeaponLong(context, x, y, weapon) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x, y, radius: 12 }, '#F88');\r\n    renderItemSlots(context, x, y, weapon);\r\n    const label = getItemName(weapon);\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_1__.embossText)(context, label, x, y + 2, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction renderWeaponShort(context, x, y, weapon) {\r\n    (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x, y, radius: 12 }, '#F88');\r\n    renderItemSlots(context, x, y, weapon);\r\n    const label = weapon.weaponType.charAt(0).toUpperCase() + weapon.level;\r\n    (0,app_render_renderText__WEBPACK_IMPORTED_MODULE_1__.embossText)(context, label, x, y + 2, { size: 16, color: 'white', borderColor: 'black' });\r\n}\r\nfunction getItemName(item) {\r\n    let name = item.name;\r\n    for (const enchantment of item.bonusEnchantmentSlots) {\r\n        if (enchantment.enchantmentType === 'uniqueWeaponEnchantment' || enchantment.enchantmentType === 'uniqueArmorEnchantment') {\r\n            const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_5__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n            name = definition.name + ' ' + name;\r\n        }\r\n    }\r\n    return name;\r\n}\r\nfunction renderItemSlots(context, x, y, item) {\r\n    for (let i = 0; i < item.enchantmentSlots.length; i++) {\r\n        let sx = x - 10 + 20 * (i % 2), sy = y - 10 + 20 * Math.floor(i / 2);\r\n        if (item.enchantmentSlots[i].enchantmentType !== 'empty') {\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: sx, y: sy, radius: 4 }, '#8F8');\r\n        }\r\n        else {\r\n            (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x: sx, y: sy, radius: 4 }, 'white');\r\n        }\r\n        context.beginPath();\r\n        context.strokeStyle = 'black';\r\n        context.arc(sx, sy, 4, 0, 2 * Math.PI);\r\n        context.stroke();\r\n    }\r\n    if (item.bonusEnchantmentSlots.length > 0) {\r\n        (0,app_render_renderGeometry__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { x, y, radius: 7 }, 'yellow');\r\n    }\r\n}\r\nconst minDetailsWidth = 200;\r\nconst minDetailsHeight = 50;\r\nfunction renderItemDetails(context, state, item, { x, y }, equippedItem) {\r\n    let w = minDetailsWidth, h = minDetailsHeight;\r\n    context.font = `16px monospace`;\r\n    const textLines = equippedItem && equippedItem !== item && item.type !== 'enchantment'\r\n        ? getItemComparisonTextLines(state, item, equippedItem)\r\n        : getItemTextLines(state, item);\r\n    const lineWidths = [];\r\n    for (const line of textLines) {\r\n        const lineWidth = context.measureText(line).width;\r\n        w = Math.max(w, lineWidth + 20);\r\n        lineWidths.push(lineWidth);\r\n    }\r\n    h = Math.max(h, textLines.length * 20 + 20);\r\n    x = Math.max(10, Math.min(window.CANVAS_WIDTH - 10 - w, x - w / 2));\r\n    y = Math.max(10, Math.min(window.CANVAS_HEIGHT - 10 - h, y - h - 10));\r\n    context.fillStyle = 'white';\r\n    context.fillRect(x, y, w, h);\r\n    context.fillStyle = 'black';\r\n    context.fillRect(x + 2, y + 2, w - 4, h - 4);\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'top';\r\n    context.textAlign = 'left';\r\n    for (let i = 0; i < textLines.length; i++) {\r\n        const line = textLines[i];\r\n        context.fillText(line, x + 10, y + 10 + 20 * i);\r\n    }\r\n}\r\nfunction getWeaponAttacksPerSecond(state, weapon) {\r\n    if (weapon.weaponType === 'morningStar') {\r\n        // Half the shots for morning star only apply when using charge attack.\r\n        return (weapon.getShots(state, weapon).length * weapon.getAttacksPerSecond(state, weapon)).toFixed(2);\r\n    }\r\n    return (weapon.getShots(state, weapon).length * weapon.getAttacksPerSecond(state, weapon)).toFixed(2);\r\n}\r\nfunction getItemTextLines(state, item) {\r\n    if (item.type === 'enchantment') {\r\n        return [\r\n            app_enchantments__WEBPACK_IMPORTED_MODULE_3__.enchantmentStrengthLabels[item.strength] + ' ' + item.name + ' enchantment',\r\n            'Weapon: Grants ' + (0,app_enchantments__WEBPACK_IMPORTED_MODULE_3__.getEnchantmentBonusText)(item.weaponEnchantmentType, 10 * item.strength, 20 * item.strength),\r\n            'Armor: Grants ' + (0,app_enchantments__WEBPACK_IMPORTED_MODULE_3__.getEnchantmentBonusText)(item.armorEnchantmentType, 10 * item.strength, 20 * item.strength),\r\n        ];\r\n    }\r\n    if (item.type === 'weapon') {\r\n        return [\r\n            getItemName(item),\r\n            'Lv ' + item.level + ' ' + app_weapons__WEBPACK_IMPORTED_MODULE_6__.weaponTypeLabels[item.weaponType],\r\n            //Math.round(item.damage * item.shots.length * item.attacksPerSecond) + ' DPS',\r\n            item.damage + ' Damage',\r\n            getWeaponAttacksPerSecond(state, item) + ' Attacks per second',\r\n            ...getEnchantmentTextLines(state, item),\r\n        ];\r\n    }\r\n    if (item.type === 'armor') {\r\n        return [\r\n            getItemName(item),\r\n            'Lv ' + item.level + ' ' + app_armor__WEBPACK_IMPORTED_MODULE_2__.armorTypeLabels[item.armorType],\r\n            item.armor + ' Armor',\r\n            '+' + item.life + ' Life',\r\n            ...getEnchantmentTextLines(state, item),\r\n        ];\r\n    }\r\n    return [];\r\n}\r\nfunction getItemComparisonTextLines(state, newItem, equippedItem) {\r\n    if (newItem.type === 'weapon' && equippedItem.type === 'weapon') {\r\n        //const oldDps = Math.round(equippedItem.damage * equippedItem.shots.length * equippedItem.attacksPerSecond);\r\n        //const newDps = Math.round(newItem.damage * newItem.shots.length * newItem.attacksPerSecond);\r\n        return [\r\n            getItemName(newItem),\r\n            'Lv ' + newItem.level + ' ' + app_weapons__WEBPACK_IMPORTED_MODULE_6__.weaponTypeLabels[newItem.weaponType],\r\n            //oldDps + ' → ' + newDps + ' DPS',\r\n            equippedItem.damage + ' → ' + newItem.damage + ' Damage',\r\n            getWeaponAttacksPerSecond(state, equippedItem)\r\n                + ' → '\r\n                + getWeaponAttacksPerSecond(state, newItem)\r\n                + ' Attacks per second',\r\n            ...getEnchantmentComparisonTextLines(state, newItem, equippedItem),\r\n            ...getBonusEnchantmentComparisonTextLines(state, newItem, equippedItem),\r\n        ];\r\n    }\r\n    if (newItem.type === 'armor' && equippedItem.type === 'armor') {\r\n        return [\r\n            getItemName(newItem),\r\n            'Lv ' + newItem.level + ' ' + app_armor__WEBPACK_IMPORTED_MODULE_2__.armorTypeLabels[newItem.armorType],\r\n            equippedItem.armor + ' → ' + newItem.armor + ' Armor',\r\n            '+' + equippedItem.life + ' → ' + '+' + newItem.life + ' Life',\r\n            ...getEnchantmentComparisonTextLines(state, newItem, equippedItem),\r\n            ...getBonusEnchantmentComparisonTextLines(state, newItem, equippedItem),\r\n        ];\r\n    }\r\n    return [];\r\n}\r\nfunction getEnchantmentTextLines(state, item) {\r\n    return [\r\n        ...item.enchantmentSlots.map(e => getEnchantmentText(state, e)).flat(),\r\n        ...item.bonusEnchantmentSlots.map(e => getEnchantmentText(state, e)).flat(),\r\n    ];\r\n}\r\nfunction getEnchantmentComparisonTextLines(state, newItem, equippedItem) {\r\n    const lines = [];\r\n    for (let i = 0; i < newItem.enchantmentSlots.length || i < equippedItem.enchantmentSlots.length; i++) {\r\n        const currentLines = getEnchantmentText(state, equippedItem.enchantmentSlots[i]);\r\n        const newLines = getEnchantmentText(state, newItem.enchantmentSlots[i]);\r\n        const maxLines = Math.max(currentLines.length, newLines.length);\r\n        const maxCurrentLineLength = Math.max(...currentLines.map(l => l.length));\r\n        // This is a pretty hacky way of trying to show a transition between two lines of text\r\n        for (let j = 0; j < maxLines; j++) {\r\n            const currentLine = currentLines[j];\r\n            const newLine = newLines[j];\r\n            let padding = ' '.repeat(maxCurrentLineLength - ((currentLine === null || currentLine === void 0 ? void 0 : currentLine.length) || 0));\r\n            if (currentLine && newLine) {\r\n                lines.push(currentLine + ' → ' + padding + newLine);\r\n            }\r\n            else if (currentLine) {\r\n                lines.push(currentLine);\r\n            }\r\n            else {\r\n                lines.push(padding + '   ' + newLine);\r\n            }\r\n        }\r\n    }\r\n    return lines;\r\n}\r\nfunction getBonusEnchantmentComparisonTextLines(state, newItem, equippedItem) {\r\n    const lines = [];\r\n    for (let i = 0; i < newItem.bonusEnchantmentSlots.length || i < equippedItem.bonusEnchantmentSlots.length; i++) {\r\n        const currentLines = getEnchantmentText(state, equippedItem.bonusEnchantmentSlots[i]);\r\n        const newLines = getEnchantmentText(state, newItem.bonusEnchantmentSlots[i]);\r\n        const maxLines = Math.max(currentLines.length, newLines.length);\r\n        const maxCurrentLineLength = Math.max(...currentLines.map(l => l.length));\r\n        // This is a pretty hacky way of trying to show a transition between two lines of text\r\n        for (let j = 0; j < maxLines; j++) {\r\n            const currentLine = currentLines[j];\r\n            const newLine = newLines[j];\r\n            let padding = ' '.repeat(maxCurrentLineLength - ((currentLine === null || currentLine === void 0 ? void 0 : currentLine.length) || 0));\r\n            if (currentLine && newLine) {\r\n                lines.push(currentLine + ' → ' + padding + newLine);\r\n            }\r\n            else if (currentLine) {\r\n                lines.push(currentLine);\r\n            }\r\n            else {\r\n                lines.push(padding + '   ' + newLine);\r\n            }\r\n        }\r\n    }\r\n    return lines;\r\n}\r\nfunction getEnchantmentText(state, enchantment) {\r\n    var _a, _b;\r\n    if (!enchantment) {\r\n        return ['-- '];\r\n    }\r\n    if (enchantment.enchantmentType === 'empty') {\r\n        return ['Empty Slot'];\r\n    }\r\n    if (enchantment.enchantmentType === 'uniqueArmorEnchantment' || enchantment.enchantmentType === 'uniqueWeaponEnchantment') {\r\n        const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_5__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n        const lines = (_a = definition.getDescription) === null || _a === void 0 ? void 0 : _a.call(definition, state, enchantment);\r\n        for (const flag of ((_b = definition.flags) !== null && _b !== void 0 ? _b : [])) {\r\n            const line = getHeroFlagDescription(flag);\r\n            if (line) {\r\n                lines.push(line);\r\n            }\r\n        }\r\n        return lines;\r\n    }\r\n    if (!enchantment.value) {\r\n        return [enchantment.enchantmentType];\r\n    }\r\n    return (0,app_enchantments__WEBPACK_IMPORTED_MODULE_3__.getEnchantmentBonusText)(enchantment.enchantmentType, enchantment.value);\r\n}\r\nfunction getHeroFlagDescription(flag) {\r\n    switch (flag) {\r\n        case 'noShaveShrink': return 'Shave radius is unaffected by charge level.';\r\n        case 'noShaveCharge': return 'Shaving bullets does not increase charge level.';\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderInventory.ts?");

/***/ }),

/***/ "./app/render/renderText.ts":
/*!**********************************!*\
  !*** ./app/render/renderText.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   embossText: () => (/* binding */ embossText)\n/* harmony export */ });\nfunction embossText(context, text, x, y, { textAlign = 'center', textBaseline = 'middle', size = 16, color = 'white', borderColor = 'black', bold = false, }) {\r\n    context.textBaseline = textBaseline;\r\n    context.textAlign = textAlign;\r\n    context.font = `${size}px ${bold ? 'bold ' : ''}sans-serif`;\r\n    if (borderColor) {\r\n        context.fillStyle = borderColor;\r\n        context.fillText(text, x - 1, y);\r\n        context.fillText(text, x + 1, y);\r\n        context.fillText(text, x, y + 1);\r\n        context.fillText(text, x, y - 1);\r\n    }\r\n    context.fillStyle = color;\r\n    context.fillText(text, x, y);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderText.ts?");

/***/ }),

/***/ "./app/saveGame.ts":
/*!*************************!*\
  !*** ./app/saveGame.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadGame: () => (/* binding */ loadGame),\n/* harmony export */   saveGame: () => (/* binding */ saveGame)\n/* harmony export */ });\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_item__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/item */ \"./app/utils/item.ts\");\n\r\n\r\nfunction getSaveData(state) {\r\n    const x = state.dungeon ? state.hero.overworldX : state.hero.x;\r\n    const y = state.dungeon ? state.hero.overworldY : state.hero.y;\r\n    const { armor, weapon } = state.hero.equipment;\r\n    return {\r\n        worldSeed: state.worldSeed,\r\n        // Hero data\r\n        level: state.hero.level,\r\n        experience: state.hero.experience,\r\n        x, y,\r\n        weapon: saveWeapon(weapon),\r\n        armor: saveArmor(armor),\r\n        proficiency: {\r\n            bow: (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_0__.getProficiency)(state, 'bow'),\r\n            dagger: (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_0__.getProficiency)(state, 'dagger'),\r\n            katana: (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_0__.getProficiency)(state, 'katana'),\r\n            morningStar: (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_0__.getProficiency)(state, 'morningStar'),\r\n            sword: (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_0__.getProficiency)(state, 'sword'),\r\n            wand: (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_0__.getProficiency)(state, 'wand'),\r\n            lightArmor: (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_0__.getProficiency)(state, 'lightArmor'),\r\n            mediumArmor: (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_0__.getProficiency)(state, 'mediumArmor'),\r\n            heavyArmor: (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_0__.getProficiency)(state, 'heavyArmor'),\r\n        },\r\n        weapons: state.hero.weapons.map(saveWeapon),\r\n        armors: state.hero.armors.map(saveArmor),\r\n        enchantments: state.hero.enchantments.map(saveEnchantment),\r\n        bossRecords: state.hero.bossRecords,\r\n        missedRolls: state.missedRolls,\r\n    };\r\n}\r\nfunction saveEnchantment(enchantment) {\r\n    return {\r\n        ...enchantment\r\n    };\r\n}\r\nfunction saveArmor(armor) {\r\n    return {\r\n        type: armor.armorType,\r\n        level: armor.level,\r\n        enchantmentSlots: armor.enchantmentSlots,\r\n        bonusEnchantmentSlots: armor.bonusEnchantmentSlots,\r\n    };\r\n}\r\nfunction loadArmor(data) {\r\n    const armor = (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.generateArmor)(data.type, data.level);\r\n    armor.enchantmentSlots = data.enchantmentSlots;\r\n    armor.bonusEnchantmentSlots = data.bonusEnchantmentSlots || [];\r\n    (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.applyUniqueItemEnchantments)(armor);\r\n    return armor;\r\n}\r\nfunction saveWeapon(weapon) {\r\n    return {\r\n        type: weapon.weaponType,\r\n        level: weapon.level,\r\n        enchantmentSlots: weapon.enchantmentSlots,\r\n        bonusEnchantmentSlots: weapon.bonusEnchantmentSlots,\r\n    };\r\n}\r\nfunction loadWeapon(data) {\r\n    const weapon = (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.generateWeapon)(data.type, data.level);\r\n    weapon.enchantmentSlots = data.enchantmentSlots;\r\n    weapon.bonusEnchantmentSlots = data.bonusEnchantmentSlots || [];\r\n    (0,app_utils_item__WEBPACK_IMPORTED_MODULE_1__.applyUniqueItemEnchantments)(weapon);\r\n    return weapon;\r\n}\r\nfunction saveGame(state) {\r\n    try {\r\n        window.localStorage.setItem('savedGame', JSON.stringify(getSaveData(state)));\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n        debugger;\r\n    }\r\n}\r\nfunction loadGame(state) {\r\n    try {\r\n        const jsonData = window.localStorage.getItem('savedGame');\r\n        if (!jsonData) {\r\n            return;\r\n        }\r\n        const data = JSON.parse(jsonData);\r\n        if (!data) {\r\n            return;\r\n        }\r\n        state.worldSeed = data.worldSeed;\r\n        state.hero.level = data.level;\r\n        state.hero.experience = data.experience;\r\n        state.hero.overworldX = state.hero.x = data.x;\r\n        state.hero.overworldY = state.hero.y = data.y;\r\n        state.hero.equipment.weapon = loadWeapon(data.weapon);\r\n        state.hero.equipment.armor = loadArmor(data.armor);\r\n        state.hero.weapons = data.weapons.map(loadWeapon);\r\n        state.hero.armors = data.armors.map(loadArmor);\r\n        state.hero.enchantments = data.enchantments;\r\n        // Data below this point might not exist on old save files.\r\n        state.hero.bossRecords = data.bossRecords || {};\r\n        state.missedRolls = data.missedRolls || {};\r\n        state.hero.proficiency = data.proficiency || {};\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n        debugger;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/saveGame.ts?");

/***/ }),

/***/ "./app/uniqueEnchantmentHash.ts":
/*!**************************************!*\
  !*** ./app/uniqueEnchantmentHash.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addUniqueEnchantment: () => (/* binding */ addUniqueEnchantment),\n/* harmony export */   addUniqueEnchantments: () => (/* binding */ addUniqueEnchantments),\n/* harmony export */   uniqueEnchantmentHash: () => (/* binding */ uniqueEnchantmentHash)\n/* harmony export */ });\nconst uniqueEnchantmentHash = {};\r\nfunction addUniqueEnchantment(enchantment) {\r\n    if (uniqueEnchantmentHash[enchantment.key]) {\r\n        console.error('Unique Enchantment Key collission:', enchantment.key);\r\n    }\r\n    uniqueEnchantmentHash[enchantment.key] = enchantment;\r\n}\r\nfunction addUniqueEnchantments(enchantments) {\r\n    for (const enchantment of enchantments) {\r\n        addUniqueEnchantment(enchantment);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/uniqueEnchantmentHash.ts?");

/***/ }),

/***/ "./app/uniqueEnchantments.ts":
/*!***********************************!*\
  !*** ./app/uniqueEnchantments.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addUniqueEnchantmentToItem: () => (/* binding */ addUniqueEnchantmentToItem),\n/* harmony export */   checkToAddGlobalUniqueEnchantments: () => (/* binding */ checkToAddGlobalUniqueEnchantments),\n/* harmony export */   checkToAddSpecifiedUniqueEnchantments: () => (/* binding */ checkToAddSpecifiedUniqueEnchantments)\n/* harmony export */ });\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_enemies_playerTurret__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enemies/playerTurret */ \"./app/enemies/playerTurret.ts\");\n/* harmony import */ var app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/uniqueEnchantmentHash */ \"./app/uniqueEnchantmentHash.ts\");\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_combat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/combat */ \"./app/utils/combat.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/rollWithMissBonus */ \"./app/utils/rollWithMissBonus.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst COMMON_UNIQUE_RATE = 0.1;\r\nconst UNCOMMON_UNIQUE_RATE = 0.01;\r\nconst RARE_UNIQUE_RATE = 0.001;\r\nconst tinkerer = {\r\n    key: 'tinkerer',\r\n    name: 'Tinkerer',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: UNCOMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Charged attacks creates turrets instead.',\r\n        ];\r\n    },\r\n    onActivateCharge(state, enchantment) {\r\n        const turret = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_5__.createEnemy)(state, state.hero.x, state.hero.y, app_enemies_playerTurret__WEBPACK_IMPORTED_MODULE_1__.playerTurret, state.hero.level, state.hero.disc);\r\n        turret.theta = state.hero.theta;\r\n        // This should be 2x charge attack duration\r\n        turret.params.duration = 4000;\r\n        turret.baseColor = 'blue';\r\n        // Charge level is reduced by 1 each time a turret is placed.\r\n        state.hero.chargingLevel--;\r\n        // Return true to disable default charge behavior.\r\n        return true;\r\n    },\r\n};\r\nconst wave = {\r\n    key: 'wave',\r\n    name: 'Wave',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: COMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            '25% increased attack speed.',\r\n            'Attack with oscillating shots.',\r\n        ];\r\n    },\r\n    modifyHero(state, enchantment) {\r\n        state.hero.attacksPerSecond *= 1.25;\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        const amplitude = 20;\r\n        bullet.amplitude = amplitude;\r\n        bullet.frequency = 4;\r\n        /*bullet.vx *= 0.9;\r\n        bullet.vy *= 0.9;\r\n        bullet.duration *= 1.1;*/\r\n    },\r\n};\r\nconst helix = {\r\n    key: 'helix',\r\n    name: 'Helix',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: RARE_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Attack with helix shots.',\r\n        ];\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        const amplitude = 45;\r\n        bullet.amplitude = amplitude;\r\n        bullet.frequency = 2;\r\n        //bullet.vx *= 0.9;\r\n        //bullet.vy *= 0.9;\r\n        //bullet.duration *= 1.1;\r\n        const doubleBullet = { ...bullet, hitTargets: new Set() };\r\n        doubleBullet.amplitude = -amplitude;\r\n        state.heroBullets.push(doubleBullet);\r\n    },\r\n};\r\nconst vicious = {\r\n    key: 'vicious',\r\n    name: 'Vicious',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: UNCOMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Weapon has +' + 20 * (enchantment.tier ** 2) + ' base damage.',\r\n        ];\r\n    },\r\n    modifyWeapon(enchantment, weapon) {\r\n        weapon.damage += 20 * (enchantment.tier ** 2);\r\n    }\r\n};\r\nconst kiting = {\r\n    key: 'kiting',\r\n    name: 'Kiting',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: UNCOMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Shots last longer and slow to a stop and deal damage over time.',\r\n        ];\r\n    },\r\n    modifyWeapon(enchantment, weapon) {\r\n        //weapon.speed *= 1.5;\r\n        weapon.range *= 1.5;\r\n        weapon.radius *= 1.5;\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        bullet.friction = 0.98;\r\n        bullet.duration += 1500;\r\n        //bullet.vx *= 1.75;\r\n        //bullet.vy *= 1.75;\r\n        bullet.damageOverTime = 4 * bullet.damage;\r\n        bullet.damageOverTimeLimit = state.hero.equipment.weapon.damageOverTimeStackSize * bullet.damageOverTime;\r\n    },\r\n};\r\nfunction updateBoomeringBullet(state, bullet) {\r\n    (0,app_utils_bullet__WEBPACK_IMPORTED_MODULE_3__.updateSimpleBullet)(state, bullet);\r\n    if (bullet.time >= bullet.duration / 2) {\r\n        bullet.damage *= 3;\r\n        bullet.vx = -bullet.vx;\r\n        bullet.vy = -bullet.vy;\r\n        bullet.update = app_utils_bullet__WEBPACK_IMPORTED_MODULE_3__.updateSourceSeekingBullet;\r\n    }\r\n}\r\nconst boomerang = {\r\n    key: 'boomerang',\r\n    name: 'Boomerang',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: UNCOMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Shots last longer and reverse direction.',\r\n            'Returning shots deal tripe damage'\r\n        ];\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        bullet.update = updateBoomeringBullet;\r\n        bullet.duration *= 1.5;\r\n    },\r\n    invalidTypes: ['morningStar'],\r\n};\r\nconst reversing = {\r\n    key: 'reversing',\r\n    name: 'Reversing',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: UNCOMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Shots last longer and reverse direction.',\r\n        ];\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        bullet.update = app_utils_bullet__WEBPACK_IMPORTED_MODULE_3__.updateReturnBullet;\r\n        bullet.duration *= 1.5;\r\n    },\r\n    invalidTypes: ['morningStar'],\r\n};\r\nconst vacuum = {\r\n    key: 'vacuum',\r\n    name: 'Vacuum',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: UNCOMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Shots spawn at range and move backwards.',\r\n        ];\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        const multiplier = bullet.duration / 1000;\r\n        bullet.baseX = bullet.x = bullet.x + bullet.vx * multiplier;\r\n        bullet.baseY = bullet.y = bullet.y + bullet.vy * multiplier;\r\n        bullet.vx *= -1.5;\r\n        bullet.vy *= -1.5;\r\n        if (bullet.theta !== undefined && bullet.vTheta !== undefined) {\r\n            bullet.theta = bullet.theta + bullet.vTheta * multiplier;\r\n            bullet.vTheta *= -1.5;\r\n        }\r\n        else {\r\n            bullet.update = app_utils_bullet__WEBPACK_IMPORTED_MODULE_3__.updateSourceSeekingBullet;\r\n        }\r\n    },\r\n    invalidTypes: ['morningStar'],\r\n};\r\nconst seeking = {\r\n    key: 'seeking',\r\n    name: 'Seeking',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: RARE_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Shots seek the nearest enemy.',\r\n        ];\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        bullet.update = app_utils_bullet__WEBPACK_IMPORTED_MODULE_3__.updateEnemySeekingBullet;\r\n    },\r\n    invalidTypes: ['morningStar'],\r\n};\r\nconst acid = {\r\n    key: 'acid',\r\n    name: 'Acid',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: RARE_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Shots deal 50% damage.',\r\n            'Shots create a damaging pool.',\r\n        ];\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        /*bullet.warningTime = 2 * bullet.duration / 3;\r\n        bullet.duration = bullet.warningTime + 1000;\r\n        bullet.damageOverTime = bullet.damage;\r\n        bullet.update = updateAcidBullet;*/\r\n        bullet.damage /= 2;\r\n        bullet.onHitOrDeath = (state, bullet) => {\r\n            const explosion = {\r\n                ...bullet,\r\n                time: 0,\r\n                damageOverTime: 3 * bullet.damage,\r\n                radius: 10,\r\n                duration: 1000,\r\n                vx: 0,\r\n                vy: 0,\r\n                hitTargets: new Set(),\r\n                onHitOrDeath: undefined,\r\n                update(state, bullet) {\r\n                    bullet.radius += 2;\r\n                },\r\n            };\r\n            state.heroBullets.push(explosion);\r\n        };\r\n    },\r\n};\r\nconst explosive = {\r\n    key: 'explosive',\r\n    name: 'Explosive',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: UNCOMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Shots explode dealing 50% of damage as AOE damage.',\r\n            'Shots deal 50% less damage for each enemy hit.',\r\n        ];\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        // bullet.warningTime = bullet.duration - 5 * FRAME_LENGTH;\r\n        // bullet.update = updateExplosiveBullet;\r\n        bullet.onHitOrDeath = (state, bullet) => {\r\n            bullet.damage /= 2;\r\n            const explosion = {\r\n                ...bullet,\r\n                time: 0,\r\n                radius: 10,\r\n                duration: 200,\r\n                isEnemyPiercing: true,\r\n                vx: 0,\r\n                vy: 0,\r\n                hitTargets: new Set(),\r\n                onHitOrDeath: undefined,\r\n                update(state, bullet) {\r\n                    bullet.radius *= 1.2;\r\n                },\r\n            };\r\n            state.heroBullets.push(explosion);\r\n        };\r\n    },\r\n};\r\nconst laser = {\r\n    key: 'laser',\r\n    name: 'Laser',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: RARE_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Attacks are very rapid but have reduced range and deal damage over time.',\r\n        ];\r\n    },\r\n    modifyHero(state, enchantment) {\r\n        state.hero.attacksPerSecond *= 5;\r\n    },\r\n    modifyWeapon(enchantment, weapon) {\r\n        weapon.range /= 3;\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        bullet.damageOverTime = 20 * bullet.damage;\r\n        bullet.damageOverTimeLimit = state.hero.equipment.weapon.damageOverTimeStackSize * bullet.damageOverTime;\r\n    },\r\n};\r\nconst trap = {\r\n    key: 'trap',\r\n    name: 'Trap',\r\n    enchantmentType: 'uniqueWeaponEnchantment',\r\n    chance: RARE_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Attacks with traps that trigger multiple shots on hit.',\r\n        ];\r\n    },\r\n    modifyWeapon(enchantment, weapon) {\r\n        const getBaseAttacksPerSecond = weapon.getAttacksPerSecond;\r\n        weapon.getAttacksPerSecond = (state, weapon) => getBaseAttacksPerSecond(state, weapon) / 3;\r\n    },\r\n    modifyBullet(state, enchantment, bullet) {\r\n        const baseDamage = bullet.damage;\r\n        const baesIsEnemyPiercing = bullet.isEnemyPiercing;\r\n        const baseArmorShred = bullet.armorShred;\r\n        bullet.damage = 0;\r\n        bullet.armorShred = 0;\r\n        bullet.isEnemyPiercing = false;\r\n        bullet.friction = 0.98;\r\n        bullet.duration += 2000;\r\n        bullet.onHit = function (state, bullet) {\r\n            const baseBullet = {\r\n                ...bullet,\r\n                damage: baseDamage,\r\n                isEnemyPiercing: baesIsEnemyPiercing,\r\n                armorShred: baseArmorShred,\r\n                friction: 0,\r\n                duration: 500,\r\n                time: 0,\r\n                onHit: undefined,\r\n                update: app_utils_bullet__WEBPACK_IMPORTED_MODULE_3__.updateSimpleBullet,\r\n            };\r\n            for (let i = 0; i < 6; i++) {\r\n                const theta = 2 * Math.PI * i / 6;\r\n                const dx = Math.cos(theta), dy = Math.sin(theta);\r\n                state.heroBullets.push({\r\n                    ...baseBullet,\r\n                    x: bullet.baseX + 250 * dx,\r\n                    y: bullet.baseY + 250 * dy,\r\n                    baseX: bullet.baseX + 250 * dx,\r\n                    baseY: bullet.baseY + 250 * dy,\r\n                    vx: -dx * window.BASE_BULLET_SPEED,\r\n                    vy: -dy * window.BASE_BULLET_SPEED,\r\n                    hitTargets: new Set(),\r\n                });\r\n            }\r\n        };\r\n    },\r\n};\r\nconst globalUniqueWeaponEnchantments = [\r\n    acid,\r\n    boomerang,\r\n    explosive,\r\n    helix,\r\n    kiting,\r\n    laser,\r\n    reversing,\r\n    seeking,\r\n    tinkerer,\r\n    trap,\r\n    vacuum,\r\n    vicious,\r\n    wave,\r\n];\r\nconst reinforced = {\r\n    key: 'reinforced',\r\n    name: 'Reinforced',\r\n    enchantmentType: 'uniqueArmorEnchantment',\r\n    chance: UNCOMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Armor has +' + 4 * enchantment.tier + ' base armor.',\r\n        ];\r\n    },\r\n    modifyArmor(enchantment, armor) {\r\n        armor.armor += 4 * enchantment.tier;\r\n    }\r\n};\r\nconst spongey = {\r\n    key: 'spongey',\r\n    name: 'Spongey',\r\n    enchantmentType: 'uniqueArmorEnchantment',\r\n    chance: UNCOMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Armor has +' + 20 * enchantment.tier * (enchantment.tier + 1) / 2 + ' base life.',\r\n        ];\r\n    },\r\n    modifyArmor(enchantment, armor) {\r\n        armor.life += 20 * enchantment.tier * (enchantment.tier + 1) / 2;\r\n    }\r\n};\r\nfunction getThornDamage(state, enchantment) {\r\n    const fakeEnemy = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_5__.createEnemy)(state, 0, 0, app_enemies_playerTurret__WEBPACK_IMPORTED_MODULE_1__.playerTurret, state.hero.equipment.armor.level, undefined);\r\n    return Math.ceil(fakeEnemy.maxLife / 20);\r\n}\r\nconst thorny = {\r\n    key: 'thorny',\r\n    name: 'Thorny',\r\n    enchantmentType: 'uniqueArmorEnchantment',\r\n    chance: COMMON_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Retaliate on hit for ' + (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_4__.abbreviate)(getThornDamage(state, enchantment)) + ' damage',\r\n        ];\r\n    },\r\n    onHit(state, enchantment) {\r\n        const bullet = (0,app_weapons__WEBPACK_IMPORTED_MODULE_8__.basicBullet)(state, state.hero, state.hero.equipment.weapon, state.mouse);\r\n        bullet.radius = 20;\r\n        bullet.damage = getThornDamage(state, enchantment);\r\n        bullet.chargeGain = 0;\r\n        bullet.armorShred = 0.05;\r\n        bullet.isEnemyPiercing = true;\r\n        bullet.isCrit = true;\r\n        const range = 300;\r\n        const speed = window.BASE_BULLET_SPEED;\r\n        bullet.duration = 1000 * range / speed;\r\n        for (let i = 0; i < 12; i++) {\r\n            const theta = 2 * Math.PI * i / 12;\r\n            state.heroBullets.push({\r\n                ...bullet,\r\n                vx: speed * Math.cos(theta),\r\n                vy: speed * Math.sin(theta),\r\n            });\r\n        }\r\n    }\r\n};\r\nfunction getSpikeDamage(state, enchantment) {\r\n    const fakeEnemy = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_5__.createEnemy)(state, 0, 0, app_enemies_playerTurret__WEBPACK_IMPORTED_MODULE_1__.playerTurret, state.hero.equipment.armor.level, undefined);\r\n    return Math.ceil(fakeEnemy.maxLife / 5);\r\n}\r\nconst spiky = {\r\n    key: 'spiky',\r\n    name: 'Spiky',\r\n    enchantmentType: 'uniqueArmorEnchantment',\r\n    chance: RARE_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Retaliate on hit for ' + (0,app_utils_combat__WEBPACK_IMPORTED_MODULE_4__.abbreviate)(getSpikeDamage(state, enchantment)) + ' damage',\r\n        ];\r\n    },\r\n    onHit(state, enchantment) {\r\n        const bullet = (0,app_weapons__WEBPACK_IMPORTED_MODULE_8__.basicBullet)(state, state.hero, state.hero.equipment.weapon, state.mouse);\r\n        bullet.radius = 20;\r\n        bullet.damage = getSpikeDamage(state, enchantment);\r\n        bullet.chargeGain = 0;\r\n        bullet.armorShred = 0.05;\r\n        bullet.isEnemyPiercing = true;\r\n        bullet.isCrit = true;\r\n        const range = 300;\r\n        const speed = window.BASE_BULLET_SPEED;\r\n        bullet.duration = 1000 * range / speed;\r\n        for (let i = 0; i < 12; i++) {\r\n            const theta = 2 * Math.PI * i / 12;\r\n            state.heroBullets.push({\r\n                ...bullet,\r\n                vx: speed * Math.cos(theta),\r\n                vy: speed * Math.sin(theta),\r\n            });\r\n        }\r\n    }\r\n};\r\nconst paladin = {\r\n    key: 'paladin',\r\n    name: 'Paladin',\r\n    enchantmentType: 'uniqueArmorEnchantment',\r\n    chance: RARE_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Shaving bullets restores 2% of missing health',\r\n        ];\r\n    },\r\n    onShave(state, enchantment) {\r\n        const missingHealth = state.hero.maxLife - state.hero.life;\r\n        state.hero.life = Math.min(state.hero.maxLife, Math.ceil(state.hero.life + missingHealth * 0.02));\r\n    },\r\n    flags: ['noShaveShrink', 'noShaveCharge'],\r\n};\r\nconst voidEnchantment = {\r\n    key: 'void',\r\n    name: 'Void',\r\n    enchantmentType: 'uniqueArmorEnchantment',\r\n    chance: RARE_UNIQUE_RATE,\r\n    getDescription(state, enchantment) {\r\n        return [\r\n            'Shaved bullets are destroyed',\r\n        ];\r\n    },\r\n    onShave(state, enchantment, bullet) {\r\n        bullet.duration = 0;\r\n    },\r\n    flags: ['noShaveShrink', 'noShaveCharge'],\r\n};\r\nconst globalUniqueArmorEnchantments = [\r\n    paladin,\r\n    reinforced,\r\n    spiky,\r\n    spongey,\r\n    thorny,\r\n    voidEnchantment,\r\n];\r\n(0,app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_2__.addUniqueEnchantments)(globalUniqueArmorEnchantments);\r\n(0,app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_2__.addUniqueEnchantments)(globalUniqueWeaponEnchantments);\r\nfunction createUniqueEnchantmentInstance(enchantment, level) {\r\n    return {\r\n        uniqueEnchantmentKey: enchantment.key,\r\n        enchantmentType: enchantment.enchantmentType,\r\n        tier: (0,app_enchantments__WEBPACK_IMPORTED_MODULE_0__.getEnchantmentStrength)(level),\r\n    };\r\n}\r\nfunction checkToAddGlobalUniqueEnchantments(state, item, chanceMultiplier = 1) {\r\n    if (item.type === 'weapon') {\r\n        checkToAddSpecifiedUniqueEnchantments(state, item, globalUniqueWeaponEnchantments, chanceMultiplier);\r\n    }\r\n    else if (item.type === 'armor') {\r\n        checkToAddSpecifiedUniqueEnchantments(state, item, globalUniqueArmorEnchantments, chanceMultiplier);\r\n    }\r\n}\r\nfunction checkToAddSpecifiedUniqueEnchantments(state, item, enchantments, chanceMultiplier = 1) {\r\n    const enchantment = app_utils_Random__WEBPACK_IMPORTED_MODULE_7__[\"default\"].element(enchantments.filter(e => { var _a; return !((_a = e.invalidTypes) === null || _a === void 0 ? void 0 : _a.includes(item.type === 'weapon' ? item.weaponType : item.armorType)); }));\r\n    if (!enchantment) {\r\n        return;\r\n    }\r\n    const levelMultiplier = 10 - 9 * item.level / 100;\r\n    if ((0,app_utils_rollWithMissBonus__WEBPACK_IMPORTED_MODULE_6__.rollWithMissBonus)(state, enchantment.key, enchantment.chance * chanceMultiplier * levelMultiplier)) {\r\n        addUniqueEnchantmentToItem(item, enchantment);\r\n        return;\r\n    }\r\n}\r\nfunction addUniqueEnchantmentToItem(item, enchantment) {\r\n    const instance = createUniqueEnchantmentInstance(enchantment, item.level);\r\n    item.bonusEnchantmentSlots.push(instance);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/uniqueEnchantments.ts?");

/***/ }),

/***/ "./app/utils/Random.ts":
/*!*****************************!*\
  !*** ./app/utils/Random.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Random = {\r\n    /**\r\n     * @param {number} min  The smallest returned value\r\n     * @param {number} max  The largest returned value\r\n     */\r\n    range(A, B) {\r\n        var min = Math.min(A, B);\r\n        var max = Math.max(A, B);\r\n        return Math.floor(Math.random() * (max + 1 - min)) + min;\r\n    },\r\n    /**\r\n     * @param {Collection} collection  The collection of elements to return random element from\r\n     */\r\n    element(collection) {\r\n        if (collection.constructor === Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = Random.element(keys);\r\n            return object[key];\r\n        }\r\n        if (collection.constructor === Array) {\r\n            const array = collection;\r\n            return array[Math.floor(Math.random() * array.length)];\r\n        }\r\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\r\n    },\r\n    /**\r\n     * @param {Array} array  The array of elements to return random element from\r\n     */\r\n    removeElement(collection) {\r\n        if (collection.constructor === Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = Random.element(keys);\r\n            const value = object[key];\r\n            delete object[key];\r\n            return value;\r\n        }\r\n        if (collection.constructor === Array) {\r\n            const array = collection;\r\n            return array.splice(Math.floor(Math.random() * array.length), 1)[0];\r\n        }\r\n        throw new Error(\"Warning @ Random.removeElement: \" + collection + \" is neither Array or Object\");\r\n    },\r\n    /**\r\n     * Shuffles an array.\r\n     *\r\n     * Knuth algorithm found at:\r\n     * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n     *\r\n     * @param {Array} array  The array of elements to shuffle\r\n     */\r\n    shuffle(array) {\r\n        array = [...array];\r\n        let currentIndex = array.length, temporaryValue, randomIndex;\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(Math.random() * currentIndex);\r\n            currentIndex -= 1;\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n        return array;\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Random);\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/Random.ts?");

/***/ }),

/***/ "./app/utils/SRandom.ts":
/*!******************************!*\
  !*** ./app/utils/SRandom.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst MAX_INT = 2 ** 32;\r\n// Decent pseudo random number generator based on:\r\n// https://en.wikipedia.org/wiki/Xorshift\r\n// Values seem fairly evenly distributed on [0, 1)\r\nfunction nextSeed(seed) {\r\n    let x = Math.floor(MAX_INT * seed);\r\n    x ^= x << 13;\r\n    x ^= x >> 17;\r\n    x ^= x << 5;\r\n    return (x / MAX_INT) + 0.5;\r\n}\r\nfunction numberToSeed(number) {\r\n    return nextSeed((Math.cos(number) + 1) / 2);\r\n}\r\n// Seeded random number generator.\r\nclass SRandom {\r\n    constructor(seed) {\r\n        this._seed = seed;\r\n    }\r\n    // Return an instance of SRandom with a seed based on the given value.\r\n    seed(value) {\r\n        return new SRandom(numberToSeed(value));\r\n    }\r\n    // Create a new seed based on the current seed and a given value.\r\n    addSeed(value) {\r\n        return this.seed(this._seed + value);\r\n    }\r\n    nextSeed() {\r\n        return new SRandom(nextSeed(this._seed));\r\n    }\r\n    random() {\r\n        return nextSeed(this._seed);\r\n    }\r\n    // This generates a random number and advances *this* geneator to the next seed.\r\n    generateAndMutate() {\r\n        this._seed = nextSeed(this._seed);\r\n        return this._seed;\r\n    }\r\n    /**\r\n     * @param {number} min  The smallest returned value\r\n     * @param {number} max  The largest returned value\r\n     */\r\n    range(A, B) {\r\n        var min = Math.min(A, B);\r\n        var max = Math.max(A, B);\r\n        return Math.floor(this.random() * (max + 1 - min)) + min;\r\n    }\r\n    /**\r\n     * @param {Collection} collection  The collection of elements to return random element from\r\n     */\r\n    element(collection) {\r\n        if (collection.constructor == Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = this.element(keys);\r\n            return object[key];\r\n        }\r\n        if (collection.constructor == Array) {\r\n            const array = collection;\r\n            return array[Math.floor(this.random() * array.length)];\r\n        }\r\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\r\n    }\r\n    /**\r\n     * @param {Array} array  The array of elements to return random element from\r\n     */\r\n    removeElement(collection) {\r\n        if (collection.constructor == Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = this.element(keys);\r\n            const value = object[key];\r\n            delete object[key];\r\n            return value;\r\n        }\r\n        if (collection.constructor == Array) {\r\n            const array = collection;\r\n            return array.splice(Math.floor(this.random() * array.length), 1)[0];\r\n        }\r\n        throw new Error(\"Warning @ Random.removeElement: \" + collection + \" is neither Array or Object\");\r\n    }\r\n    /**\r\n     * Shuffles an array.\r\n     *\r\n     * Knuth algorithm found at:\r\n     * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n     *\r\n     * @param {Array} array  The array of elements to shuffle\r\n     */\r\n    shuffle(array) {\r\n        let randomizer = this;\r\n        array = [...array];\r\n        let currentIndex = array.length, temporaryValue, randomIndex;\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(randomizer.random() * currentIndex);\r\n            randomizer = randomizer.nextSeed();\r\n            currentIndex -= 1;\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n;\r\nconst instance = new SRandom(0.5);\r\n// @ts-ignore\r\nwindow['SRandom'] = instance;\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/SRandom.ts?");

/***/ }),

/***/ "./app/utils/audio.ts":
/*!****************************!*\
  !*** ./app/utils/audio.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   playSound: () => (/* binding */ playSound),\n/* harmony export */   playTrack: () => (/* binding */ playTrack),\n/* harmony export */   setVolume: () => (/* binding */ setVolume)\n/* harmony export */ });\n/* harmony import */ var app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/noteFrequencies */ \"./app/utils/noteFrequencies.ts\");\n\r\n// Safari uses webkitAudioContext instead of AudioContext.\r\nconst audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n// @ts-ignore\r\nwindow['audioContext'] = audioContext;\r\nconst sounds = new Map();\r\n// @ts-ignore\r\nwindow['sounds'] = sounds;\r\nconst tracks = {};\r\n// @ts-ignore\r\nwindow['tracks'] = tracks;\r\nfunction playSound(state, key) {\r\n    const sfx = sounds.get(key);\r\n    if (sfx) {\r\n        sfx.play();\r\n    }\r\n}\r\nlet currentTrack;\r\nfunction playTrack(state, key) {\r\n    if (currentTrack === null || currentTrack === void 0 ? void 0 : currentTrack.isPlaying) {\r\n        currentTrack.stop();\r\n        currentTrack = undefined;\r\n    }\r\n    const track = tracks[key];\r\n    if (track) {\r\n        track.play(state, 0.3);\r\n        currentTrack = track;\r\n    }\r\n}\r\nfunction makeDistortionCurve(amount) {\r\n    let k = typeof amount === 'number' ? amount : 50, n_samples = 44100, curve = new Float32Array(n_samples), deg = Math.PI / 180, i = 0, x;\r\n    for (; i < n_samples; ++i) {\r\n        x = i * 2 / n_samples - 1;\r\n        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\r\n    }\r\n    return curve;\r\n}\r\n;\r\nconst distortionCurve = makeDistortionCurve(50);\r\n// Plays beeps in sequence\r\nfunction playBeeps(inputFrequencies, volume, duration, { smooth = false, swell = false, taper = false, distortion = false }) {\r\n    const frequencies = Float32Array.from(inputFrequencies);\r\n    const oscillator = audioContext.createOscillator();\r\n    oscillator.type = 'square';\r\n    if (smooth)\r\n        oscillator.frequency.setValueCurveAtTime(frequencies, audioContext.currentTime, duration);\r\n    else {\r\n        for (var i = 0; i < frequencies.length; i++) {\r\n            oscillator.frequency.setValueAtTime(frequencies[i], audioContext.currentTime + duration * i / frequencies.length);\r\n        }\r\n    }\r\n    let lastNode = oscillator;\r\n    if (distortion) {\r\n        const distortionNode = audioContext.createWaveShaper();\r\n        distortionNode.curve = distortionCurve;\r\n        distortionNode.oversample = '4x';\r\n        lastNode.connect(distortionNode);\r\n        lastNode = distortionNode;\r\n    }\r\n    const gainNode = audioContext.createGain();\r\n    if (swell) {\r\n        gainNode.gain.setValueAtTime(0, audioContext.currentTime);\r\n        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + duration * .1);\r\n    }\r\n    else {\r\n        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);\r\n    }\r\n    if (taper) {\r\n        gainNode.gain.setValueAtTime(volume, audioContext.currentTime + duration * .9);\r\n        // gainNode.gain.setTargetAtTime(0, audioContext.currentTime, duration / 10);\r\n        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);\r\n    }\r\n    lastNode.connect(gainNode);\r\n    lastNode = gainNode;\r\n    lastNode.connect(masterVolumeNode);\r\n    oscillator.start();\r\n    oscillator.stop(audioContext.currentTime + duration);\r\n    oscillator.onended = function () {\r\n        lastNode.disconnect(masterVolumeNode);\r\n    };\r\n}\r\n// @ts-ignore\r\nwindow['playBeeps'] = playBeeps;\r\nfunction vibratoNode(duration, frequency, gain) {\r\n    const waveNode = audioContext.createOscillator();\r\n    waveNode.frequency.value = frequency;\r\n    const gainNode = audioContext.createGain();\r\n    gainNode.gain.value = gain;\r\n    waveNode.connect(gainNode);\r\n    waveNode.start(audioContext.currentTime);\r\n    waveNode.stop(audioContext.currentTime + duration);\r\n    waveNode.onended = function () {\r\n        waveNode.disconnect(gainNode);\r\n    };\r\n    return gainNode;\r\n}\r\n// @ts-ignore\r\nwindow['vibratoNode'] = vibratoNode;\r\nfunction glideNode(duration, glideStart, glideEnd, gain) {\r\n    const constantNode = audioContext.createConstantSource();\r\n    const gainNode = audioContext.createGain();\r\n    gainNode.gain.setValueAtTime(0, audioContext.currentTime + glideStart);\r\n    gainNode.gain.linearRampToValueAtTime(gain, audioContext.currentTime + glideEnd);\r\n    constantNode.connect(gainNode);\r\n    constantNode.start(audioContext.currentTime);\r\n    constantNode.stop(audioContext.currentTime + duration);\r\n    constantNode.onended = function () {\r\n        constantNode.disconnect(gainNode);\r\n    };\r\n    return gainNode;\r\n}\r\n// @ts-ignore\r\nwindow['glideNode'] = glideNode;\r\nfunction mergeNodes(nodes) {\r\n    const gainNode = audioContext.createGain();\r\n    for (const node of nodes) {\r\n        node.connect(gainNode);\r\n    }\r\n    return gainNode;\r\n}\r\n// @ts-ignore\r\nwindow['mergeNodes'] = mergeNodes;\r\nfunction playSimpleSoundAt(frequencies, volume, duration, { oscillatorType = 'sine', attackTime = 0.003, fadeTime = 0.1 * duration, frequencyVolumeFactor = 1, frequencyDurationFactor = 1, bandpassFrequency, highpassFrequency, pitchNode, } = {}, time = audioContext.currentTime, destination = masterVolumeNode) {\r\n    const combinedGainNode = audioContext.createGain();\r\n    combinedGainNode.gain.value = volume;\r\n    let lastNode = combinedGainNode;\r\n    if (bandpassFrequency) {\r\n        const filterNode = audioContext.createBiquadFilter();\r\n        filterNode.frequency.value = bandpassFrequency;\r\n        filterNode.type = 'bandpass';\r\n        lastNode.connect(filterNode);\r\n        lastNode = filterNode;\r\n    }\r\n    if (highpassFrequency) {\r\n        const filterNode = audioContext.createBiquadFilter();\r\n        filterNode.frequency.value = highpassFrequency;\r\n        filterNode.type = 'highpass';\r\n        lastNode.connect(filterNode);\r\n        lastNode = filterNode;\r\n    }\r\n    lastNode.connect(destination);\r\n    const frequenciesArray = Float32Array.from(frequencies);\r\n    let frequencyVolume = 1;\r\n    let frequencyDuration = duration;\r\n    for (const frequency of frequenciesArray) {\r\n        let fadeDuration = Math.min(fadeTime, frequencyDuration - attackTime);\r\n        const gainNode = audioContext.createGain();\r\n        gainNode.gain.setValueAtTime(0, time);\r\n        gainNode.gain.linearRampToValueAtTime(frequencyVolume, time + attackTime);\r\n        gainNode.gain.setValueAtTime(frequencyVolume, time + duration - fadeDuration);\r\n        gainNode.gain.linearRampToValueAtTime(0, time + duration);\r\n        const oscillator = audioContext.createOscillator();\r\n        oscillator.frequency.value = frequency;\r\n        /*if (pitchVibratoGain && pitchVibratoFrequency) {\r\n            const vibratoOscillator = audioContext.createOscillator();\r\n            vibratoOscillator.frequency.value = pitchVibratoFrequency;\r\n            const vibratoGain = audioContext.createGain();\r\n            vibratoGain.gain.value = pitchVibratoGain;\r\n            vibratoOscillator.connect(vibratoGain).connect(oscillator.frequency);\r\n            console.log('adding pitch vibrato');\r\n            vibratoOscillator.start(time);\r\n            vibratoOscillator.stop(time + duration);\r\n        }*/\r\n        if (pitchNode) {\r\n            pitchNode.connect(oscillator.frequency);\r\n        }\r\n        oscillator.type = oscillatorType;\r\n        oscillator.connect(gainNode);\r\n        oscillator.start(time);\r\n        oscillator.stop(time + duration);\r\n        oscillator.onended = () => {\r\n            if (pitchNode) {\r\n                pitchNode.disconnect(oscillator.frequency);\r\n            }\r\n            oscillator.disconnect(gainNode);\r\n            gainNode.disconnect(combinedGainNode);\r\n        };\r\n        frequencyVolume *= frequencyVolumeFactor;\r\n        frequencyDuration *= frequencyDurationFactor;\r\n        gainNode.connect(combinedGainNode);\r\n    }\r\n    setTimeout(() => {\r\n        lastNode.disconnect(destination);\r\n    }, 1000 * (time - audioContext.currentTime + duration));\r\n}\r\n// @ts-ignore\r\nwindow['playSimpleSoundAt'] = playSimpleSoundAt;\r\nconst masterVolumeNode = audioContext.createGain();\r\nmasterVolumeNode.connect(audioContext.destination);\r\nfunction setVolume(volume) {\r\n    masterVolumeNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.1);\r\n}\r\nfunction playBellSoundAt(frequencies, volume, duration, time = audioContext.currentTime, destination = masterVolumeNode) {\r\n    const combinedGainNode = audioContext.createGain();\r\n    combinedGainNode.connect(destination);\r\n    combinedGainNode.gain.value = volume;\r\n    const frequenciesArray = Float32Array.from(frequencies);\r\n    const attackTime = 0.003;\r\n    let frequencyVolume = 0.5;\r\n    let fadeDuration = duration - attackTime;\r\n    for (const frequency of frequenciesArray) {\r\n        const gainNode = audioContext.createGain();\r\n        gainNode.gain.setValueAtTime(0, time);\r\n        gainNode.gain.linearRampToValueAtTime(frequencyVolume, time + attackTime);\r\n        gainNode.gain.setValueAtTime(frequencyVolume, time + attackTime);\r\n        gainNode.gain.linearRampToValueAtTime(0, time + attackTime + fadeDuration);\r\n        const oscillator = audioContext.createOscillator();\r\n        oscillator.frequency.value = frequency;\r\n        oscillator.type = 'sine';\r\n        oscillator.connect(gainNode);\r\n        oscillator.start(time);\r\n        oscillator.stop(time + duration);\r\n        frequencyVolume *= 0.5;\r\n        fadeDuration *= 0.75;\r\n        gainNode.connect(combinedGainNode);\r\n    }\r\n    setTimeout(() => {\r\n        combinedGainNode.disconnect(destination);\r\n    }, 1000 * (time - audioContext.currentTime + duration));\r\n}\r\n// @ts-ignore\r\nwindow['playBellSoundAt'] = playBellSoundAt;\r\nfunction playScale(coreFrequenciess, callback, interval = 500) {\r\n    let index = 0;\r\n    const intervalId = setInterval(() => {\r\n        const frequency = coreFrequenciess[index++];\r\n        if (!frequency) {\r\n            clearInterval(intervalId);\r\n            return;\r\n        }\r\n        callback(frequency);\r\n    }, interval);\r\n}\r\n// @ts-ignore\r\nwindow['playScale'] = playScale;\r\nsounds.set('reflect', {\r\n    play() {\r\n        playBeeps([2000, 8000, 4000], .01, .1, {});\r\n    }\r\n});\r\nsounds.set('wand', {\r\n    play() {\r\n        playBeeps([1200, 400], 0.1, .1, { smooth: true, taper: true, swell: true, distortion: true });\r\n    }\r\n});\r\nsounds.set('takeDamage', {\r\n    play() {\r\n        playBeeps([100, 50], 0.2, 0.2, { smooth: true, distortion: true });\r\n    }\r\n});\r\nsounds.set('takeBigDamage', {\r\n    play() {\r\n        playBeeps([200, 100, 100, 200, 100, 50, 50], 0.5, 0.3, { smooth: true, distortion: true });\r\n    }\r\n});\r\n// This gets replaced once audio worklets load.\r\nsounds.set('dealDamage', {\r\n    play() {\r\n        playBeeps([200, 230, 200, 230], 0.1, 0.1, { smooth: true, distortion: true });\r\n    }\r\n});\r\nsounds.set('chargeReady', {\r\n    play() {\r\n        playSimpleSoundAt([100], 0.05, 0.5, { oscillatorType: 'square', pitchNode: glideNode(0.5, 0, 0.5, 100), attackTime: 0.1, fadeTime: 0.4 });\r\n    }\r\n});\r\nsounds.set('activateCharge', {\r\n    play() {\r\n        //playSimpleSoundAt([120], 0.05, 2, {oscillatorType: 'square', pitchNode: mergeNodes([glideNode(2, 0, 0.5, 80), vibratoNode(2, 10, 5)]), attackTime: 0.1, fadeTime: 0.1});\r\n        playSimpleSoundAt([100], 0.2, 2, { oscillatorType: 'triangle', pitchNode: mergeNodes([glideNode(2, 0, 1, 100), vibratoNode(2, 20, 10)]), attackTime: 0.1, fadeTime: 0.1 });\r\n    }\r\n});\r\nasync function registerAndUseAudioWorklets() {\r\n    await audioContext.audioWorklet.addModule('audio/gain-processor.js');\r\n    await audioContext.audioWorklet.addModule('audio/white-noise-processor.js');\r\n    await audioContext.audioWorklet.addModule('audio/pink-noise-processor.js');\r\n    await audioContext.audioWorklet.addModule('audio/brown-noise-processor.js');\r\n    const pinkNoiseNode = new AudioWorkletNode(audioContext, 'pink-noise');\r\n    const brownNoiseNode = new AudioWorkletNode(audioContext, 'brown-noise');\r\n    //const gainWorkletNode = new AudioWorkletNode(audioContext, 'gain');\r\n    /*const whiteNoiseNode = new AudioWorkletNode(audioContext, 'white-noise');\r\n    const gainParam = gainWorkletNode.parameters.get('gain')!;\r\n    gainParam.setValueAtTime(0, audioContext.currentTime);\r\n    gainParam.linearRampToValueAtTime(0.8, audioContext.currentTime + .05);\r\n    gainParam.linearRampToValueAtTime(0, audioContext.currentTime + .1);*/\r\n    //whiteNoiseNode.connect(gainWorkletNode).connect(masterVolumeNode);\r\n    //pinkNoiseNode.connect(gainWorkletNode).connect(masterVolumeNode);\r\n    //setTimeout(() => gainWorkletNode.disconnect(masterVolumeNode), 2000);\r\n    sounds.set('dealDamage', {\r\n        play() {\r\n            const noiseGainNode = new AudioWorkletNode(audioContext, 'gain');\r\n            const noiseGainParam = noiseGainNode.parameters.get('gain');\r\n            noiseGainParam.setValueAtTime(0, audioContext.currentTime);\r\n            noiseGainParam.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.1);\r\n            noiseGainParam.linearRampToValueAtTime(0, audioContext.currentTime + 0.15);\r\n            pinkNoiseNode.connect(noiseGainNode);\r\n            noiseGainNode.connect(masterVolumeNode);\r\n            const waveGainNode = new AudioWorkletNode(audioContext, 'gain');\r\n            const waveGainParam = waveGainNode.parameters.get('gain');\r\n            waveGainParam.setValueAtTime(0.1, audioContext.currentTime);\r\n            waveGainParam.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);\r\n            const oscillator = audioContext.createOscillator();\r\n            oscillator.type = 'sine';\r\n            oscillator.frequency.setValueAtTime(500, audioContext.currentTime);\r\n            oscillator.frequency.linearRampToValueAtTime(50, audioContext.currentTime + 0.02);\r\n            oscillator.connect(waveGainNode);\r\n            waveGainNode.connect(masterVolumeNode);\r\n            oscillator.start(audioContext.currentTime);\r\n            oscillator.stop(audioContext.currentTime + 0.1);\r\n            oscillator.onended = function () {\r\n                pinkNoiseNode.disconnect(noiseGainNode);\r\n                noiseGainNode.port.postMessage('done');\r\n                noiseGainNode.disconnect(masterVolumeNode);\r\n                oscillator.disconnect(waveGainNode);\r\n                waveGainNode.port.postMessage('done');\r\n                waveGainNode.disconnect(masterVolumeNode);\r\n            };\r\n        }\r\n    });\r\n    sounds.set('shaveBullet', {\r\n        play() {\r\n            const gainNode = audioContext.createGain();\r\n            gainNode.gain.setValueAtTime(0, audioContext.currentTime);\r\n            gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.1);\r\n            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);\r\n            pinkNoiseNode.connect(gainNode);\r\n            gainNode.connect(masterVolumeNode);\r\n            setTimeout(() => {\r\n                pinkNoiseNode.disconnect(gainNode);\r\n                gainNode.disconnect(masterVolumeNode);\r\n            }, 400);\r\n        }\r\n    });\r\n    sounds.set('defeatEnemy', {\r\n        play() {\r\n            const gainNode = audioContext.createGain();\r\n            gainNode.gain.setValueAtTime(0, audioContext.currentTime);\r\n            gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.1);\r\n            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.3);\r\n            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.4);\r\n            brownNoiseNode.connect(gainNode);\r\n            gainNode.connect(masterVolumeNode);\r\n            setTimeout(() => {\r\n                brownNoiseNode.disconnect(gainNode);\r\n                gainNode.disconnect(masterVolumeNode);\r\n            }, 400);\r\n        }\r\n    });\r\n    tracks.beach = {\r\n        isPlaying: false,\r\n        masterNode: new AudioWorkletNode(audioContext, 'gain'),\r\n        waterGainNode: new AudioWorkletNode(audioContext, 'gain'),\r\n        // Times are all in seconds.\r\n        lastTrackTime: 0,\r\n        lastContextTime: 0,\r\n        lastScheduledTime: 0,\r\n        initialized: false,\r\n        play(state, volume) {\r\n            if (this.isPlaying) {\r\n                return;\r\n            }\r\n            console.log('playing beach');\r\n            this.isPlaying = true;\r\n            state.audio.playingTracks.push(this);\r\n            const masterGainParam = this.masterNode.parameters.get('gain');\r\n            masterGainParam.setValueAtTime(volume, audioContext.currentTime);\r\n            this.masterNode.connect(masterVolumeNode);\r\n            this.lastTrackTime = 0;\r\n            if (!this.initialized) {\r\n                console.log('initializing beach');\r\n                pinkNoiseNode.connect(this.waterGainNode);\r\n                this.initialized = true;\r\n                this.waterGainNode.connect(this.masterNode);\r\n                const waterGainParam = this.waterGainNode.parameters.get('gain');\r\n                waterGainParam.linearRampToValueAtTime(0, 0);\r\n            }\r\n        },\r\n        update(state) {\r\n            // this.waterSound.update(this.temp);\r\n            if (!this.isPlaying) {\r\n                return;\r\n            }\r\n            const trackTime = this.lastTrackTime + (audioContext.currentTime - this.lastContextTime);\r\n            // Want to make the water gain node fade in and out over 2 second intervals.\r\n            if (this.lastScheduledTime <= trackTime + 4) {\r\n                const nextTime = this.lastScheduledTime + 4;\r\n                const waterGainParam = this.waterGainNode.parameters.get('gain');\r\n                // console.log('fading in+ out', this.lastScheduledTime + 1, this.lastScheduledTime + 4);\r\n                waterGainParam.linearRampToValueAtTime(0.2, this.lastScheduledTime + 1);\r\n                waterGainParam.linearRampToValueAtTime(0.1, this.lastScheduledTime + 2);\r\n                waterGainParam.linearRampToValueAtTime(0.3, this.lastScheduledTime + 3);\r\n                waterGainParam.linearRampToValueAtTime(0.05, this.lastScheduledTime + 4);\r\n                if (this.lastScheduledTime % 32 >= 0) {\r\n                    if (this.lastScheduledTime % 8 === 0) {\r\n                        /*playZeldaSquareAt(noteFrequencies.C4, 1, this.lastScheduledTime, this.masterNode);\r\n                        playZeldaSquareAt(noteFrequencies.B3, 1, this.lastScheduledTime + 1, this.masterNode);\r\n                        playZeldaSquareAt(noteFrequencies.A3, 1, this.lastScheduledTime + 2, this.masterNode);\r\n                        playZeldaSquareAt(noteFrequencies.G3, 1, this.lastScheduledTime + 3, this.masterNode);*/\r\n                        playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.C6), 0.4, 2, this.lastScheduledTime, this.masterNode);\r\n                        playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.B5), 0.4, 2, this.lastScheduledTime + 1, this.masterNode);\r\n                        playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.A5), 0.4, 2, this.lastScheduledTime + 2, this.masterNode);\r\n                        playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.G5), 0.4, 2, this.lastScheduledTime + 3, this.masterNode);\r\n                    }\r\n                    else if (this.lastScheduledTime % 8 === 4) {\r\n                        playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.G5), 0.4, 2, this.lastScheduledTime, this.masterNode);\r\n                        playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.A5), 0.4, 2, this.lastScheduledTime + 1, this.masterNode);\r\n                        playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.B5), 0.4, 2, this.lastScheduledTime + 2, this.masterNode);\r\n                        playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.C6), 0.4, 2, this.lastScheduledTime + 3, this.masterNode);\r\n                    }\r\n                }\r\n                if (this.lastScheduledTime % 32 >= 0 && (this.lastScheduledTime % 32 < 16 || this.lastScheduledTime % 32 >= 24)) {\r\n                    playHihatSoundAt(40, 0.4, this.lastScheduledTime + 0, this.masterNode);\r\n                    playHihatSoundAt(40, 0.2, this.lastScheduledTime + 0.5, this.masterNode);\r\n                    playHihatSoundAt(40, 0.2, this.lastScheduledTime + 0.75, this.masterNode);\r\n                    playHihatSoundAt(40, 0.4, this.lastScheduledTime + 1, this.masterNode);\r\n                    playHihatSoundAt(40, 0.2, this.lastScheduledTime + 1.5, this.masterNode);\r\n                    playHihatSoundAt(40, 0.4, this.lastScheduledTime + 1.75, this.masterNode);\r\n                    playHihatSoundAt(40, 0.2, this.lastScheduledTime + 2.25, this.masterNode);\r\n                    playHihatSoundAt(40, 0.4, this.lastScheduledTime + 2.5, this.masterNode);\r\n                    playHihatSoundAt(40, 0.4, this.lastScheduledTime + 3, this.masterNode);\r\n                    playHihatSoundAt(40, 0.4, this.lastScheduledTime + 3.5, this.masterNode);\r\n                }\r\n                if (this.lastScheduledTime % 32 >= 8) {\r\n                    playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.C6), 0.4, 1, this.lastScheduledTime, this.masterNode);\r\n                    playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.E6), 0.4, 1, this.lastScheduledTime + 0.5, this.masterNode);\r\n                    playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.G6), 0.4, 1, this.lastScheduledTime + 1, this.masterNode);\r\n                    playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.E6), 0.4, 1, this.lastScheduledTime + 1.5, this.masterNode);\r\n                    playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.G6), 0.4, 1, this.lastScheduledTime + 2, this.masterNode);\r\n                    playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.C7), 0.4, 1, this.lastScheduledTime + 2.5, this.masterNode);\r\n                    playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.G6), 0.4, 1, this.lastScheduledTime + 3, this.masterNode);\r\n                    playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies.E6), 0.4, 1, this.lastScheduledTime + 3.5, this.masterNode);\r\n                }\r\n                this.lastScheduledTime = nextTime;\r\n            }\r\n        },\r\n        stop(state) {\r\n            if (!this.isPlaying) {\r\n                return;\r\n            }\r\n            console.log('stopping beach');\r\n            const index = state.audio.playingTracks.indexOf(this);\r\n            if (index >= 0) {\r\n                state.audio.playingTracks.splice(index, 1);\r\n            }\r\n            this.isPlaying = false;\r\n            this.masterNode.disconnect(masterVolumeNode);\r\n        }\r\n    };\r\n}\r\nregisterAndUseAudioWorklets();\r\n/*\r\nclass RandomNoiseProcessor extends AudioWorkletProcessor {\r\n  process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>) {\r\n    const noiseRandomizer = SRandom.seed(1337);\r\n    const output = outputs[0];\r\n    output.forEach((channel) => {\r\n      for (let i = 0; i < channel.length; i++) {\r\n        channel[i] = noiseRandomizer.generateAndMutate() * 2 - 1;\r\n      }\r\n    });\r\n    return true;\r\n  }\r\n}\r\n\r\nregisterProcessor(\"random-noise-processor\", RandomNoiseProcessor);*/\r\n/*\r\n\r\nfunction generateWhiteNoiseBuffer(seconds: number): AudioBuffer {\r\n    const noiseRandomizer = SRandom.seed(1337);\r\n    const bufferSize = 2 * audioContext.sampleRate;\r\n    const whiteNoiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);\r\n    const output = whiteNoiseBuffer.getChannelData(0);\r\n    for (var i = 0; i < bufferSize; i++) {\r\n        output[i] = noiseRandomizer.generateAndMutate() * 2 - 1;\r\n    }\r\n    return whiteNoiseBuffer;\r\n}\r\nconst whiteNoiseBuffer = generateWhiteNoiseBuffer(2);\r\n// @ts-ignore\r\nwindow['whiteNoiseBuffer'] = whiteNoiseBuffer;*/\r\n/*\r\nvar whiteNoise = audioContext.createBufferSource();\r\nwhiteNoise.buffer = whiteNoiseBuffer;\r\nwhiteNoise.loop = true;\r\nwhiteNoise.start(0);\r\n\r\nwhiteNoise.connect(masterVolumeNode);\r\n*/\r\n// Frequencies from https://www.computermusicresource.com/Simple.bell.tutorial.html\r\nconst bellFrequencies = [0.56, 0.92, 1.19, 1.71, 2, 2.74, 3, 3.76, 4.07];\r\nfunction getBellFrequencies(baseFrequency) {\r\n    return bellFrequencies.map(n => baseFrequency * n);\r\n}\r\n// Frequencies etc from http://joesul.li/van/synthesizing-hi-hats/\r\nconst hiHatFrequencies = [2, 3, 4.16, 5.43, 6.79, 8.21];\r\nfunction getHiHatFrequencies(baseFrequency) {\r\n    return hiHatFrequencies.map(n => baseFrequency * n);\r\n}\r\n// @ts-ignore\r\nwindow['getHiHatFrequencies'] = getHiHatFrequencies;\r\nconst notes = Object.keys(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies);\r\nfunction majorScale(allNotes, baseNote) {\r\n    return allNotes.filter((x, i) => [0, 2, 4, 5, 7, 9, 11].includes((i - baseNote + 11) % 12));\r\n}\r\nconst frequencies = {};\r\nfrequencies.western = Object.values(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies);\r\nfrequencies.midWestern = Object.values(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies).slice(36, 72);\r\nfrequencies.cMajor = majorScale(frequencies.midWestern, 0);\r\n// @ts-ignore\r\nwindow['frequencies'] = frequencies;\r\nnotes.forEach((noteName) => {\r\n    sounds.set(`bell${noteName}`, {\r\n        play() {\r\n            playBellSoundAt(getBellFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies[noteName]), 0.2, 2);\r\n        }\r\n    });\r\n});\r\nfunction playHihatSoundAt(frequency, duration = 0.1, time = audioContext.currentTime, destination = masterVolumeNode) {\r\n    playSimpleSoundAt(getHiHatFrequencies(frequency), 0.5, duration, {\r\n        oscillatorType: 'square',\r\n        attackTime: 0.002,\r\n        fadeTime: duration - 0.005,\r\n        bandpassFrequency: 10000,\r\n        highpassFrequency: 7000,\r\n    }, time, destination);\r\n}\r\n// @ts-ignore\r\nwindow['playHihatSoundAt'] = playHihatSoundAt;\r\nfunction playZeldaSquareAt(frequency, duration = 0.2, time = audioContext.currentTime, destination = masterVolumeNode) {\r\n    const vibrato = vibratoNode(duration, 8, 1);\r\n    playSimpleSoundAt([frequency], 0.1, duration, {\r\n        oscillatorType: 'square',\r\n        pitchNode: vibrato,\r\n        //pitchVibratoFrequency: 8,\r\n        //pitchVibratoGain: 1\r\n    }, time, destination);\r\n}\r\n// @ts-ignore\r\nwindow['playZeldaSquareAt'] = playZeldaSquareAt;\r\nnotes.forEach((noteName) => {\r\n    sounds.set(`hiHat${noteName}`, {\r\n        play() {\r\n            playSimpleSoundAt(getHiHatFrequencies(app_utils_noteFrequencies__WEBPACK_IMPORTED_MODULE_0__.noteFrequencies[noteName]), 0.2, 0.2, {\r\n                oscillatorType: 'square',\r\n                attackTime: 0.003,\r\n                fadeTime: 0.1,\r\n                bandpassFrequency: 10000,\r\n                highpassFrequency: 7000,\r\n                //frequencyVolumeFactor = 1,\r\n                //frequencyDurationFactor = 1,\r\n            });\r\n        }\r\n    });\r\n});\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/audio.ts?");

/***/ }),

/***/ "./app/utils/bullet.ts":
/*!*****************************!*\
  !*** ./app/utils/bullet.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isEnemyTargetable: () => (/* binding */ isEnemyTargetable),\n/* harmony export */   updateBoomeringBullet: () => (/* binding */ updateBoomeringBullet),\n/* harmony export */   updateCirclingBullet: () => (/* binding */ updateCirclingBullet),\n/* harmony export */   updateEnemySeekingBullet: () => (/* binding */ updateEnemySeekingBullet),\n/* harmony export */   updateHeroSeekingBullet: () => (/* binding */ updateHeroSeekingBullet),\n/* harmony export */   updateReturnBullet: () => (/* binding */ updateReturnBullet),\n/* harmony export */   updateSimpleBullet: () => (/* binding */ updateSimpleBullet),\n/* harmony export */   updateSourceSeekingBullet: () => (/* binding */ updateSourceSeekingBullet)\n/* harmony export */ });\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\nfunction updateCirclingBullet(state, bullet) {\r\n    const anchor = bullet.anchor || bullet.source;\r\n    if (!anchor\r\n        || typeof (bullet.theta) !== 'number'\r\n        || typeof (bullet.vTheta) !== 'number'\r\n        || typeof (bullet.orbitRadius) !== 'number') {\r\n        return;\r\n    }\r\n    bullet.theta += window.FRAME_LENGTH * bullet.vTheta / 1000;\r\n    bullet.baseX = anchor.x + bullet.orbitRadius * Math.cos(bullet.theta);\r\n    bullet.baseY = anchor.y + bullet.orbitRadius * Math.sin(bullet.theta);\r\n    if (bullet.frequency && bullet.amplitude) {\r\n        const theta = bullet.theta;\r\n        const p = Math.min(1, bullet.time / 200);\r\n        const amplitude = p * bullet.amplitude * Math.sin(bullet.frequency * 2 * Math.PI * bullet.time / 1000);\r\n        bullet.x = bullet.baseX + amplitude * Math.cos(theta);\r\n        bullet.y = bullet.baseY + amplitude * Math.sin(theta);\r\n    }\r\n    else {\r\n        bullet.x = bullet.baseX;\r\n        bullet.y = bullet.baseY;\r\n    }\r\n    if (bullet.friction) {\r\n        const multiplier = (1 - bullet.friction) ** (window.FRAME_LENGTH / 1000);\r\n        bullet.vTheta = Math.max(0.2, bullet.vTheta * multiplier);\r\n    }\r\n}\r\nfunction updateSimpleBullet(state, bullet) {\r\n    bullet.baseX += bullet.vx * window.FRAME_LENGTH / 1000;\r\n    bullet.baseY += bullet.vy * window.FRAME_LENGTH / 1000;\r\n    if (bullet.frequency && bullet.amplitude) {\r\n        const theta = Math.atan2(bullet.vy, bullet.vx) + Math.PI / 2;\r\n        const p = Math.min(1, bullet.time / 200);\r\n        const amplitude = p * bullet.amplitude * Math.sin(bullet.frequency * 2 * Math.PI * bullet.time / 1000);\r\n        bullet.x = bullet.baseX + amplitude * Math.cos(theta);\r\n        bullet.y = bullet.baseY + amplitude * Math.sin(theta);\r\n    }\r\n    else {\r\n        bullet.x = bullet.baseX;\r\n        bullet.y = bullet.baseY;\r\n    }\r\n    if (bullet.friction) {\r\n        const multiplier = (1 - bullet.friction) ** (window.FRAME_LENGTH / 1000);\r\n        bullet.vx *= multiplier;\r\n        bullet.vy *= multiplier;\r\n    }\r\n}\r\nfunction updateReturnBullet(state, bullet) {\r\n    updateSimpleBullet(state, bullet);\r\n    // Reverse velocity at the bullet's half life.\r\n    if (bullet.time >= bullet.duration / 2) {\r\n        bullet.vx = -bullet.vx;\r\n        bullet.vy = -bullet.vy;\r\n        bullet.update = updateSimpleBullet;\r\n    }\r\n}\r\nfunction updateBoomeringBullet(state, bullet) {\r\n    updateSimpleBullet(state, bullet);\r\n    if (bullet.time >= bullet.duration / 2) {\r\n        bullet.vx = -bullet.vx;\r\n        bullet.vy = -bullet.vy;\r\n        bullet.update = updateSourceSeekingBullet;\r\n    }\r\n}\r\nfunction turnBulletTowardsTarget(bullet, rate = 0.1, target) {\r\n    if (!target) {\r\n        return;\r\n    }\r\n    const dx = target.x - bullet.baseX, dy = target.y - bullet.baseY;\r\n    const theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.turnTowardsAngle)(Math.atan2(bullet.vy, bullet.vx), rate, Math.atan2(dy, dx));\r\n    const speed = Math.sqrt(bullet.vx * bullet.vx + bullet.vy * bullet.vy);\r\n    bullet.vx = speed * Math.cos(theta);\r\n    bullet.vy = speed * Math.sin(theta);\r\n}\r\nfunction isEnemyTargetable(state, enemy) {\r\n    return !enemy.isInvulnerable && (!enemy.warningTime || enemy.warningTime <= 0);\r\n}\r\nfunction updateEnemySeekingBullet(state, bullet) {\r\n    const closestEnemy = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.getClosestElement)(bullet, state.enemies.filter(e => !bullet.hitTargets.has(e) && isEnemyTargetable(state, e)));\r\n    turnBulletTowardsTarget(bullet, 0.1, closestEnemy);\r\n    updateSimpleBullet(state, bullet);\r\n}\r\nfunction updateHeroSeekingBullet(state, bullet) {\r\n    turnBulletTowardsTarget(bullet, 0.1, state.hero);\r\n    updateSimpleBullet(state, bullet);\r\n}\r\nfunction updateSourceSeekingBullet(state, bullet) {\r\n    turnBulletTowardsTarget(bullet, 0.2, bullet.anchor || bullet.source);\r\n    updateSimpleBullet(state, bullet);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/bullet.ts?");

/***/ }),

/***/ "./app/utils/canvas.ts":
/*!*****************************!*\
  !*** ./app/utils/canvas.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCanvas: () => (/* binding */ createCanvas),\n/* harmony export */   createCanvasAndContext: () => (/* binding */ createCanvasAndContext),\n/* harmony export */   drawCanvas: () => (/* binding */ drawCanvas),\n/* harmony export */   mainCanvas: () => (/* binding */ mainCanvas),\n/* harmony export */   mainContext: () => (/* binding */ mainContext),\n/* harmony export */   require2dContext: () => (/* binding */ require2dContext)\n/* harmony export */ });\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n\r\nconst mainCanvas = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-mainCanvas');\r\n// @ts-ignore\r\nwindow['mainCanvas'] = mainCanvas;\r\n// mainCanvas.width = mainCanvas.height = 512;\r\nconst mainContext = require2dContext(mainCanvas);\r\n// mainContext.imageSmoothingEnabled = false;\r\n// @ts-ignore\r\nwindow['mainContext'] = mainContext;\r\nfunction require2dContext(canvas) {\r\n    const context = canvas.getContext('2d');\r\n    if (!context) {\r\n        throw new Error('Failed to get context');\r\n    }\r\n    return context;\r\n}\r\nfunction createCanvas(width, height, classes = '') {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.className = classes;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    return canvas;\r\n}\r\nfunction createCanvasAndContext(width, height) {\r\n    const canvas = createCanvas(width, height);\r\n    const context = require2dContext(canvas);\r\n    return [canvas, context];\r\n}\r\n/**\r\n * Safari (and possibly other browsers) will not draw canvases if the source\r\n * rectangle has any parts outside the dimensions of the actual canvas, so this\r\n * method takes arbitrary rectangles and then modifies them to only draw the\r\n * part that overlaps with the canvas.\r\n */\r\nfunction drawCanvas(context, canvas, { x, y, w, h }, { x: tx, y: ty, w: tw, h: th }) {\r\n    if (w > canvas.width - x) {\r\n        const dx = w - (canvas.width - x);\r\n        w += dx;\r\n        tw += dx;\r\n    }\r\n    if (h > canvas.height - y) {\r\n        const dy = h - (canvas.height - y);\r\n        h += dy;\r\n        th += dy;\r\n    }\r\n    if (x < 0) {\r\n        tx -= x;\r\n        tw += x;\r\n        w += x;\r\n        x = 0;\r\n    }\r\n    if (y < 0) {\r\n        ty -= y;\r\n        th += y;\r\n        h += y;\r\n        y = 0;\r\n    }\r\n    if (w > 0 && h > 0) {\r\n        context.drawImage(canvas, x, y, w, h, tx, ty, tw, th);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/canvas.ts?");

/***/ }),

/***/ "./app/utils/combat.ts":
/*!*****************************!*\
  !*** ./app/utils/combat.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abbreviate: () => (/* binding */ abbreviate),\n/* harmony export */   abbreviateHealth: () => (/* binding */ abbreviateHealth),\n/* harmony export */   addDamageNumber: () => (/* binding */ addDamageNumber),\n/* harmony export */   applyArmorToDamage: () => (/* binding */ applyArmorToDamage),\n/* harmony export */   applyDamageToHero: () => (/* binding */ applyDamageToHero),\n/* harmony export */   applySlowEffect: () => (/* binding */ applySlowEffect),\n/* harmony export */   damageHero: () => (/* binding */ damageHero),\n/* harmony export */   damageHeroOverTime: () => (/* binding */ damageHeroOverTime),\n/* harmony export */   fixedDigits: () => (/* binding */ fixedDigits),\n/* harmony export */   updateSlowEffects: () => (/* binding */ updateSlowEffects)\n/* harmony export */ });\n/* harmony import */ var app_utils_audio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/audio */ \"./app/utils/audio.ts\");\n/* harmony import */ var app_utils_guardSkill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/guardSkill */ \"./app/utils/guardSkill.ts\");\n\r\n\r\nfunction damageHero(state, damage) {\r\n    damage = applyArmorToDamage(state, damage, state.hero.armor);\r\n    // Incoming damage is limited by both the amount of the damage and the players total health.\r\n    // Shots that deal window.X damage only deal damage if the player has taken less than 2X damage recently.\r\n    // window.A player cannot take more than 50% of their health over their recorded damage history.\r\n    const damageCap = Math.min(Math.floor(state.hero.maxLife / 2), 2 * damage);\r\n    const damageTaken = Math.max(0, Math.min(damage, damageCap - state.hero.recentDamageTaken));\r\n    if (damageTaken <= 0) {\r\n        return;\r\n    }\r\n    if (damageTaken < 0.25 * state.hero.life) {\r\n        (0,app_utils_audio__WEBPACK_IMPORTED_MODULE_0__.playSound)(state, 'takeDamage');\r\n    }\r\n    else {\r\n        (0,app_utils_audio__WEBPACK_IMPORTED_MODULE_0__.playSound)(state, 'takeBigDamage');\r\n    }\r\n    addDamageNumber(state, state.hero, damageTaken);\r\n    applyDamageToHero(state, damageTaken);\r\n}\r\nfunction damageHeroOverTime(state, damage) {\r\n    // Incoming damage over time is limited only by player health.\r\n    const damageCap = Math.floor(state.hero.maxLife / 2);\r\n    const damageTaken = Math.min(damage, \r\n    // Damage over time cannot put the player over there max damage taken cap.\r\n    damageCap - state.hero.recentDamageTaken, \r\n    // Only the max damage over time value applies to a player each frame.\r\n    damage - state.hero.frameDamageOverTime);\r\n    if (damageTaken <= 0) {\r\n        return;\r\n    }\r\n    state.hero.frameDamageOverTime += damageTaken;\r\n    applyDamageToHero(state, damageTaken);\r\n}\r\nfunction applyDamageToHero(state, damage) {\r\n    state.hero.life -= damage;\r\n    if (state.hero.life < 0) {\r\n        state.hero.life = 0;\r\n    }\r\n    state.hero.damageHistory[0] += damage;\r\n    state.hero.recentDamageTaken += damage;\r\n    const p = 2 * damage / state.hero.maxLife;\r\n    (0,app_utils_guardSkill__WEBPACK_IMPORTED_MODULE_1__.chargeGuardSkill)(state, p * (0,app_utils_guardSkill__WEBPACK_IMPORTED_MODULE_1__.getGuardSkillCooldownTime)(state));\r\n}\r\nfunction addDamageNumber(state, target, damage, isCrit = false) {\r\n    state.fieldText.push({\r\n        x: target.x - 5 + Math.random() * 10,\r\n        y: target.y - 10,\r\n        vx: 2 * Math.random() - 1,\r\n        vy: -1,\r\n        text: abbreviate(Math.round(damage)),\r\n        color: isCrit ? 'yellow' : 'red',\r\n        borderColor: 'black',\r\n        expirationTime: state.fieldTime + 500,\r\n        time: 0,\r\n    });\r\n}\r\nfunction applyArmorToDamage(state, damage, armor) {\r\n    return Math.max(Math.ceil(damage / 10), damage - armor);\r\n}\r\nfunction fixedDigits(number, digits = 1) {\r\n    return parseFloat(number.toFixed(digits));\r\n}\r\nfunction abbreviate(number, digits) {\r\n    if (typeof (digits) === 'number') {\r\n        number = fixedDigits(number, digits);\r\n    }\r\n    if (number >= 1000000000000) {\r\n        return (number / 1000000000000 + '').slice(0, 4) + 'T';\r\n    }\r\n    if (number >= 1000000000) {\r\n        return (number / 1000000000 + '').slice(0, 4) + 'B';\r\n    }\r\n    if (number >= 1000000) {\r\n        return (number / 1000000 + '').slice(0, 4) + 'M';\r\n    }\r\n    if (number >= 10000) {\r\n        return (number / 1000 + '').slice(0, 4) + 'K';\r\n    }\r\n    return `${number}`;\r\n}\r\nfunction abbreviateHealth(number, digits) {\r\n    if (typeof (digits) === 'number') {\r\n        number = fixedDigits(number, digits);\r\n    }\r\n    if (number >= 1000000000000) {\r\n        return (number / 1000000000 + '').slice(0, 4) + 'B';\r\n    }\r\n    if (number >= 1000000000) {\r\n        return (number / 1000000 + '').slice(0, 4) + 'M';\r\n    }\r\n    if (number >= 1000000) {\r\n        return (number / 1000 + '').slice(0, 4) + 'K';\r\n    }\r\n    return `${number}`;\r\n}\r\nfunction applySlowEffect(target, slow) {\r\n    for (const oldSlow of target.slowEffects) {\r\n        if (slow.effect >= oldSlow.effect && slow.duration >= oldSlow.duration) {\r\n            oldSlow.effect = slow.effect;\r\n            oldSlow.duration = slow.duration;\r\n            return;\r\n        }\r\n        if (slow.effect <= oldSlow.effect && slow.duration <= oldSlow.duration) {\r\n            return;\r\n        }\r\n    }\r\n    target.slowEffects.unshift({ ...slow });\r\n}\r\nfunction updateSlowEffects(state, target) {\r\n    let highestSlowEffect = 0;\r\n    const currentSlowEffects = target.slowEffects;\r\n    target.slowEffects = [];\r\n    for (const slowEffect of currentSlowEffects) {\r\n        highestSlowEffect = Math.max(highestSlowEffect, slowEffect.effect);\r\n        slowEffect.duration -= window.FRAME_LENGTH;\r\n        if (slowEffect.duration > 0) {\r\n            target.slowEffects.push(slowEffect);\r\n        }\r\n    }\r\n    return highestSlowEffect;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/combat.ts?");

/***/ }),

/***/ "./app/utils/coreCalculations.ts":
/*!***************************************!*\
  !*** ./app/utils/coreCalculations.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBaseEnemyExperience: () => (/* binding */ getBaseEnemyExperience),\n/* harmony export */   getBaseWeaponDpsForLevel: () => (/* binding */ getBaseWeaponDpsForLevel),\n/* harmony export */   getExperienceForNextEquipmentLevel: () => (/* binding */ getExperienceForNextEquipmentLevel),\n/* harmony export */   getExperienceForNextLevel: () => (/* binding */ getExperienceForNextLevel),\n/* harmony export */   getHeroLevelDamageBonus: () => (/* binding */ getHeroLevelDamageBonus),\n/* harmony export */   getHeroWeaponProficiencyLevelDamageBonus: () => (/* binding */ getHeroWeaponProficiencyLevelDamageBonus),\n/* harmony export */   rollForCritDamage: () => (/* binding */ rollForCritDamage)\n/* harmony export */ });\nfunction rollForCritDamage(state, additionalCritchance = 0) {\r\n    const weapon = state.hero.equipment.weapon;\r\n    const isCrit = Math.random() < additionalCritchance + state.hero.critChance + weapon.critChance;\r\n    if (!isCrit) {\r\n        return 1;\r\n    }\r\n    return 1 + state.hero.critDamage + weapon.critDamage;\r\n}\r\nfunction getBaseWeaponDpsForLevel(level) {\r\n    return level * window.BASE_WEAPON_DPS_PER_LEVEL * (window.BASE_WEAPON_DPS_PER_LEVEL_MULTIPLIER ** level);\r\n}\r\nfunction getHeroLevelDamageBonus(level) {\r\n    return 1.04 ** (level - 1);\r\n}\r\nfunction getHeroWeaponProficiencyLevelDamageBonus(level) {\r\n    return 1.04 ** level;\r\n}\r\nfunction getBaseEnemyExperience(level) {\r\n    return Math.ceil(window.BASE_XP * Math.pow(1.2, level - 1));\r\n}\r\nfunction getExperienceForNextLevel(currentLevel) {\r\n    // This is:\r\n    // ~5 kills for 1 -> 2\r\n    // ~16 kills for 10 -> 11\r\n    // 30 kills for 20 -> 21\r\n    // 100 kills for 50 -> 51\r\n    // 125 kills for 60 -> 61\r\n    // 200 kills for 75 -> 76\r\n    // 250 kills for 80 -> 81\r\n    // 500 kills for 90 -> 91\r\n    // 1000 kills for 95 -> 96\r\n    // 2500 kills for 98 -> 99\r\n    // 5000 kills for 99 -> 100\r\n    const averageKills = Math.min(50, 4 + currentLevel) * 100 / (100 - currentLevel);\r\n    return Math.ceil(averageKills * getBaseEnemyExperience(currentLevel));\r\n}\r\n// @ts-ignore-next-line\r\nwindow['getExperienceForNextLevel'] = getExperienceForNextLevel;\r\nfunction getExperienceForNextEquipmentLevel(currentLevel) {\r\n    const averageKills = Math.min(20, 5 + currentLevel) * 100 / (100 - currentLevel);\r\n    const xpPerKill = Math.ceil(window.BASE_XP * Math.pow(1.2, currentLevel));\r\n    return averageKills * xpPerKill;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/coreCalculations.ts?");

/***/ }),

/***/ "./app/utils/disc.ts":
/*!***************************!*\
  !*** ./app/utils/disc.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDisc: () => (/* binding */ createDisc),\n/* harmony export */   findClosestDisc: () => (/* binding */ findClosestDisc),\n/* harmony export */   findClosestDiscToDisc: () => (/* binding */ findClosestDiscToDisc),\n/* harmony export */   getConnectionPoint: () => (/* binding */ getConnectionPoint),\n/* harmony export */   linkDiscs: () => (/* binding */ linkDiscs),\n/* harmony export */   projectDiscToClosestDisc: () => (/* binding */ projectDiscToClosestDisc),\n/* harmony export */   projectDiscToDisc: () => (/* binding */ projectDiscToDisc)\n/* harmony export */ });\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\nfunction findClosestDisc({ x, y }, discs) {\r\n    let closestDistance2 = Number.MAX_SAFE_INTEGER, closestDisc = discs[0];\r\n    for (const disc of discs) {\r\n        const dx = disc.x - x, dy = disc.y - y;\r\n        const distance2 = dx * dx + dy * dy - disc.radius * disc.radius;\r\n        if (distance2 < closestDistance2) {\r\n            closestDistance2 = distance2;\r\n            closestDisc = disc;\r\n        }\r\n    }\r\n    return closestDisc;\r\n}\r\nfunction findClosestDiscToDisc(disc, discs) {\r\n    let closestDistance = Number.MAX_SAFE_INTEGER, closestDisc = discs[0];\r\n    for (const otherDisc of discs) {\r\n        const dx = otherDisc.x - disc.x, dy = otherDisc.y - disc.y;\r\n        const distance = (dx * dx + dy * dy) ** 0.5 - disc.radius - otherDisc.radius;\r\n        if (distance < closestDistance) {\r\n            closestDistance = distance;\r\n            closestDisc = otherDisc;\r\n        }\r\n    }\r\n    return closestDisc;\r\n}\r\nfunction createDisc(props) {\r\n    return {\r\n        level: 1,\r\n        name: 'Shinsekai',\r\n        x: 0,\r\n        y: 0,\r\n        radius: 400,\r\n        links: [],\r\n        enemies: [],\r\n        portals: [],\r\n        loot: [],\r\n        holes: [],\r\n        ...props,\r\n    };\r\n}\r\nfunction projectDiscToDisc(newDisc, targetDisc, overlap) {\r\n    const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.getTargetVector)(targetDisc, newDisc);\r\n    const m = Math.sqrt(distance2);\r\n    const distance = targetDisc.radius + newDisc.radius - overlap;\r\n    newDisc.x = targetDisc.x + x / m * distance;\r\n    newDisc.y = targetDisc.y + y / m * distance;\r\n}\r\nfunction projectDiscToClosestDisc(discs, newDisc, overlap) {\r\n    const closestDisc = findClosestDiscToDisc(newDisc, discs);\r\n    projectDiscToDisc(newDisc, closestDisc, overlap);\r\n}\r\nfunction linkDiscs(discs) {\r\n    for (let i = 0; i < discs.length; i++) {\r\n        const disc = discs[i];\r\n        for (let j = i + 1; j < discs.length; j++) {\r\n            const otherDisc = discs[j];\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.getTargetVector)(disc, otherDisc);\r\n            const minDistance = disc.radius + otherDisc.radius - 16;\r\n            if (distance2 <= minDistance * minDistance) {\r\n                disc.links.push(otherDisc);\r\n                otherDisc.links.push(disc);\r\n            }\r\n        }\r\n    }\r\n}\r\n// Assuming discA and discB are touching, this returns the point on the edge\r\n// of discA closest to the center of discB.\r\n// This is useful for pathing from discA to discB. If there are no obstacles\r\n// you can travel from anywhere on discA to this point and then from this\r\n// point to anywhere on discB.\r\nfunction getConnectionPoint(discA, discB) {\r\n    const p = discA.radius / (discA.radius + discB.radius);\r\n    return {\r\n        x: discA.x + p * (discB.x - discA.x),\r\n        y: discA.y + p * (discB.y - discA.y),\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/disc.ts?");

/***/ }),

/***/ "./app/utils/dom.ts":
/*!**************************!*\
  !*** ./app/utils/dom.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bodyDiv: () => (/* binding */ bodyDiv),\n/* harmony export */   divider: () => (/* binding */ divider),\n/* harmony export */   findEmptyElement: () => (/* binding */ findEmptyElement),\n/* harmony export */   getClosestElement: () => (/* binding */ getClosestElement),\n/* harmony export */   getDomRectCenter: () => (/* binding */ getDomRectCenter),\n/* harmony export */   getElementIndex: () => (/* binding */ getElementIndex),\n/* harmony export */   getElementRect: () => (/* binding */ getElementRect),\n/* harmony export */   handleChildEvent: () => (/* binding */ handleChildEvent),\n/* harmony export */   mainContent: () => (/* binding */ mainContent),\n/* harmony export */   mouseContainer: () => (/* binding */ mouseContainer),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryAll: () => (/* binding */ queryAll),\n/* harmony export */   tag: () => (/* binding */ tag),\n/* harmony export */   tagElement: () => (/* binding */ tagElement),\n/* harmony export */   titleDiv: () => (/* binding */ titleDiv),\n/* harmony export */   toggleElement: () => (/* binding */ toggleElement),\n/* harmony export */   toggleElements: () => (/* binding */ toggleElements)\n/* harmony export */ });\nfunction query(className) {\r\n    return document.querySelector(className);\r\n}\r\nfunction queryAll(className) {\r\n    return document.querySelectorAll(className);\r\n}\r\nconst mouseContainer = query('.js-mouseContainer');\r\nconst mainContent = query('.js-gameContent');\r\nfunction tag(type, classes = '', content = '') {\r\n    return '<' + type + ' class=\"' + classes + '\">' + content + '</' + type + '>';\r\n}\r\nfunction tagElement(type, classes = '', content = '') {\r\n    const element = document.createElement(type);\r\n    element.className = classes || '';\r\n    element.innerHTML = '' + (content || '');\r\n    return element;\r\n}\r\nconst divider = tag('div', 'centered medium', tag('div', 'divider'));\r\nfunction titleDiv(titleMarkup) {\r\n    return titleMarkup && tag('div', 'title', titleMarkup);\r\n}\r\nfunction bodyDiv(bodyMarkup) {\r\n    return bodyMarkup && tag('div', 'body', bodyMarkup);\r\n}\r\n;\r\nfunction findEmptyElement(elements) {\r\n    return [...elements].find(element => element.innerHTML === '');\r\n}\r\nfunction getDomRectCenter(r) {\r\n    return [r.x + r.width / 2, r.y + r.height / 2];\r\n}\r\nfunction getElementRect(element, container) {\r\n    let b = element.getBoundingClientRect();\r\n    const rect = { x: b.left, y: b.top, w: b.width, h: b.height };\r\n    // If container is specified, return the rectangle relative to the container's coordinates.\r\n    if (container) {\r\n        const containerRect = container.getBoundingClientRect();\r\n        rect.x -= containerRect.left;\r\n        rect.y -= containerRect.top;\r\n    }\r\n    return rect;\r\n}\r\nfunction getClosestElement(element, elements, threshold) {\r\n    let closestElement = null;\r\n    let closestDistanceSquared = threshold * threshold;\r\n    const center = getDomRectCenter(element.getBoundingClientRect());\r\n    elements.forEach(element => {\r\n        const elementCenter = getDomRectCenter(element.getBoundingClientRect());\r\n        const d2 = (center[0] - elementCenter[0]) ** 2 + (center[1] - elementCenter[1]) ** 2;\r\n        if (d2 <= closestDistanceSquared) {\r\n            closestDistanceSquared = d2;\r\n            closestElement = element;\r\n        }\r\n    });\r\n    return closestElement;\r\n}\r\nfunction toggleElements(elements, show) {\r\n    elements.forEach(element => toggleElement(element, show));\r\n}\r\nfunction toggleElement(element, show) {\r\n    element.style.display = show ? '' : 'none';\r\n}\r\nfunction handleChildEvent(eventType, container, selector, handler) {\r\n    container.addEventListener(eventType, event => {\r\n        const element = event.target;\r\n        const matchedElement = element.closest(selector);\r\n        if (matchedElement) {\r\n            return handler(matchedElement, event);\r\n        }\r\n    });\r\n}\r\nfunction getElementIndex(element) {\r\n    if (!element.parentElement) {\r\n        return -1;\r\n    }\r\n    return [...element.parentElement.children].indexOf(element);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/dom.ts?");

/***/ }),

/***/ "./app/utils/dungeon.ts":
/*!******************************!*\
  !*** ./app/utils/dungeon.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   activateDungeonPortal: () => (/* binding */ activateDungeonPortal),\n/* harmony export */   addDungeonPortalToDisc: () => (/* binding */ addDungeonPortalToDisc),\n/* harmony export */   createArenaDungeon: () => (/* binding */ createArenaDungeon),\n/* harmony export */   createCaveDungeon: () => (/* binding */ createCaveDungeon),\n/* harmony export */   createDungeon: () => (/* binding */ createDungeon),\n/* harmony export */   dungeonTypes: () => (/* binding */ dungeonTypes),\n/* harmony export */   getDungeonLevelBonus: () => (/* binding */ getDungeonLevelBonus),\n/* harmony export */   startDungeon: () => (/* binding */ startDungeon)\n/* harmony export */ });\n/* harmony import */ var app_bosses_guardian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/bosses/guardian */ \"./app/bosses/guardian.ts\");\n/* harmony import */ var app_bosses_skissue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/bosses/skissue */ \"./app/bosses/skissue.ts\");\n/* harmony import */ var app_bosses_spider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/bosses/spider */ \"./app/bosses/spider.ts\");\n/* harmony import */ var app_enemies_bat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enemies/bat */ \"./app/enemies/bat.ts\");\n/* harmony import */ var app_enemies_chest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/enemies/chest */ \"./app/enemies/chest.ts\");\n/* harmony import */ var app_enemies_clam__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/enemies/clam */ \"./app/enemies/clam.ts\");\n/* harmony import */ var app_enemies_slime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/enemies/slime */ \"./app/enemies/slime.ts\");\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n/* harmony import */ var app_utils_disc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/disc */ \"./app/utils/disc.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_overworld__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/utils/overworld */ \"./app/utils/overworld.ts\");\n/* harmony import */ var app_utils_SRandom__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/utils/SRandom */ \"./app/utils/SRandom.ts\");\n/* harmony import */ var app_dungeons_pearlTrove__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/dungeons/pearlTrove */ \"./app/dungeons/pearlTrove.ts\");\n/* harmony import */ var app_dungeons_reef__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/dungeons/reef */ \"./app/dungeons/reef.ts\");\n/* harmony import */ var app_dungeons_spiderDen__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/dungeons/spiderDen */ \"./app/dungeons/spiderDen.ts\");\n/* harmony import */ var app_dungeons_tree__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! app/dungeons/tree */ \"./app/dungeons/tree.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst platformSizes = [200, 350, 500];\r\nconst dungeonTypes = ['reef', 'pearlTrove', 'cave', 'tree', 'arena', 'spiderDen'];\r\nfunction addDungeonPortalToDisc(state, { x, y }, type, level, seed = Math.random(), disc) {\r\n    const dungeon = createDungeon(state, type, level, seed);\r\n    const portal = {\r\n        x, y, radius: 40,\r\n        disc,\r\n        dungeon,\r\n        name: dungeon.name,\r\n        activate(state) {\r\n            activateDungeonPortal(state, this);\r\n        },\r\n    };\r\n    disc.portals.push(portal);\r\n    return portal;\r\n}\r\nfunction getDungeonLevelBonus(type) {\r\n    if (type === 'reef')\r\n        return 0;\r\n    if (type === 'pearlTrove')\r\n        return 1;\r\n    if (type === 'cave')\r\n        return 1;\r\n    if (type === 'tree')\r\n        return 1;\r\n    if (type === 'arena')\r\n        return 1;\r\n    if (type === 'spiderDen')\r\n        return 1;\r\n    return 2;\r\n}\r\nfunction createDungeon(state, type, level, seed = Math.random()) {\r\n    const radius = 1600 + 8 * level;\r\n    level = Math.max(0, level + getDungeonLevelBonus(type));\r\n    if (type === 'reef')\r\n        return (0,app_dungeons_reef__WEBPACK_IMPORTED_MODULE_14__.createReefDungeon)(state, seed, radius, level);\r\n    if (type === 'pearlTrove')\r\n        return (0,app_dungeons_pearlTrove__WEBPACK_IMPORTED_MODULE_13__.createPearlTroveDungeon)(state, seed, radius, level);\r\n    if (type === 'cave')\r\n        return createCaveDungeon(state, seed, radius, level);\r\n    if (type === 'arena')\r\n        return createArenaDungeon(state, seed, radius, level);\r\n    if (type === 'spiderDen')\r\n        return (0,app_dungeons_spiderDen__WEBPACK_IMPORTED_MODULE_15__.createSpiderDenDungeon)(state, seed, level);\r\n    return (0,app_dungeons_tree__WEBPACK_IMPORTED_MODULE_16__.createTreeDungeon)(state, seed, radius, level);\r\n}\r\nfunction createCaveDungeon(state, seed, radius, level) {\r\n    const name = 'Cave';\r\n    const discs = [];\r\n    const entrance = { x: 0, y: 0, radius: 16 };\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_12__[\"default\"].seed(seed);\r\n    const startingPlatform = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.createDisc)({\r\n        level,\r\n        name,\r\n        x: entrance.x,\r\n        y: entrance.y,\r\n        radius: 400,\r\n    });\r\n    (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_11__.addOverworldPortalToDisc)(entrance, startingPlatform);\r\n    discs.push(startingPlatform);\r\n    let finished = false;\r\n    let theta = Math.PI / 2;\r\n    for (let i = 0; i < 100 && (!finished || i < 12); i++) {\r\n        theta += Math.PI / 24 + Math.PI / 12 * dungeonRandomizer.generateAndMutate();\r\n        const newDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.createDisc)({\r\n            level,\r\n            name,\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: dungeonRandomizer.element(platformSizes),\r\n        });\r\n        (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.projectDiscToClosestDisc)(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n        if (newDisc.x * newDisc.x + newDisc.y * newDisc.y >= radius * radius) {\r\n            // Only one disc is allowed to spawn outside of the radius.\r\n            if (!finished) {\r\n                finished = true;\r\n                newDisc.radius = 400;\r\n                (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.projectDiscToClosestDisc)(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n                newDisc.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_6__.megaSlime, level + 2, newDisc);\r\n                newDisc.boss.isBoss = true;\r\n                discs.push(newDisc);\r\n            }\r\n            continue;\r\n        }\r\n        discs.push(newDisc);\r\n        // window.TODO: Add different enemy generators and apply them at random.\r\n        if (dungeonRandomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_6__.greatSlime, level, newDisc);\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_4__.chest, level + 1, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x + 50, newDisc.y, app_enemies_bat__WEBPACK_IMPORTED_MODULE_3__.bat, level, newDisc);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x - 50, newDisc.y, app_enemies_bat__WEBPACK_IMPORTED_MODULE_3__.bat, level, newDisc);\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y + 50, app_enemies_bat__WEBPACK_IMPORTED_MODULE_3__.bat, level, newDisc);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y - 50, app_enemies_bat__WEBPACK_IMPORTED_MODULE_3__.bat, level, newDisc);\r\n        }\r\n    }\r\n    (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.linkDiscs)(discs);\r\n    return {\r\n        name,\r\n        level,\r\n        discs,\r\n        entrance,\r\n    };\r\n}\r\nfunction createArenaDungeon(state, seed, radius, level) {\r\n    const name = 'Cave';\r\n    const discs = [];\r\n    const entrance = { x: 0, y: 0, radius: 16 };\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_12__[\"default\"].seed(seed);\r\n    const startingPlatform = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.createDisc)({\r\n        level,\r\n        name,\r\n        x: entrance.x,\r\n        y: entrance.y,\r\n        radius: 400,\r\n    });\r\n    (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_11__.addOverworldPortalToDisc)(entrance, startingPlatform);\r\n    discs.push(startingPlatform);\r\n    const bosses = dungeonRandomizer.shuffle([app_enemies_slime__WEBPACK_IMPORTED_MODULE_6__.megaSlime, app_bosses_guardian__WEBPACK_IMPORTED_MODULE_0__.guardian, app_enemies_clam__WEBPACK_IMPORTED_MODULE_5__.giantClam, app_bosses_spider__WEBPACK_IMPORTED_MODULE_2__.spider, app_bosses_skissue__WEBPACK_IMPORTED_MODULE_1__.skissue]);\r\n    const count = bosses.length;\r\n    for (let i = 0; i < count; i++) {\r\n        const theta = 2 * Math.PI * i / count;\r\n        let previousDisc = startingPlatform;\r\n        for (let j = 0; j < 4; j++) {\r\n            const newDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.createDisc)({\r\n                level,\r\n                name,\r\n                x: 10000 * Math.cos(theta),\r\n                y: 10000 * Math.sin(theta),\r\n                radius: dungeonRandomizer.element(platformSizes),\r\n            });\r\n            (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.projectDiscToDisc)(newDisc, previousDisc, dungeonRandomizer.range(32, 64));\r\n            // window.TODO: Add different enemy generators and apply them at random.\r\n            if (dungeonRandomizer.generateAndMutate() < 0.2) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_6__.greatSlime, level, newDisc);\r\n            }\r\n            else if (dungeonRandomizer.generateAndMutate() < 0.2) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_4__.chest, level + 1, newDisc);\r\n            }\r\n            if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x + 50, newDisc.y, app_enemies_bat__WEBPACK_IMPORTED_MODULE_3__.bat, level, newDisc);\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x - 50, newDisc.y, app_enemies_bat__WEBPACK_IMPORTED_MODULE_3__.bat, level, newDisc);\r\n            }\r\n            if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y + 50, app_enemies_bat__WEBPACK_IMPORTED_MODULE_3__.bat, level, newDisc);\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, newDisc.x, newDisc.y - 50, app_enemies_bat__WEBPACK_IMPORTED_MODULE_3__.bat, level, newDisc);\r\n            }\r\n            previousDisc = newDisc;\r\n            discs.push(newDisc);\r\n        }\r\n        previousDisc.enemies = [];\r\n        // Only one disc is allowed to spawn outside of the radius.\r\n        if (bosses.length) {\r\n            previousDisc.radius = 400;\r\n            (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.projectDiscToDisc)(previousDisc, discs[discs.length - 2], dungeonRandomizer.range(32, 48));\r\n            previousDisc.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_9__.createEnemy)(state, previousDisc.x, previousDisc.y, bosses.pop(), level + 2, previousDisc);\r\n            previousDisc.boss.isBoss = true;\r\n        }\r\n    }\r\n    (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_8__.linkDiscs)(discs);\r\n    return {\r\n        name,\r\n        level,\r\n        discs,\r\n        entrance,\r\n    };\r\n}\r\nfunction activateDungeonPortal(state, portal) {\r\n    const dungeon = portal.dungeon;\r\n    if (!dungeon) {\r\n        return;\r\n    }\r\n    // Remove this portal when it is used.\r\n    portal.disc.portals = portal.disc.portals.filter(p => p !== portal);\r\n    startDungeon(state, dungeon);\r\n}\r\nfunction startDungeon(state, dungeon) {\r\n    if (!dungeon) {\r\n        return;\r\n    }\r\n    if (!state.dungeon) {\r\n        state.hero.overworldX = state.hero.x;\r\n        state.hero.overworldY = state.hero.y;\r\n    }\r\n    // Remove this portal when it is used.\r\n    state.dungeon = dungeon;\r\n    state.hero.x = dungeon.entrance.x;\r\n    state.hero.y = dungeon.entrance.y;\r\n    state.activeDiscs = dungeon.discs;\r\n    state.visibleDiscs = dungeon.discs;\r\n    (0,app_utils_overworld__WEBPACK_IMPORTED_MODULE_11__.updateActiveCells)(state);\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.refillAllPotions)(state);\r\n    (0,app_saveGame__WEBPACK_IMPORTED_MODULE_7__.saveGame)(state);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/dungeon.ts?");

/***/ }),

/***/ "./app/utils/enemy.ts":
/*!****************************!*\
  !*** ./app/utils/enemy.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chaseHeroHeading: () => (/* binding */ chaseHeroHeading),\n/* harmony export */   chaseTarget: () => (/* binding */ chaseTarget),\n/* harmony export */   createBombBullet: () => (/* binding */ createBombBullet),\n/* harmony export */   createEnemy: () => (/* binding */ createEnemy),\n/* harmony export */   getBaseEnemyBullet: () => (/* binding */ getBaseEnemyBullet),\n/* harmony export */   getEnemyColor: () => (/* binding */ getEnemyColor),\n/* harmony export */   isEnemyOffDisc: () => (/* binding */ isEnemyOffDisc),\n/* harmony export */   isEnemyPositionInvalid: () => (/* binding */ isEnemyPositionInvalid),\n/* harmony export */   moveEnemyInCurrentDirection: () => (/* binding */ moveEnemyInCurrentDirection),\n/* harmony export */   moveEnemyInDirection: () => (/* binding */ moveEnemyInDirection),\n/* harmony export */   moveEnemyToTarget: () => (/* binding */ moveEnemyToTarget),\n/* harmony export */   moveEnemyToTargetWithoutTurning: () => (/* binding */ moveEnemyToTargetWithoutTurning),\n/* harmony export */   renderNormalizedEnemy: () => (/* binding */ renderNormalizedEnemy),\n/* harmony export */   shootBulletArc: () => (/* binding */ shootBulletArc),\n/* harmony export */   shootBulletAtHero: () => (/* binding */ shootBulletAtHero),\n/* harmony export */   shootBulletAtHeroHeading: () => (/* binding */ shootBulletAtHeroHeading),\n/* harmony export */   shootBulletCircle: () => (/* binding */ shootBulletCircle),\n/* harmony export */   shootBulletInDirection: () => (/* binding */ shootBulletInDirection),\n/* harmony export */   shootCirclingBullet: () => (/* binding */ shootCirclingBullet),\n/* harmony export */   shootEnemyBullet: () => (/* binding */ shootEnemyBullet),\n/* harmony export */   turnTowardsDirection: () => (/* binding */ turnTowardsDirection),\n/* harmony export */   turnTowardsHeroHeading: () => (/* binding */ turnTowardsHeroHeading),\n/* harmony export */   turnTowardsTarget: () => (/* binding */ turnTowardsTarget)\n/* harmony export */ });\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/coreCalculations */ \"./app/utils/coreCalculations.ts\");\n/* harmony import */ var app_utils_disc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/disc */ \"./app/utils/disc.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nfunction createEnemy(state, x, y, definition, level, disc, stats) {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    const heroBaseWeaponDamage = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.getBaseWeaponDpsForLevel)(level);\r\n    const heroLevelDamageFactor = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.getHeroLevelDamageBonus)(level);\r\n    const heroProficiencyDamageFactor = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.getHeroWeaponProficiencyLevelDamageBonus)(level);\r\n    const heroDamage = Math.ceil(heroBaseWeaponDamage * heroLevelDamageFactor * heroProficiencyDamageFactor);\r\n    // This includes attack speed gain from both level and weapon proficiency\r\n    const heroAttacksPerSecond = 1 + 0.02 * level;\r\n    const halfMediumArmorLifeBonus = (1 + level / 100 / 2);\r\n    const baseHeroLife = 20 * level;\r\n    // This is halfway between the light armor and heavy armor base life stats.\r\n    const mediumArmorBaseLifeBonus = level * 15;\r\n    const heroMaxLife = (baseHeroLife + mediumArmorBaseLifeBonus) * halfMediumArmorLifeBonus;\r\n    const dps = heroAttacksPerSecond * heroDamage;\r\n    const targetDuration = 1 + level * 10 / 100;\r\n    const maxLife = Math.ceil((dps * targetDuration) * ((_a = definition.statFactors.maxLife) !== null && _a !== void 0 ? _a : 1));\r\n    const baseArmor = Math.ceil(heroDamage / 20 * ((_b = definition.statFactors.armor) !== null && _b !== void 0 ? _b : 1));\r\n    const halfHeavyArmorBonus = (1 + level / 100 / 2);\r\n    const enemy = {\r\n        definition,\r\n        disc,\r\n        params: { ...definition.initialParams },\r\n        x,\r\n        y,\r\n        vx: 0,\r\n        vy: 0,\r\n        maxLife,\r\n        life: maxLife,\r\n        level,\r\n        baseColor: getEnemyColor(level),\r\n        speed: window.BASE_ENEMY_SPEED * ((_c = definition.statFactors.speed) !== null && _c !== void 0 ? _c : 1) * (0.9 + 0.2 * Math.random()),\r\n        baseArmor,\r\n        armor: baseArmor,\r\n        damage: Math.floor((heroMaxLife / 10 + heroMaxLife / 10 * level / 100 + 1.5 * level * halfHeavyArmorBonus) * ((_d = definition.statFactors.damage) !== null && _d !== void 0 ? _d : 1)),\r\n        attacksPerSecond: (0.75 + 0.0125 * level) * ((_e = definition.statFactors.attacksPerSecond) !== null && _e !== void 0 ? _e : 1),\r\n        attackCooldown: 0,\r\n        radius: definition.radius,\r\n        theta: 0,\r\n        minions: [],\r\n        chargingLevel: 1,\r\n        attackChargeLevel: 1,\r\n        mode: 'choose',\r\n        modeTime: 0,\r\n        time: 0,\r\n        isInvulnerable: definition.isInvulnerable,\r\n        setMode(mode) {\r\n            this.mode = mode;\r\n            this.modeTime = 0;\r\n        },\r\n        frameDamageOverTime: 0,\r\n        slowEffects: [],\r\n        ...stats,\r\n    };\r\n    if (disc) {\r\n        disc.enemies.push(enemy);\r\n        (_f = definition.initialize) === null || _f === void 0 ? void 0 : _f.call(definition, state, enemy);\r\n    }\r\n    return enemy;\r\n}\r\nfunction getEnemyColor(level) {\r\n    if (level === 1) {\r\n        return 'lightBlue';\r\n    }\r\n    if (level <= 3) {\r\n        return 'lightGreen';\r\n    }\r\n    if (level <= 5) {\r\n        return 'orange';\r\n    }\r\n    if (level < 10) {\r\n        return 'white';\r\n    }\r\n    if (level < 20) {\r\n        return '#262';\r\n    }\r\n    if (level < 30) {\r\n        return 'purple';\r\n    }\r\n    if (level < 40) {\r\n        return 'brown';\r\n    }\r\n    if (level < 50) {\r\n        return 'green';\r\n    }\r\n    if (level < 60) {\r\n        return '#FF0';\r\n    }\r\n    if (level < 70) {\r\n        return '#F0F';\r\n    }\r\n    if (level < 80) {\r\n        return '#0FF';\r\n    }\r\n    if (level < 90) {\r\n        return 'silver';\r\n    }\r\n    // Bright purple, slightly brighter than abyss top edges.\r\n    return '#E8E';\r\n}\r\nfunction getBaseEnemyBullet(state, enemy) {\r\n    return {\r\n        time: 0,\r\n        //x: enemy.x + vx / mag * enemy.radius,\r\n        //y: enemy.y + vy / mag * enemy.radius,\r\n        baseX: enemy.x,\r\n        baseY: enemy.y,\r\n        x: enemy.x,\r\n        y: enemy.y,\r\n        damage: enemy.damage,\r\n        radius: window.BASE_ENEMY_BULLET_RADIUS,\r\n        vx: 0,\r\n        vy: 0,\r\n        duration: window.BASE_ENEMY_BULLET_DURATION,\r\n        update: app_utils_bullet__WEBPACK_IMPORTED_MODULE_0__.updateSimpleBullet,\r\n        hitTargets: new Set(),\r\n        armorShred: 0.05,\r\n        warningTime: 0,\r\n        source: enemy,\r\n    };\r\n}\r\nfunction createBombBullet(state, enemy, x, y, stats = {}) {\r\n    const bullet = {\r\n        ...getBaseEnemyBullet(state, enemy),\r\n        baseX: x,\r\n        baseY: y,\r\n        radius: 3 * window.BASE_ENEMY_BULLET_RADIUS,\r\n        x, y,\r\n        warningTime: 800,\r\n        duration: window.BASE_ENEMY_BULLET_DURATION,\r\n        ...stats,\r\n    };\r\n    //const mag = Math.sqrt(vx * vx + vy * vy);\r\n    state.enemyBullets.push(bullet);\r\n    return bullet;\r\n}\r\nfunction shootEnemyBullet(state, enemy, vx, vy, stats = {}) {\r\n    const bullet = {\r\n        ...getBaseEnemyBullet(state, enemy),\r\n        vx, vy,\r\n        ...stats,\r\n    };\r\n    //const mag = Math.sqrt(vx * vx + vy * vy);\r\n    state.enemyBullets.push(bullet);\r\n    return bullet;\r\n}\r\nfunction shootBulletInDirection(state, enemy, theta, speed, stats = {}) {\r\n    const bullet = {\r\n        ...getBaseEnemyBullet(state, enemy),\r\n        vx: speed * Math.cos(theta),\r\n        vy: speed * Math.sin(theta),\r\n        ...stats,\r\n    };\r\n    //const mag = Math.sqrt(vx * vx + vy * vy);\r\n    state.enemyBullets.push(bullet);\r\n    return bullet;\r\n}\r\nfunction shootCirclingBullet(state, enemy, theta, radius, stats = {}) {\r\n    //const mag = Math.sqrt(vx * vx + vy * vy);\r\n    const bullet = {\r\n        time: 0,\r\n        //x: enemy.x + vx / mag * enemy.radius,\r\n        //y: enemy.y + vy / mag * enemy.radius,\r\n        baseX: enemy.x,\r\n        baseY: enemy.y,\r\n        x: enemy.x,\r\n        y: enemy.y,\r\n        source: enemy,\r\n        damage: enemy.damage,\r\n        radius: window.BASE_ENEMY_BULLET_RADIUS,\r\n        vx: 0,\r\n        vy: 0,\r\n        orbitRadius: radius,\r\n        theta,\r\n        vTheta: 2 * Math.PI,\r\n        duration: window.BASE_ENEMY_BULLET_DURATION,\r\n        update: app_utils_bullet__WEBPACK_IMPORTED_MODULE_0__.updateCirclingBullet,\r\n        hitTargets: new Set(),\r\n        // Armor shred is not functional against the player, although maybe it could be added\r\n        // with player recovering armor over time.\r\n        armorShred: 0.05,\r\n        warningTime: 0,\r\n        ...stats,\r\n    };\r\n    bullet.update(state, bullet);\r\n    state.enemyBullets.push(bullet);\r\n}\r\nfunction shootBulletArc(state, enemy, theta, angle, count, speed, stats = {}) {\r\n    for (let i = 0; i < count; i++) {\r\n        const bulletTheta = count > 1 ? (theta - angle / 2 + angle * i / (count - 1)) : theta;\r\n        shootEnemyBullet(state, enemy, speed * Math.cos(bulletTheta), speed * Math.sin(bulletTheta), stats);\r\n    }\r\n}\r\nfunction shootBulletCircle(state, enemy, theta, count, speed, stats = {}) {\r\n    for (let i = 0; i < count; i++) {\r\n        const bulletTheta = theta + 2 * Math.PI * i / count;\r\n        shootEnemyBullet(state, enemy, speed * Math.cos(bulletTheta), speed * Math.sin(bulletTheta), stats);\r\n    }\r\n}\r\n// This is used to check if the enemy hit a wall when trying to move somewhere.\r\nfunction isEnemyOffDisc(state, enemy) {\r\n    if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc).distance2 >= enemy.disc.radius * enemy.disc.radius) {\r\n        return true;\r\n    }\r\n    for (const hole of state.holes) {\r\n        if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, hole).distance2 < hole.radius * hole.radius) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n// Indicates that the enemy is off the edge of the closest valid disc or inside a pit/wall.\r\nfunction isEnemyPositionInvalid(state, enemy) {\r\n    const disc = enemy.disc.boss ? enemy.disc : (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_2__.findClosestDisc)(enemy, state.activeDiscs);\r\n    if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, disc).distance2 >= disc.radius * disc.radius) {\r\n        return true;\r\n    }\r\n    for (const hole of state.holes) {\r\n        if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, hole).distance2 < hole.radius * hole.radius) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction shootBulletAtHero(state, enemy, speed, stats = {}) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n    const theta = Math.atan2(y, x);\r\n    shootEnemyBullet(state, enemy, speed * Math.cos(theta), speed * Math.sin(theta), stats);\r\n}\r\nfunction shootBulletAtHeroHeading(state, enemy, speed, leadTime, stats = {}) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, {\r\n        x: state.hero.x + state.hero.vx * leadTime / 1000,\r\n        y: state.hero.y + state.hero.vy * leadTime / 1000,\r\n    });\r\n    const theta = Math.atan2(y, x);\r\n    shootEnemyBullet(state, enemy, speed * Math.cos(theta), speed * Math.sin(theta), stats);\r\n}\r\nfunction moveEnemyInCurrentDirection(state, enemy, speed = enemy.speed) {\r\n    enemy.x += speed * Math.cos(enemy.theta) * window.FRAME_LENGTH / 1000;\r\n    enemy.y += speed * Math.sin(enemy.theta) * window.FRAME_LENGTH / 1000;\r\n}\r\nfunction moveEnemyInDirection(state, enemy, theta = enemy.theta, speed = enemy.speed) {\r\n    enemy.x += speed * Math.cos(theta) * window.FRAME_LENGTH / 1000;\r\n    enemy.y += speed * Math.sin(theta) * window.FRAME_LENGTH / 1000;\r\n}\r\nfunction turnTowardsDirection(state, enemy, theta, turnSpeed = 0.2) {\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, turnSpeed, theta);\r\n}\r\nfunction turnTowardsTarget(state, enemy, target, turnSpeed = 0.2) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, target);\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, turnSpeed, Math.atan2(y, x));\r\n}\r\nfunction turnTowardsHeroHeading(state, enemy, leadTime, turnSpeed = 0.2) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, {\r\n        x: state.hero.x + state.hero.vx * leadTime / 1000,\r\n        y: state.hero.y + state.hero.vy * leadTime / 1000,\r\n    });\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, turnSpeed, Math.atan2(y, x));\r\n}\r\nfunction chaseTarget(state, enemy, target, speed = enemy.speed) {\r\n    turnTowardsTarget(state, enemy, target);\r\n    moveEnemyInDirection(state, enemy, enemy.theta, speed);\r\n}\r\nfunction chaseHeroHeading(state, enemy, leadTime = 500, speed = enemy.speed) {\r\n    turnTowardsHeroHeading(state, enemy, leadTime);\r\n    moveEnemyInDirection(state, enemy, enemy.theta, speed);\r\n}\r\nfunction moveEnemyToTarget(state, enemy, { x, y }, speed = enemy.speed) {\r\n    const dx = x - enemy.x, dy = y - enemy.y;\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(dy, dx));\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    enemy.x += Math.min(speed * window.FRAME_LENGTH / 1000, distance) * Math.cos(enemy.theta);\r\n    enemy.y += Math.min(speed * window.FRAME_LENGTH / 1000, distance) * Math.sin(enemy.theta);\r\n    return distance <= speed * window.FRAME_LENGTH / 1000;\r\n}\r\nfunction moveEnemyToTargetWithoutTurning(state, enemy, { x, y }, speed = enemy.speed) {\r\n    const dx = x - enemy.x, dy = y - enemy.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    if (!distance) {\r\n        return true;\r\n    }\r\n    enemy.x += Math.min(speed * window.FRAME_LENGTH / 1000, distance) * dx / distance;\r\n    enemy.y += Math.min(speed * window.FRAME_LENGTH / 1000, distance) * dy / distance;\r\n    return distance <= speed * window.FRAME_LENGTH / 1000;\r\n}\r\nfunction renderNormalizedEnemy(renderEnemy) {\r\n    return (context, state, enemy) => {\r\n        context.save();\r\n        context.translate(enemy.x, enemy.y);\r\n        context.rotate(enemy.theta);\r\n        context.scale(enemy.radius / 100, enemy.radius / 100);\r\n        renderEnemy(context, state, enemy);\r\n        context.restore();\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/enemy.ts?");

/***/ }),

/***/ "./app/utils/geometry.ts":
/*!*******************************!*\
  !*** ./app/utils/geometry.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doCirclesIntersect: () => (/* binding */ doCirclesIntersect),\n/* harmony export */   getClosestElement: () => (/* binding */ getClosestElement),\n/* harmony export */   getTargetVector: () => (/* binding */ getTargetVector),\n/* harmony export */   isCircleInCircle: () => (/* binding */ isCircleInCircle),\n/* harmony export */   isPointInRect: () => (/* binding */ isPointInRect),\n/* harmony export */   turnTowardsAngle: () => (/* binding */ turnTowardsAngle)\n/* harmony export */ });\nfunction isPointInRect({ x, y, w, h }, p) {\r\n    return p.x >= x && p.x <= (x + w) && p.y >= y && p.y <= (y + h);\r\n}\r\nfunction doCirclesIntersect(circleA, circleB) {\r\n    const radius = circleA.radius + circleB.radius;\r\n    const dx = circleB.x - circleA.x, dy = circleB.y - circleA.y;\r\n    return dx * dx + dy * dy < radius * radius;\r\n}\r\nfunction isCircleInCircle(circleA, circleB) {\r\n    const radius = circleB.radius - circleA.radius;\r\n    const dx = circleB.x - circleA.x, dy = circleB.y - circleA.y;\r\n    return dx * dx + dy * dy < radius * radius;\r\n}\r\nfunction getClosestElement({ x, y }, elements) {\r\n    let closestDistance2 = Number.MAX_SAFE_INTEGER, closestElement = elements[0];\r\n    for (const element of elements) {\r\n        const dx = element.x - x, dy = element.y - y;\r\n        const distance2 = dx * dx + dy * dy - element.radius * element.radius;\r\n        if (distance2 < closestDistance2) {\r\n            closestDistance2 = distance2;\r\n            closestElement = element;\r\n        }\r\n    }\r\n    return closestElement;\r\n}\r\nfunction getTargetVector(pointA, pointB) {\r\n    const dx = pointB.x - pointA.x, dy = pointB.y - pointA.y;\r\n    const distance2 = dx * dx + dy * dy;\r\n    if (distance2 <= 0) {\r\n        return { x: 1, y: 0, distance2: 0 };\r\n    }\r\n    return { x: dx, y: dy, distance2 };\r\n}\r\nfunction turnTowardsAngle(theta, delta, targetTheta) {\r\n    const negativeDistance = (theta - targetTheta + 2 * Math.PI) % (2 * Math.PI);\r\n    const positiveDistance = (targetTheta - theta + 2 * Math.PI) % (2 * Math.PI);\r\n    if (negativeDistance <= delta || positiveDistance <= delta) {\r\n        return targetTheta;\r\n    }\r\n    if (negativeDistance < positiveDistance) {\r\n        return theta - delta;\r\n    }\r\n    return theta + delta;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/geometry.ts?");

/***/ }),

/***/ "./app/utils/guardSkill.ts":
/*!*********************************!*\
  !*** ./app/utils/guardSkill.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chargeGuardSkill: () => (/* binding */ chargeGuardSkill),\n/* harmony export */   getDispersionCircle: () => (/* binding */ getDispersionCircle),\n/* harmony export */   getGuardSkillCooldownTime: () => (/* binding */ getGuardSkillCooldownTime),\n/* harmony export */   getMaxGuardSkillCharges: () => (/* binding */ getMaxGuardSkillCharges),\n/* harmony export */   updateGuardSkill: () => (/* binding */ updateGuardSkill),\n/* harmony export */   useGuardSkill: () => (/* binding */ useGuardSkill)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/uniqueEnchantmentHash */ \"./app/uniqueEnchantmentHash.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n\r\n\r\n\r\n\r\n\r\nfunction getMaxGuardSkillCharges(state) {\r\n    if (state.hero.equipment.armor.armorType === 'lightArmor') {\r\n        return 3;\r\n    }\r\n    if (state.hero.equipment.armor.armorType === 'mediumArmor') {\r\n        return 2;\r\n    }\r\n    return 1;\r\n}\r\nfunction getGuardSkillCooldownTime(state) {\r\n    if (state.hero.equipment.armor.armorType === 'lightArmor') {\r\n        const bonus = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.getTotalProficiency)(state, 'lightArmor');\r\n        const multiplier = 100 / (100 + bonus);\r\n        if (state.hero.guardSkill.charges === 0) {\r\n            return multiplier * 3000;\r\n        }\r\n        else if (state.hero.guardSkill.charges === 1) {\r\n            return multiplier * 5000;\r\n        }\r\n        return multiplier * 7000;\r\n    }\r\n    if (state.hero.equipment.armor.armorType === 'mediumArmor') {\r\n        if (state.hero.guardSkill.charges === 0) {\r\n            return 4000;\r\n        }\r\n        else {\r\n            return 6000;\r\n        }\r\n    }\r\n    if (state.hero.equipment.armor.armorType === 'heavyArmor') {\r\n        return 5000;\r\n    }\r\n    return 5000;\r\n}\r\nfunction updateGuardSkill(state) {\r\n    const guardSkill = state.hero.guardSkill;\r\n    if (state.hero.roll) {\r\n        state.hero.roll.time += window.FRAME_LENGTH;\r\n        const roll = state.hero.roll;\r\n        const p = roll.time / roll.duration;\r\n        state.hero.x = roll.start.x + p * (roll.goal.x - roll.start.x);\r\n        state.hero.y = roll.start.y + p * (roll.goal.y - roll.start.y);\r\n        if (p >= 1) {\r\n            delete state.hero.roll;\r\n        }\r\n    }\r\n    else if (guardSkill.duration) {\r\n        guardSkill.time += window.FRAME_LENGTH;\r\n        if (guardSkill.time >= guardSkill.duration) {\r\n            guardSkill.duration = 0;\r\n            // Remove the guard skill effect.\r\n            state.hero.armor = Math.min(state.hero.armor, state.hero.baseArmor);\r\n        }\r\n        if (state.hero.equipment.armor.armorType === 'mediumArmor') {\r\n            const circle = getDispersionCircle(state);\r\n            state.enemyBullets = state.enemyBullets.filter(bullet => !(0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.doCirclesIntersect)(circle, bullet));\r\n        }\r\n    }\r\n    else {\r\n        chargeGuardSkill(state, window.FRAME_LENGTH);\r\n        if (guardSkill.charges > 0 && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.GUARD_SKILL)) {\r\n            useGuardSkill(state);\r\n        }\r\n    }\r\n}\r\nfunction chargeGuardSkill(state, milliseconds) {\r\n    const guardSkill = state.hero.guardSkill;\r\n    if (guardSkill.charges < getMaxGuardSkillCharges(state)) {\r\n        guardSkill.cooldownTime += milliseconds;\r\n        if (guardSkill.cooldownTime >= getGuardSkillCooldownTime(state)) {\r\n            guardSkill.cooldownTime = 0;\r\n            guardSkill.charges++;\r\n        }\r\n    }\r\n}\r\nconst maxRollDistance = 200;\r\nconst baseDispersionRadius = 100;\r\nconst baseShieldDuration = 2000;\r\nfunction getDispersionCircle(state) {\r\n    const bonus = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.getTotalProficiency)(state, 'mediumArmor');\r\n    return {\r\n        x: state.hero.x,\r\n        y: state.hero.y,\r\n        radius: state.hero.guardSkill.duration\r\n            ? baseDispersionRadius * state.hero.guardSkill.time / state.hero.guardSkill.duration * (1 + bonus / 100)\r\n            : 0,\r\n    };\r\n}\r\nfunction useGuardSkill(state) {\r\n    var _a;\r\n    let skipRegularGuard = false;\r\n    for (const enchantment of state.hero.uniqueEnchantments) {\r\n        const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_1__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n        skipRegularGuard = skipRegularGuard || !!((_a = definition.onActivateGuardSkill) === null || _a === void 0 ? void 0 : _a.call(definition, state, enchantment));\r\n    }\r\n    if (skipRegularGuard) {\r\n        return;\r\n    }\r\n    const guardSkill = state.hero.guardSkill;\r\n    guardSkill.charges--;\r\n    if (state.hero.equipment.armor.armorType === 'lightArmor') {\r\n        /*let rollDx = state.mouse.x - window.FIELD_CENTER.x, rollDy = state.mouse.y - window.FIELD_CENTER.y;\r\n        const magnitude = Math.sqrt(rollDx * rollDx + rollDy * rollDy);\r\n        if (magnitude > maxRollDistance) {\r\n            rollDx *= maxRollDistance / magnitude;\r\n            rollDy *= maxRollDistance / magnitude;\r\n        }*/\r\n        let [dx, dy] = (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_4__.getMovementDeltas)(state);\r\n        const m = Math.sqrt(dx * dx + dy * dy);\r\n        if (m > 1) {\r\n            dx /= m;\r\n            dy /= m;\r\n        }\r\n        const rollDx = maxRollDistance * dx, rollDy = maxRollDistance * dy;\r\n        state.hero.roll = {\r\n            start: { x: state.hero.x, y: state.hero.y },\r\n            goal: { x: state.hero.x + rollDx, y: state.hero.y + rollDy },\r\n            time: 0,\r\n            duration: 200,\r\n        };\r\n        return;\r\n    }\r\n    if (state.hero.equipment.armor.armorType === 'mediumArmor') {\r\n        state.hero.guardSkill.duration = 300;\r\n        state.hero.guardSkill.time = 0;\r\n        return;\r\n    }\r\n    if (state.hero.equipment.armor.armorType === 'heavyArmor') {\r\n        const bonus = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.getTotalProficiency)(state, 'heavyArmor');\r\n        guardSkill.duration = baseShieldDuration * (1 + bonus / 100);\r\n        guardSkill.time = 0;\r\n        state.hero.armor = state.hero.baseArmor * 10;\r\n        return;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/guardSkill.ts?");

/***/ }),

/***/ "./app/utils/hero.ts":
/*!***************************!*\
  !*** ./app/utils/hero.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gainEquipmentExperience: () => (/* binding */ gainEquipmentExperience),\n/* harmony export */   gainExperience: () => (/* binding */ gainExperience),\n/* harmony export */   gainItemExperience: () => (/* binding */ gainItemExperience),\n/* harmony export */   getHeroShaveRadius: () => (/* binding */ getHeroShaveRadius),\n/* harmony export */   getMastery: () => (/* binding */ getMastery),\n/* harmony export */   getMaxChargeLevel: () => (/* binding */ getMaxChargeLevel),\n/* harmony export */   getProficiency: () => (/* binding */ getProficiency),\n/* harmony export */   getTotalProficiency: () => (/* binding */ getTotalProficiency),\n/* harmony export */   masteryMap: () => (/* binding */ masteryMap),\n/* harmony export */   refillAllPotions: () => (/* binding */ refillAllPotions),\n/* harmony export */   setDerivedHeroStats: () => (/* binding */ setDerivedHeroStats)\n/* harmony export */ });\n/* harmony import */ var app_bosses_guardian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/bosses/guardian */ \"./app/bosses/guardian.ts\");\n/* harmony import */ var app_bosses_spider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/bosses/spider */ \"./app/bosses/spider.ts\");\n/* harmony import */ var app_enemies_clam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/enemies/clam */ \"./app/enemies/clam.ts\");\n/* harmony import */ var app_enemies_slime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enemies/slime */ \"./app/enemies/slime.ts\");\n/* harmony import */ var app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/uniqueEnchantmentHash */ \"./app/uniqueEnchantmentHash.ts\");\n/* harmony import */ var app_enchantments__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/enchantments */ \"./app/enchantments.ts\");\n/* harmony import */ var app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/coreCalculations */ \"./app/utils/coreCalculations.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst masteryMap = {\r\n    [app_bosses_guardian__WEBPACK_IMPORTED_MODULE_0__.guardian.name]: 'dagger',\r\n    [app_bosses_spider__WEBPACK_IMPORTED_MODULE_1__.spider.name]: 'katana',\r\n    [app_enemies_clam__WEBPACK_IMPORTED_MODULE_2__.giantClam.name]: 'sword',\r\n    [app_enemies_slime__WEBPACK_IMPORTED_MODULE_3__.megaSlime.name]: 'bow',\r\n};\r\nfunction gainExperience(state, experience) {\r\n    const requiredExperience = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_6__.getExperienceForNextLevel)(state.hero.level);\r\n    // You cannot gain more than 100% of the experience for the next level at once.\r\n    state.hero.experience += Math.min(experience, requiredExperience);\r\n    if (state.hero.experience >= requiredExperience) {\r\n        state.hero.level++;\r\n        state.hero.experience -= requiredExperience;\r\n        setDerivedHeroStats(state);\r\n        refillAllPotions(state);\r\n    }\r\n}\r\nfunction gainEquipmentExperience(state, type, sourceLevel, experience) {\r\n    const proficiency = getProficiency(state, type);\r\n    const xpPenalty = Math.min(1, Math.max(0, (proficiency.level - sourceLevel) * 0.1));\r\n    const requiredExperience = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_6__.getExperienceForNextEquipmentLevel)(proficiency.level);\r\n    // You cannot gain more than 25% of the experience for the next weapon level at once.\r\n    proficiency.experience += Math.min(Math.ceil(experience * (1 - xpPenalty)), requiredExperience / 4);\r\n    if (proficiency.experience >= requiredExperience) {\r\n        proficiency.level++;\r\n        proficiency.experience -= requiredExperience;\r\n        setDerivedHeroStats(state);\r\n    }\r\n}\r\nfunction getProficiency(state, type) {\r\n    return state.hero.proficiency[type] = state.hero.proficiency[type] || { level: 0, experience: 0 };\r\n}\r\nfunction getMastery(state, type) {\r\n    return state.hero.mastery[type] = state.hero.mastery[type] || 0;\r\n}\r\nfunction getTotalProficiency(state, type) {\r\n    return getProficiency(state, type).level + getMastery(state, type);\r\n}\r\nfunction gainItemExperience(state, item) {\r\n    const experiencePenalty = Math.min(1, Math.max(0, (state.hero.level - item.level) * 0.1));\r\n    const experience = window.BASE_XP * Math.pow(1.2, item.level) * 1.5;\r\n    gainExperience(state, Math.ceil(experience * (1 - experiencePenalty)));\r\n    if (item.type === 'armor') {\r\n        gainEquipmentExperience(state, item.armorType, item.level, 2 * experience);\r\n    }\r\n    if (item.type === 'weapon') {\r\n        gainEquipmentExperience(state, item.weaponType, item.level, 2 * experience);\r\n    }\r\n}\r\nfunction setDerivedHeroStats(state) {\r\n    var _a, _b;\r\n    state.hero.uniqueEnchantments = [];\r\n    state.hero.flags = {};\r\n    // This must be calculated before anything that uses weapon proficiency which is derived in part from these numbers.\r\n    state.hero.mastery = {};\r\n    for (const bossName of Object.keys(state.hero.bossRecords)) {\r\n        const weaponType = masteryMap[bossName];\r\n        const bonus = 5 + Math.floor(state.hero.bossRecords[bossName] / 5);\r\n        state.hero.mastery[weaponType] = (state.hero.mastery[weaponType] || 0) + bonus;\r\n    }\r\n    const { armor, weapon } = state.hero.equipment;\r\n    const weaponLevel = weapon.level;\r\n    const proficiency = getTotalProficiency(state, weapon.weaponType);\r\n    state.hero.damage = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_6__.getHeroWeaponProficiencyLevelDamageBonus)(proficiency) * (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_6__.getHeroLevelDamageBonus)(state.hero.level);\r\n    state.hero.attacksPerSecond = 1 + 0.01 * state.hero.level + 0.01 * proficiency;\r\n    // If weapon level is higher than your proficiency, attack speed is reduced down to a minimum of 10% base attack speed.\r\n    const proficiencyDefecit = weaponLevel - proficiency;\r\n    if (proficiencyDefecit > 0) {\r\n        state.hero.attacksPerSecond = state.hero.attacksPerSecond * Math.max(0.1, 0.95 ** proficiencyDefecit);\r\n    }\r\n    const lifePercentage = state.hero.life / state.hero.maxLife;\r\n    const armorPercentage = state.hero.baseArmor ? (state.hero.armor / state.hero.baseArmor) : 0;\r\n    state.hero.maxLife = 20 * state.hero.level;\r\n    state.hero.baseArmor = 0;\r\n    state.hero.speed = 400;\r\n    state.hero.potionEffect = 1;\r\n    state.hero.dropChance = 0;\r\n    state.hero.dropLevel = 0;\r\n    state.hero.maxLife += armor.life;\r\n    state.hero.baseArmor += armor.armor;\r\n    state.hero.speed *= armor.speedFactor;\r\n    // Bow gives 0.1% -> 10% increased crit chance\r\n    state.hero.critChance = getTotalProficiency(state, 'bow') * 0.001;\r\n    // Dagger gives +0.01 -> 1 increased base attacks per second\r\n    state.hero.attacksPerSecond += getTotalProficiency(state, 'dagger') * 0.01;\r\n    // Katana gives 1% -> 100% increased crit damage\r\n    state.hero.critDamage = getTotalProficiency(state, 'katana') * 0.01;\r\n    // Morning Star gives +0.01 -> 1 increased armor shred effect\r\n    state.hero.armorShredEffect = 1 + getTotalProficiency(state, 'morningStar') * 0.01;\r\n    // Staff gives +0.01 -> 1 increased charge damage\r\n    state.hero.chargeDamage = getTotalProficiency(state, 'wand') * 0.01;\r\n    // Sword gives 1% -> 100% increased damage\r\n    state.hero.damage *= (1 + getTotalProficiency(state, 'sword') * 0.01);\r\n    state.hero.maxLife *= (1 + getTotalProficiency(state, 'mediumArmor') * 0.01);\r\n    state.hero.baseArmor *= (1 + getTotalProficiency(state, 'heavyArmor') * 0.01);\r\n    // Enchantments are applied last to stats.\r\n    (0,app_enchantments__WEBPACK_IMPORTED_MODULE_5__.applyEnchantmentsToStats)(state);\r\n    // Make sure updating stats doesn't change the hero's life percentage beyond rounding it.\r\n    state.hero.maxLife = Math.ceil(state.hero.maxLife);\r\n    state.hero.life = Math.round(lifePercentage * state.hero.maxLife);\r\n    state.hero.armor = armorPercentage * state.hero.baseArmor;\r\n    const allSlots = [\r\n        ...armor.enchantmentSlots,\r\n        ...armor.bonusEnchantmentSlots,\r\n        ...weapon.enchantmentSlots,\r\n        ...weapon.bonusEnchantmentSlots,\r\n    ];\r\n    for (const enchantment of allSlots) {\r\n        if (enchantment.enchantmentType === 'uniqueArmorEnchantment' || enchantment.enchantmentType === 'uniqueWeaponEnchantment') {\r\n            state.hero.uniqueEnchantments.push(enchantment);\r\n            const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_4__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n            for (const flag of ((_a = definition.flags) !== null && _a !== void 0 ? _a : [])) {\r\n                state.hero.flags[flag] = true;\r\n            }\r\n            (_b = definition.modifyHero) === null || _b === void 0 ? void 0 : _b.call(definition, state, enchantment);\r\n        }\r\n    }\r\n}\r\nfunction refillAllPotions(state) {\r\n    state.hero.life = state.hero.maxLife;\r\n    state.hero.potions = window.BASE_MAX_POTIONS;\r\n    state.hero.armor = Math.max(state.hero.armor, state.hero.baseArmor);\r\n}\r\nfunction getMaxChargeLevel(state) {\r\n    const proficiency = getTotalProficiency(state, state.hero.equipment.weapon.weaponType);\r\n    return state.hero.equipment.weapon.chargeLevel + Math.floor(proficiency / 25);\r\n}\r\nfunction getHeroShaveRadius(state) {\r\n    const bonus = (1 + getTotalProficiency(state, 'lightArmor') / 100);\r\n    let p = (state.hero.attackChargeLevel > 1)\r\n        ? 0\r\n        : 1 - (state.hero.chargingLevel - 1) / (getMaxChargeLevel(state) - 1);\r\n    if (state.hero.flags.noShaveShrink) {\r\n        p = 1;\r\n    }\r\n    if (state.hero.equipment.armor.armorType === 'lightArmor') {\r\n        return p * 1.25 * window.BULLET_SHAVE_RADIUS * bonus;\r\n    }\r\n    if (state.hero.equipment.armor.armorType === 'heavyArmor') {\r\n        return p * 0.75 * window.BULLET_SHAVE_RADIUS * bonus;\r\n    }\r\n    return p * window.BULLET_SHAVE_RADIUS * bonus;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/hero.ts?");

/***/ }),

/***/ "./app/utils/item.ts":
/*!***************************!*\
  !*** ./app/utils/item.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEnchantmentSlot: () => (/* binding */ addEnchantmentSlot),\n/* harmony export */   applyUniqueItemEnchantments: () => (/* binding */ applyUniqueItemEnchantments),\n/* harmony export */   generateArmor: () => (/* binding */ generateArmor),\n/* harmony export */   generateWeapon: () => (/* binding */ generateWeapon),\n/* harmony export */   resetArmor: () => (/* binding */ resetArmor),\n/* harmony export */   resetWeapon: () => (/* binding */ resetWeapon)\n/* harmony export */ });\n/* harmony import */ var app_armor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/armor */ \"./app/armor.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n/* harmony import */ var app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/uniqueEnchantmentHash */ \"./app/uniqueEnchantmentHash.ts\");\n\r\n\r\n\r\nfunction addEnchantmentSlot(item) {\r\n    item.enchantmentSlots.push({ enchantmentType: 'empty', value: 0 });\r\n}\r\nfunction resetArmor(armor) {\r\n    const defaultArmor = generateArmor(armor.armorType, armor.level);\r\n    Object.assign(armor, {\r\n        ...defaultArmor,\r\n        enchantmentSlots: armor.enchantmentSlots,\r\n        bonusEnchantmentSlots: armor.bonusEnchantmentSlots,\r\n    });\r\n}\r\nfunction applyUniqueItemEnchantments(item) {\r\n    var _a, _b;\r\n    for (const enchantment of [...item.enchantmentSlots, ...item.bonusEnchantmentSlots]) {\r\n        if (enchantment.enchantmentType === 'uniqueArmorEnchantment' || enchantment.enchantmentType === 'uniqueWeaponEnchantment') {\r\n            const definition = app_uniqueEnchantmentHash__WEBPACK_IMPORTED_MODULE_2__.uniqueEnchantmentHash[enchantment.uniqueEnchantmentKey];\r\n            if (item.type === 'armor') {\r\n                (_a = definition.modifyArmor) === null || _a === void 0 ? void 0 : _a.call(definition, enchantment, item);\r\n            }\r\n            if (item.type === 'weapon') {\r\n                (_b = definition.modifyWeapon) === null || _b === void 0 ? void 0 : _b.call(definition, enchantment, item);\r\n            }\r\n        }\r\n    }\r\n}\r\n// Generates the base armor item for a given type+level.\r\nfunction generateArmor(armorType, level) {\r\n    const armorArray = app_armor__WEBPACK_IMPORTED_MODULE_0__.armorsByType[armorType];\r\n    let armorIndex = 0;\r\n    for (; armorIndex < armorArray.length - 1; armorIndex++) {\r\n        if (armorArray[armorIndex + 1].level > level) {\r\n            break;\r\n        }\r\n    }\r\n    const armor = { ...armorArray[armorIndex] };\r\n    for (let i = 0; i < 5 && armor.level < level; i++) {\r\n        armor.level++;\r\n        armor.name = armor.name + '+';\r\n        armor.armor = Math.ceil(armor.armor * 1.1);\r\n        armor.life = Math.ceil(armor.life * 1.1);\r\n    }\r\n    return armor;\r\n}\r\nfunction resetWeapon(weapon) {\r\n    const defaultWeapon = generateWeapon(weapon.weaponType, weapon.level);\r\n    Object.assign(weapon, {\r\n        ...defaultWeapon,\r\n        enchantmentSlots: weapon.enchantmentSlots,\r\n        bonusEnchantmentSlots: weapon.bonusEnchantmentSlots,\r\n    });\r\n}\r\nfunction generateWeapon(weaponType, level) {\r\n    let weaponArray = app_weapons__WEBPACK_IMPORTED_MODULE_1__.weaponsByType[weaponType];\r\n    if (!weaponArray.length) {\r\n        weaponArray = app_weapons__WEBPACK_IMPORTED_MODULE_1__.weaponsByType.sword;\r\n    }\r\n    let weaponIndex = 0;\r\n    for (; weaponIndex < weaponArray.length - 1; weaponIndex++) {\r\n        if (weaponArray[weaponIndex + 1].level > level) {\r\n            break;\r\n        }\r\n    }\r\n    const weapon = { ...weaponArray[weaponIndex] };\r\n    for (let i = 0; i < 5 && weapon.level < level; i++) {\r\n        weapon.level++;\r\n        weapon.name = weapon.name + '+';\r\n        weapon.damage = Math.ceil(weapon.damage * 1.1);\r\n    }\r\n    return weapon;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/item.ts?");

/***/ }),

/***/ "./app/utils/mouse.ts":
/*!****************************!*\
  !*** ./app/utils/mouse.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addContextMenuListeners: () => (/* binding */ addContextMenuListeners),\n/* harmony export */   bindMouseListeners: () => (/* binding */ bindMouseListeners),\n/* harmony export */   getMousePosition: () => (/* binding */ getMousePosition),\n/* harmony export */   isMiddleMouseDown: () => (/* binding */ isMiddleMouseDown),\n/* harmony export */   isMouseDown: () => (/* binding */ isMouseDown),\n/* harmony export */   isMouseOverElement: () => (/* binding */ isMouseOverElement),\n/* harmony export */   isRightMouseDown: () => (/* binding */ isRightMouseDown)\n/* harmony export */ });\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n//import { window.CANVAS_SCALE } from 'app/constants';\r\n\r\n\r\nlet mousePosition = [-1000, -1000];\r\nlet mouseIsDown = false;\r\nlet rightMouseIsDown = false;\r\nlet middleMouseIsDown = false;\r\nfunction isMouseDown() {\r\n    return mouseIsDown;\r\n}\r\nfunction getMousePosition(container = null, scale = 1) {\r\n    if (container) {\r\n        const containerRect = container.getBoundingClientRect();\r\n        return [\r\n            (mousePosition[0] - containerRect.x) / scale,\r\n            (mousePosition[1] - containerRect.y) / scale,\r\n        ];\r\n    }\r\n    return [mousePosition[0] / scale, mousePosition[1] / scale];\r\n}\r\nfunction onMouseMove(event) {\r\n    mousePosition = [event.pageX, event.pageY];\r\n    // console.log(mousePosition);\r\n}\r\nfunction onMouseDown(event) {\r\n    if (event.which === 1)\r\n        mouseIsDown = true;\r\n    if (event.which === 2)\r\n        middleMouseIsDown = true;\r\n    if (event.which === 3)\r\n        rightMouseIsDown = true;\r\n}\r\nfunction onMouseUp(event) {\r\n    if (event.which === 1)\r\n        mouseIsDown = false;\r\n    if (event.which === 2)\r\n        middleMouseIsDown = false;\r\n    if (event.which === 3)\r\n        rightMouseIsDown = false;\r\n}\r\nfunction bindMouseListeners() {\r\n    document.addEventListener('mousemove', onMouseMove);\r\n    document.addEventListener('mousedown', onMouseDown);\r\n    document.addEventListener('mouseup', onMouseUp);\r\n}\r\n/* This would in theory be used if we ever cleaned up the application\r\nexport function unbindMouseListeners() {\r\n    document.removeEventListener('mousemove', onMouseMove);\r\n    document.removeEventListener('mousedown', onMouseDown);\r\n    document.removeEventListener('mouseup', onMouseUp);\r\n    // Prevent mouse from being \"stuck down\"\r\n    mouseIsDown = false;\r\n}*/\r\nfunction isMouseOverElement(element) {\r\n    const rect = element.getBoundingClientRect();\r\n    return mousePosition[0] >= rect.x && mousePosition[0] <= rect.x + rect.width\r\n        && mousePosition[1] >= rect.y && mousePosition[1] <= rect.y + rect.height;\r\n}\r\nfunction isMiddleMouseDown() {\r\n    return middleMouseIsDown;\r\n}\r\nfunction isRightMouseDown() {\r\n    return rightMouseIsDown;\r\n}\r\nfunction addContextMenuListeners() {\r\n    // Prevent the context menu from displaying when clicking over the canvas unless shift is held.\r\n    app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__.mainCanvas.addEventListener('contextmenu', function (event) {\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.KEY.SHIFT)) {\r\n            return;\r\n        }\r\n        event.preventDefault();\r\n        // const [x, y] = getMousePosition();\r\n        // lastContextClick = getMousePosition(mainCanvas, window.CANVAS_SCALE);\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/mouse.ts?");

/***/ }),

/***/ "./app/utils/noteFrequencies.ts":
/*!**************************************!*\
  !*** ./app/utils/noteFrequencies.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   noteFrequencies: () => (/* binding */ noteFrequencies)\n/* harmony export */ });\nconst noteFrequencies = {\r\n    C0: 16.35,\r\n    Cs0: 17.32,\r\n    D0: 18.35,\r\n    Ds0: 19.45,\r\n    E0: 20.60,\r\n    F0: 21.83,\r\n    Fs0: 23.12,\r\n    G0: 24.50,\r\n    Gs0: 25.96,\r\n    A0: 27.50,\r\n    As0: 29.14,\r\n    B0: 30.87,\r\n    C1: 32.70,\r\n    Cs1: 34.65,\r\n    D1: 36.71,\r\n    Ds1: 38.89,\r\n    E1: 41.20,\r\n    F1: 43.65,\r\n    Fs1: 46.25,\r\n    G1: 49.00,\r\n    Gs1: 51.91,\r\n    A1: 55.00,\r\n    As1: 58.27,\r\n    B1: 61.74,\r\n    C2: 65.41,\r\n    Cs2: 69.30,\r\n    D2: 73.42,\r\n    Ds2: 77.78,\r\n    E2: 82.41,\r\n    F2: 87.31,\r\n    Fs2: 92.50,\r\n    G2: 98.00,\r\n    Gs2: 103.83,\r\n    A2: 110.00,\r\n    As2: 116.54,\r\n    B2: 123.47,\r\n    C3: 130.81,\r\n    Cs3: 138.59,\r\n    D3: 146.83,\r\n    Ds3: 155.56,\r\n    E3: 164.81,\r\n    F3: 174.61,\r\n    Fs3: 185.00,\r\n    G3: 196.00,\r\n    Gs3: 207.65,\r\n    A3: 220.00,\r\n    As3: 233.08,\r\n    B3: 246.94,\r\n    C4: 261.63,\r\n    Cs4: 277.18,\r\n    D4: 293.66,\r\n    Ds4: 311.13,\r\n    E4: 329.63,\r\n    F4: 349.23,\r\n    Fs4: 369.99,\r\n    G4: 392.00,\r\n    Gs4: 415.30,\r\n    A4: 440.00,\r\n    As4: 466.16,\r\n    B4: 493.88,\r\n    C5: 523.25,\r\n    Cs5: 554.37,\r\n    D5: 587.33,\r\n    Ds5: 622.25,\r\n    E5: 659.25,\r\n    F5: 698.46,\r\n    Fs5: 739.99,\r\n    G5: 783.99,\r\n    Gs5: 830.61,\r\n    A5: 880.00,\r\n    As5: 932.33,\r\n    B5: 987.77,\r\n    C6: 1046.50,\r\n    Cs6: 1108.73,\r\n    D6: 1174.66,\r\n    Ds6: 1244.51,\r\n    E6: 1318.51,\r\n    F6: 1396.91,\r\n    Fs6: 1479.98,\r\n    G6: 1567.98,\r\n    Gs6: 1661.22,\r\n    A6: 1760.00,\r\n    As6: 1864.66,\r\n    B6: 1975.53,\r\n    C7: 2093.00,\r\n    Cs7: 2217.46,\r\n    D7: 2349.32,\r\n    Ds7: 2489.02,\r\n    E7: 2637.02,\r\n    F7: 2793.83,\r\n    Fs7: 2959.96,\r\n    G7: 3135.96,\r\n    Gs7: 3322.44,\r\n    A7: 3520.00,\r\n    As7: 3729.31,\r\n    B7: 3951.07,\r\n    C8: 4186.01,\r\n    Cs8: 4434.92,\r\n    D8: 4698.63,\r\n    Ds8: 4978.03,\r\n    E8: 5274.04,\r\n    F8: 5587.65,\r\n    Fs8: 5919.91,\r\n    G8: 6271.93,\r\n    Gs8: 6644.88,\r\n    A8: 7040.00,\r\n    As8: 7458.62,\r\n    B8: 7902.13,\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/noteFrequencies.ts?");

/***/ }),

/***/ "./app/utils/overworld.ts":
/*!********************************!*\
  !*** ./app/utils/overworld.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addOverworldPortalToDisc: () => (/* binding */ addOverworldPortalToDisc),\n/* harmony export */   clearNearbyEnemies: () => (/* binding */ clearNearbyEnemies),\n/* harmony export */   createWorldCell: () => (/* binding */ createWorldCell),\n/* harmony export */   getCellCoordinates: () => (/* binding */ getCellCoordinates),\n/* harmony export */   returnToOverworld: () => (/* binding */ returnToOverworld),\n/* harmony export */   updateActiveCells: () => (/* binding */ updateActiveCells)\n/* harmony export */ });\n/* harmony import */ var app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/bosses/spider */ \"./app/bosses/spider.ts\");\n/* harmony import */ var app_enemies_bandit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enemies/bandit */ \"./app/enemies/bandit.ts\");\n/* harmony import */ var app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/enemies/bat */ \"./app/enemies/bat.ts\");\n/* harmony import */ var app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enemies/chest */ \"./app/enemies/chest.ts\");\n/* harmony import */ var app_enemies_clam__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/enemies/clam */ \"./app/enemies/clam.ts\");\n/* harmony import */ var app_enemies_crab__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/enemies/crab */ \"./app/enemies/crab.ts\");\n/* harmony import */ var app_enemies_dragon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/enemies/dragon */ \"./app/enemies/dragon.ts\");\n/* harmony import */ var app_events_thrivingReef__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/events/thrivingReef */ \"./app/events/thrivingReef.ts\");\n/* harmony import */ var app_enemies_ent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/enemies/ent */ \"./app/enemies/ent.ts\");\n/* harmony import */ var app_enemies_lord__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/enemies/lord */ \"./app/enemies/lord.ts\");\n/* harmony import */ var app_enemies_skeleton__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/enemies/skeleton */ \"./app/enemies/skeleton.ts\");\n/* harmony import */ var app_enemies_slime__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/enemies/slime */ \"./app/enemies/slime.ts\");\n/* harmony import */ var app_enemies_scorpion__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/enemies/scorpion */ \"./app/enemies/scorpion.ts\");\n/* harmony import */ var app_enemies_snake__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/enemies/snake */ \"./app/enemies/snake.ts\");\n/* harmony import */ var app_enemies_sniper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/enemies/sniper */ \"./app/enemies/sniper.ts\");\n/* harmony import */ var app_enemies_squid__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/enemies/squid */ \"./app/enemies/squid.ts\");\n/* harmony import */ var app_enemies_swampThing__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! app/enemies/swampThing */ \"./app/enemies/swampThing.ts\");\n/* harmony import */ var app_enemies_tornado__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! app/enemies/tornado */ \"./app/enemies/tornado.ts\");\n/* harmony import */ var app_enemies_turret__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! app/enemies/turret */ \"./app/enemies/turret.ts\");\n/* harmony import */ var app_enemies_urchin__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! app/enemies/urchin */ \"./app/enemies/urchin.ts\");\n/* harmony import */ var app_enemies_wolf__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! app/enemies/wolf */ \"./app/enemies/wolf.ts\");\n/* harmony import */ var app_utils_disc__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! app/utils/disc */ \"./app/utils/disc.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n/* harmony import */ var app_utils_SRandom__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! app/utils/SRandom */ \"./app/utils/SRandom.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction returnToOverworld(state) {\r\n    var _a;\r\n    delete state.dungeon;\r\n    // If the player happens to leave during a boss fight, we have to clear the\r\n    // boss in order to automatically assign them to a different disc.\r\n    if ((_a = state.hero.disc) === null || _a === void 0 ? void 0 : _a.boss) {\r\n        delete state.hero.disc.boss;\r\n    }\r\n    state.hero.x = state.hero.overworldX;\r\n    state.hero.y = state.hero.overworldY;\r\n    clearNearbyEnemies(state);\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_24__.refillAllPotions)(state);\r\n    (0,app_saveGame__WEBPACK_IMPORTED_MODULE_25__.saveGame)(state);\r\n}\r\nfunction addOverworldPortalToDisc({ x, y }, disc) {\r\n    const portal = {\r\n        x, y, radius: 40,\r\n        disc,\r\n        name: 'Overworld',\r\n        activate(state) {\r\n            returnToOverworld(state);\r\n        },\r\n    };\r\n    disc.portals.push(portal);\r\n    return portal;\r\n}\r\nfunction getCellCoordinates(state, x = state.hero.x, y = state.hero.y) {\r\n    return {\r\n        x: Math.floor(x / window.CELL_SIZE),\r\n        y: Math.floor(-y / window.CELL_SIZE),\r\n    };\r\n}\r\nfunction clearNearbyEnemies(state) {\r\n    updateActiveCells(state);\r\n    for (const enemy of state.enemies) {\r\n        if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_23__.getTargetVector)(state.hero, enemy).distance2 <= 1000 ** 2) {\r\n            // This will cause the enemy to be cleaned up when `updateActiveCells` is called again.\r\n            enemy.life = 0;\r\n        }\r\n    }\r\n    updateActiveCells(state);\r\n}\r\nfunction updateActiveCells(state) {\r\n    // Cells only apply when on the overworld.\r\n    if (!state.dungeon) {\r\n        state.activeDiscs = [];\r\n        state.activeCells = [];\r\n        const { x: minX, y: minY } = getCellCoordinates(state, state.hero.x - 3750, state.hero.y + 3750);\r\n        const { x: maxX, y: maxY } = getCellCoordinates(state, state.hero.x + 3750, state.hero.y - 3750);\r\n        for (let cellY = Math.max(0, minY); cellY <= maxY; cellY++) {\r\n            for (let cellX = minX; cellX <= maxX; cellX++) {\r\n                const cellKey = `${cellX}x${cellY}`;\r\n                const cell = state.cellMap.get(cellKey) || createWorldCell(state, { x: cellX, y: cellY });\r\n                addCellTohistory(state, cell);\r\n                state.cellMap.set(cellKey, cell);\r\n                state.activeCells.push(cell);\r\n                state.activeDiscs = [...state.activeDiscs, ...cell.discs];\r\n            }\r\n        }\r\n        state.visibleDiscs = state.activeDiscs;\r\n    }\r\n    state.enemies = [];\r\n    state.loot = [];\r\n    state.portals = [];\r\n    state.holes = [];\r\n    // This is 4x the player's sight radius.\r\n    // Note that enemies outside of this radius will not render on the extended map.\r\n    const enemyR2 = 1600 ** 2;\r\n    const itemR2 = 500 ** 2;\r\n    for (const disc of state.activeDiscs) {\r\n        disc.enemies = disc.enemies.filter(e => e.life > 0);\r\n        for (const enemy of disc.enemies) {\r\n            if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_23__.getTargetVector)(enemy, state.hero).distance2 < enemyR2) {\r\n                state.enemies.push(enemy);\r\n            }\r\n        }\r\n        for (const loot of disc.loot) {\r\n            if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_23__.getTargetVector)(loot, state.hero).distance2 < itemR2) {\r\n                state.loot.push(loot);\r\n            }\r\n        }\r\n        for (const portal of disc.portals) {\r\n            if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_23__.getTargetVector)(portal, state.hero).distance2 < itemR2) {\r\n                state.portals.push(portal);\r\n            }\r\n        }\r\n        for (const hole of disc.holes) {\r\n            state.holes.push(hole);\r\n        }\r\n    }\r\n}\r\nfunction addCellTohistory(state, cell) {\r\n    const index = state.recentCells.indexOf(cell);\r\n    if (index) {\r\n        state.recentCells.splice(index, 1);\r\n    }\r\n    state.recentCells.unshift(cell);\r\n    // Forget about cells that have not been active recently.\r\n    if (state.recentCells.length > 100) {\r\n        const ancientCell = state.recentCells.pop();\r\n        state.cellMap.delete(`${ancientCell.x}x${ancientCell.y}`);\r\n    }\r\n}\r\nfunction getCellLevel(randomizer, cellY) {\r\n    if (cellY === 0) {\r\n        return 1;\r\n    }\r\n    if (cellY === 1) {\r\n        return randomizer.range(2, 3);\r\n    }\r\n    if (cellY === 2) {\r\n        return randomizer.range(4, 5);\r\n    }\r\n    if (cellY === 3) {\r\n        return randomizer.range(6, 8);\r\n    }\r\n    const baseLevel = Math.min(90, 10 * (Math.floor(cellY / 2) - 1));\r\n    if (cellY % 2 === 0) {\r\n        // 9/10/11\r\n        return randomizer.range(baseLevel - 1, baseLevel + 1);\r\n    }\r\n    // 13/14/15\r\n    return randomizer.range(baseLevel + 3, baseLevel + 5);\r\n}\r\nfunction getBiome(cellY, randomizer) {\r\n    // There is a 20% chance to spawn lower tier biomes at higher tiers.\r\n    // We always reduce by 2+ tiers so that the same tier doesn't appear at very different\r\n    // levels next to each other. If that happens, a player can accidentally enter more\r\n    // difficult areas without any warning.\r\n    for (let alternateY = cellY - 4; alternateY >= 0; alternateY -= 4) {\r\n        if (randomizer.generateAndMutate() < 0.05) {\r\n            return getBiome(alternateY, randomizer);\r\n        }\r\n    }\r\n    /*if (cellY >= 4 && randomizer.generateAndMutate() < 0.2) {\r\n        return getBiome(cellY - 4, randomizer);\r\n    } else if (cellY >= 2 && cellY < 4 && randomizer.generateAndMutate() < 0.2) {\r\n        return getBiome(cellY - 2, randomizer);\r\n    }*/\r\n    if (cellY <= 1) {\r\n        // Tan sand with blue sides\r\n        return {\r\n            name: 'Beach',\r\n            color: '#FC8',\r\n            centerColor: '#FDB',\r\n            topEdgeColor: '#4CF',\r\n            bottomEdgeColor: '#28F',\r\n        };\r\n    }\r\n    if (cellY <= 3) {\r\n        // Yellow sand, yellow sides\r\n        return {\r\n            name: 'Desert',\r\n            color: '#FE4',\r\n            centerColor: '#FF8',\r\n            topEdgeColor: '#DC2',\r\n            bottomEdgeColor: '#BA0',\r\n        };\r\n    }\r\n    if (cellY <= 5) {\r\n        // Grass green, earth brown sides\r\n        return {\r\n            name: 'Field',\r\n            color: '#4E8',\r\n            centerColor: '#8FA',\r\n            topEdgeColor: '#640',\r\n            bottomEdgeColor: '#320',\r\n        };\r\n    }\r\n    if (cellY <= 7) { // Level 10\r\n        // Dark green, earth brown sides\r\n        return {\r\n            name: 'Forest',\r\n            color: '#080',\r\n            centerColor: '#0B4',\r\n            topEdgeColor: '#640',\r\n            bottomEdgeColor: '#320',\r\n        };\r\n    }\r\n    if (cellY <= 9) {\r\n        // Mustard green with matching sides\r\n        return {\r\n            name: 'Swamp',\r\n            color: '#682',\r\n            centerColor: '#8A4',\r\n            topEdgeColor: '#350',\r\n            bottomEdgeColor: '#230',\r\n        };\r\n    }\r\n    if (cellY <= 11) { // Level 30\r\n        return {\r\n            name: 'Foothills',\r\n            // Light bluish-green grass\r\n            color: '#6FA',\r\n            centerColor: '#AFC',\r\n            // lighter brown earth sides\r\n            topEdgeColor: '#862',\r\n            bottomEdgeColor: '#542',\r\n        };\r\n    }\r\n    if (cellY <= 13) {\r\n        return {\r\n            name: 'Mountains',\r\n            // Very slightly brown grey\r\n            color: '#998',\r\n            centerColor: '#BBA',\r\n            topEdgeColor: '#887',\r\n            bottomEdgeColor: '#665',\r\n        };\r\n    }\r\n    if (cellY <= 15) { // Level 50\r\n        return {\r\n            name: 'Frozen Peaks',\r\n            // Very pale blue ice/snow\r\n            color: '#CDF',\r\n            centerColor: '#DEF',\r\n            // Pale blue top layer of ice/snow\r\n            topEdgeColor: '#BCF',\r\n            // Dark grey stone\r\n            bottomEdgeColor: '#666',\r\n        };\r\n    }\r\n    if (cellY <= 17) { // Level 60\r\n        return {\r\n            name: 'Descent',\r\n            // Monochrome grey, but not too dark\r\n            color: '#999',\r\n            // Center color is darker than base color\r\n            centerColor: '#777',\r\n            topEdgeColor: '#555',\r\n            bottomEdgeColor: '#333',\r\n        };\r\n    }\r\n    if (cellY <= 19) { // Level 70\r\n        return {\r\n            name: 'Badlands',\r\n            // Sickly yellow brown surface\r\n            color: '#996',\r\n            centerColor: '#AA5',\r\n            topEdgeColor: '#885',\r\n            bottomEdgeColor: '#553',\r\n        };\r\n    }\r\n    if (cellY <= 21) { // Level 80\r\n        return {\r\n            name: 'Inferno',\r\n            //Top is burning fire/lava surface\r\n            color: '#F94',\r\n            centerColor: '#FC0',\r\n            // Red cool lava layer\r\n            topEdgeColor: '#C42',\r\n            // Bright orange molten core\r\n            bottomEdgeColor: '#FC0',\r\n        };\r\n    }\r\n    // Level 90\r\n    return {\r\n        name: 'Abyss',\r\n        // Very dark base color has poor contrast with black background\r\n        color: '#111',\r\n        // Slightly lighter center color so it doesn't look like a pit.\r\n        centerColor: '#222',\r\n        // Purple edges\r\n        topEdgeColor: '#A6A',\r\n        bottomEdgeColor: '#424',\r\n    };\r\n}\r\nfunction addOverworldEnemiesToDisc(state, randomizer, disc) {\r\n    if (disc.name === 'Beach') {\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_clam__WEBPACK_IMPORTED_MODULE_4__.clam, disc.level, disc);\r\n        }\r\n        else if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_urchin__WEBPACK_IMPORTED_MODULE_19__.urchin, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.4) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 100, app_enemies_crab__WEBPACK_IMPORTED_MODULE_5__.crab, disc.level, disc);\r\n            if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.2) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 100, app_enemies_crab__WEBPACK_IMPORTED_MODULE_5__.crab, disc.level, disc);\r\n            }\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.4) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 100, disc.y, app_enemies_squid__WEBPACK_IMPORTED_MODULE_15__.squid, disc.level, disc);\r\n            if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.2) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 100, app_enemies_squid__WEBPACK_IMPORTED_MODULE_15__.squid, disc.level, disc);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (disc.name === 'Desert') {\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_18__.turret, disc.level, disc);\r\n        }\r\n        else if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_lord__WEBPACK_IMPORTED_MODULE_9__.lord, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.1) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 100, app_enemies_scorpion__WEBPACK_IMPORTED_MODULE_12__.scorpion, disc.level, disc);\r\n        }\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 1) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 100, app_enemies_tornado__WEBPACK_IMPORTED_MODULE_17__.dustDevil, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 100, disc.y, app_enemies_skeleton__WEBPACK_IMPORTED_MODULE_10__.skeleton, disc.level, disc);\r\n        }\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 100, disc.y, app_enemies_skeleton__WEBPACK_IMPORTED_MODULE_10__.skeleton, disc.level, disc);\r\n        }\r\n        return;\r\n    }\r\n    if (disc.name === 'Field') {\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_bandit__WEBPACK_IMPORTED_MODULE_1__.bandit, disc.level, disc);\r\n        }\r\n        else if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_lord__WEBPACK_IMPORTED_MODULE_9__.lord, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.1) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 1) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 100, app_enemies_wolf__WEBPACK_IMPORTED_MODULE_20__.wolf, disc.level, disc);\r\n        }\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 1) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 100, app_enemies_wolf__WEBPACK_IMPORTED_MODULE_20__.wolf, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 100, disc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_11__.slime, disc.level, disc);\r\n        }\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 100, disc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_11__.slime, disc.level, disc);\r\n        }\r\n        return;\r\n    }\r\n    if (disc.name === 'Forest') {\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.6) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_ent__WEBPACK_IMPORTED_MODULE_8__.ent, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_18__.turret, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.1) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 100, app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.overworldSpiderNova, disc.level, disc);\r\n        }\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 100, app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.overworldSpiderNova, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 100, disc.y, app_enemies_snake__WEBPACK_IMPORTED_MODULE_13__.snake, disc.level, disc);\r\n        }\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 100, disc.y, app_enemies_sniper__WEBPACK_IMPORTED_MODULE_14__.sniper, disc.level, disc);\r\n        }\r\n        return;\r\n    }\r\n    if (disc.name === 'Swamp') {\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_dragon__WEBPACK_IMPORTED_MODULE_6__.swampDragon, disc.level, disc);\r\n        }\r\n        else if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_11__.greatSlime, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.5) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 100, disc.y, app_enemies_swampThing__WEBPACK_IMPORTED_MODULE_16__.swampThing, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 100, disc.y, app_enemies_snake__WEBPACK_IMPORTED_MODULE_13__.snake, disc.level, disc);\r\n        }\r\n        return;\r\n    }\r\n    if (disc.name === 'Foothills') {\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for centipede\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_ent__WEBPACK_IMPORTED_MODULE_8__.ent, disc.level, disc);\r\n        }\r\n        else if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for trebuchet\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_18__.turret, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for ronin\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 50, disc.y, app_enemies_bandit__WEBPACK_IMPORTED_MODULE_1__.bandit, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for ronin\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 50, disc.y, app_enemies_bandit__WEBPACK_IMPORTED_MODULE_1__.bandit, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 50, app_enemies_wolf__WEBPACK_IMPORTED_MODULE_20__.wolf, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 50, app_enemies_wolf__WEBPACK_IMPORTED_MODULE_20__.wolf, disc.level, disc);\r\n        }\r\n    }\r\n    if (disc.name === 'Mountains') {\r\n        if (disc.radius >= 300 && randomizer.generateAndMutate() < 1) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 100, app_enemies_tornado__WEBPACK_IMPORTED_MODULE_17__.tornado, disc.level, disc);\r\n        }\r\n        else if (disc.radius >= 300 && randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for Golem\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_18__.turret, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for naga priest\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 50, disc.y, app_enemies_squid__WEBPACK_IMPORTED_MODULE_15__.squid, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for naga priest\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 50, disc.y, app_enemies_squid__WEBPACK_IMPORTED_MODULE_15__.squid, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for naga wizard\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 50, app_enemies_sniper__WEBPACK_IMPORTED_MODULE_14__.sniper, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for naga wizard\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 50, app_enemies_sniper__WEBPACK_IMPORTED_MODULE_14__.sniper, disc.level, disc);\r\n        }\r\n    }\r\n    if (disc.name === 'Frozen Peaks') {\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for Giant Snowflake\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_ent__WEBPACK_IMPORTED_MODULE_8__.ent, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for Frost Dragon\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_dragon__WEBPACK_IMPORTED_MODULE_6__.swampDragon, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for Yeti\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 50, disc.y, app_enemies_crab__WEBPACK_IMPORTED_MODULE_5__.crab, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for Yeti\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 50, disc.y, app_enemies_crab__WEBPACK_IMPORTED_MODULE_5__.crab, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for White Wolf\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 50, app_enemies_wolf__WEBPACK_IMPORTED_MODULE_20__.wolf, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for White Wolf\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 50, app_enemies_wolf__WEBPACK_IMPORTED_MODULE_20__.wolf, disc.level, disc);\r\n        }\r\n    }\r\n    if (disc.name === 'Descent') {\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for Naga Mystic\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_lord__WEBPACK_IMPORTED_MODULE_9__.lord, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for Mimic\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_clam__WEBPACK_IMPORTED_MODULE_4__.clam, disc.level + 1, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for Naga Priest\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 50, disc.y, app_enemies_scorpion__WEBPACK_IMPORTED_MODULE_12__.scorpion, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for Naga Wizard\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 50, disc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_11__.slime, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for vampire bat\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 50, app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__.bat, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for vampire bat\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 50, app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__.bat, disc.level, disc);\r\n        }\r\n    }\r\n    if (disc.name === 'Badlands') {\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for Necromancer\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_lord__WEBPACK_IMPORTED_MODULE_9__.lord, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for Trebuchet\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_ent__WEBPACK_IMPORTED_MODULE_8__.ent, disc.level + 1, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 50, disc.y, app_enemies_swampThing__WEBPACK_IMPORTED_MODULE_16__.swampThing, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 50, disc.y, app_enemies_swampThing__WEBPACK_IMPORTED_MODULE_16__.swampThing, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 50, app_enemies_sniper__WEBPACK_IMPORTED_MODULE_14__.sniper, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 50, app_enemies_sniper__WEBPACK_IMPORTED_MODULE_14__.sniper, disc.level, disc);\r\n        }\r\n    }\r\n    if (disc.name === 'Inferno') {\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for Flame Cyclone\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_tornado__WEBPACK_IMPORTED_MODULE_17__.tornado, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            // PLACEHOLDER for Flame Dragon\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_dragon__WEBPACK_IMPORTED_MODULE_6__.swampDragon, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for Magma Thing\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 50, disc.y, app_enemies_swampThing__WEBPACK_IMPORTED_MODULE_16__.swampThing, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for Magma Thing\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 50, disc.y, app_enemies_swampThing__WEBPACK_IMPORTED_MODULE_16__.swampThing, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for ???\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 50, app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.overworldSpiderNova, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            // PLACEHOLDER for ???\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 50, app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.overworldSpiderNova, disc.level, disc);\r\n        }\r\n    }\r\n    if (disc.name === 'Abyss') {\r\n        if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_ent__WEBPACK_IMPORTED_MODULE_8__.ent, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_urchin__WEBPACK_IMPORTED_MODULE_19__.urchin, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_18__.turret, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_clam__WEBPACK_IMPORTED_MODULE_4__.clam, disc.level, disc);\r\n        }\r\n        else if (randomizer.generateAndMutate() < 0.2) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_3__.chest, disc.level + 1, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x - 50, disc.y, app_enemies_scorpion__WEBPACK_IMPORTED_MODULE_12__.scorpion, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x + 50, disc.y, app_enemies_slime__WEBPACK_IMPORTED_MODULE_11__.slime, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y + 50, app_enemies_bat__WEBPACK_IMPORTED_MODULE_2__.bat, disc.level, disc);\r\n        }\r\n        if (randomizer.generateAndMutate() < 0.3) {\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, disc.x, disc.y - 50, app_bosses_spider__WEBPACK_IMPORTED_MODULE_0__.overworldSpiderNova, disc.level, disc);\r\n        }\r\n    }\r\n}\r\nconst bonusConnectionChance = 0.25;\r\nfunction cellHasNorthExit(x, y, worldRandomizer) {\r\n    const modulus = Math.min(y + 2, 6);\r\n    const rowRandomizer = worldRandomizer.addSeed((y + 1) * 1357);\r\n    const offset = (rowRandomizer.addSeed(934322).random() * modulus) | 0;\r\n    if ((x + offset) % modulus === 0) {\r\n        return true;\r\n    }\r\n    return rowRandomizer.addSeed(x * 37).random() <= bonusConnectionChance;\r\n}\r\nconst debugDiscs = false;\r\nconst platformSizes = [200, 350, 350, 350, 500, 500];\r\nfunction createWorldCell(state, { x, y }) {\r\n    const discs = [];\r\n    const worldRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_26__[\"default\"].seed(state.worldSeed);\r\n    const hasNorthExit = cellHasNorthExit(x, y, worldRandomizer);\r\n    const hasSouthExit = y > 0 && cellHasNorthExit(x, y - 1, worldRandomizer);\r\n    const hasEventDisc = worldRandomizer.addSeed(y * 36327).addSeed(x * 37).random() <= 0.1;\r\n    const cellRandomizer = worldRandomizer.addSeed(x * 37).addSeed(y * 29);\r\n    const level = getCellLevel(cellRandomizer, y);\r\n    const cellRadius = window.CELL_SIZE / 2;\r\n    const biome = getBiome(y, cellRandomizer);\r\n    const c = { x: window.CELL_SIZE * (x + 0.5), y: -window.CELL_SIZE * (y + 0.5) };\r\n    let discRandomizer = cellRandomizer.addSeed(79);\r\n    const goalDiscs = [];\r\n    const extraDiscs = [];\r\n    const eastDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.createDisc)({\r\n        level,\r\n        ...biome,\r\n        x: c.x + cellRadius,\r\n        y: c.y,\r\n        radius: 400,\r\n    });\r\n    extraDiscs.push(eastDisc);\r\n    goalDiscs.push(eastDisc);\r\n    const westDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.createDisc)({\r\n        level,\r\n        ...biome,\r\n        x: c.x - cellRadius,\r\n        y: c.y,\r\n        radius: 400,\r\n    });\r\n    extraDiscs.push(westDisc);\r\n    goalDiscs.push(westDisc);\r\n    let northDisc;\r\n    if (hasNorthExit) {\r\n        goalDiscs.push(northDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.createDisc)({\r\n            level,\r\n            ...biome,\r\n            ...(debugDiscs ? { color: 'blue' } : {}),\r\n            x: c.x,\r\n            y: c.y - cellRadius,\r\n            radius: 400,\r\n        }));\r\n        extraDiscs.push(northDisc);\r\n    }\r\n    if (hasSouthExit) {\r\n        const southDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.createDisc)({\r\n            level,\r\n            ...biome,\r\n            x: c.x,\r\n            y: c.y + cellRadius,\r\n            radius: 400,\r\n        });\r\n        goalDiscs.push(southDisc);\r\n        extraDiscs.push(southDisc);\r\n    }\r\n    let eventDisc;\r\n    if (hasEventDisc) {\r\n        discs.push(eventDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.createDisc)({\r\n            level,\r\n            ...biome,\r\n            x: c.x,\r\n            y: c.y,\r\n            name: 'Thriving Reef',\r\n            color: '#28F',\r\n            centerColor: '#4CF',\r\n            topEdgeColor: '#12D',\r\n            bottomEdgeColor: '#00A',\r\n            radius: 600,\r\n        }));\r\n        (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_22__.createEnemy)(state, eventDisc.x, eventDisc.y, app_events_thrivingReef__WEBPACK_IMPORTED_MODULE_7__.thrivingReef, eventDisc.level + 1, eventDisc);\r\n    }\r\n    else {\r\n        discs.push((0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.createDisc)({\r\n            level,\r\n            ...biome,\r\n            x: c.x + (discRandomizer.generateAndMutate() - 0.5) * window.CELL_SIZE / 10,\r\n            y: c.y + (discRandomizer.generateAndMutate() - 0.5) * window.CELL_SIZE / 10,\r\n            radius: discRandomizer.element(platformSizes),\r\n        }));\r\n    }\r\n    let i = 0;\r\n    for (i = 0; i < 200 && (goalDiscs.length || i < 20); i++) {\r\n        /*const theta = 2 * Math.PI * discRandomizer.generateAndMutate();\r\n        const newDisc: Disc = createDisc({\r\n            level,\r\n            ...biome,\r\n            x: c.x + cellRadius * Math.cos(theta),\r\n            y: c.y + cellRadius * Math.sin(theta),\r\n            radius: discRandomizer.element(platformSizes),\r\n        });*/\r\n        const newDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.createDisc)({\r\n            level,\r\n            ...biome,\r\n            x: c.x + cellRadius * (1 - 2 * discRandomizer.generateAndMutate()),\r\n            y: c.y + cellRadius * (1 - 2 * discRandomizer.generateAndMutate()),\r\n            radius: discRandomizer.element(platformSizes),\r\n        });\r\n        // Attempt to adjust the position of the disc until it satisfies placement criteria.\r\n        let positionIsGood = false;\r\n        for (let j = 0; j < 10 && !positionIsGood && newDisc.radius >= 150; j++) {\r\n            positionIsGood = adjustDiscPosition(discs, extraDiscs, newDisc, 24, 80, discRandomizer.range(24, 80));\r\n            if (!positionIsGood\r\n                || Math.abs(newDisc.x - c.x) >= (cellRadius - newDisc.radius + 32)\r\n                || Math.abs(newDisc.y - c.y) >= (cellRadius - newDisc.radius + 32)) {\r\n                newDisc.radius -= 20;\r\n            }\r\n        }\r\n        // Discard the disc if the placement is still bad.\r\n        if (!positionIsGood\r\n            || Math.abs(newDisc.x - c.x) >= (cellRadius - newDisc.radius + 32)\r\n            || Math.abs(newDisc.y - c.y) >= (cellRadius - newDisc.radius + 32)) {\r\n            continue;\r\n        }\r\n        for (let j = 0; j < goalDiscs.length; j++) {\r\n            const goalDisc = goalDiscs[j];\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_23__.getTargetVector)(goalDisc, newDisc);\r\n            if (distance2 <= (goalDisc.radius + newDisc.radius - 16) ** 2) {\r\n                goalDiscs.splice(j--, 1);\r\n            }\r\n        }\r\n        addOverworldEnemiesToDisc(state, discRandomizer, newDisc);\r\n        discs.push(newDisc);\r\n    }\r\n    for (const remainingGoal of goalDiscs) {\r\n        const closestDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.findClosestDiscToDisc)(remainingGoal, discs);\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_23__.getTargetVector)(remainingGoal, closestDisc);\r\n        const mag = Math.sqrt(distance2);\r\n        const dx = x / mag, dy = y / mag;\r\n        const p = (remainingGoal.radius + (mag - remainingGoal.radius - closestDisc.radius) / 2);\r\n        discs.push((0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.createDisc)({\r\n            level,\r\n            ...biome,\r\n            ...(debugDiscs ? { color: 'red' } : {}),\r\n            x: remainingGoal.x + dx * p,\r\n            y: remainingGoal.y + dy * p,\r\n            radius: (mag - remainingGoal.radius - closestDisc.radius + 48),\r\n        }));\r\n    }\r\n    // The west+north discs are part of this cell, but the east+south discs are not.\r\n    discs.push(westDisc);\r\n    if (northDisc) {\r\n        discs.push(northDisc);\r\n    }\r\n    (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.linkDiscs)(discs);\r\n    return {\r\n        level,\r\n        x, y,\r\n        discs,\r\n    };\r\n}\r\nfunction adjustDiscPosition(discs, otherDiscs, disc, minOverlap, maxOverlap, targetOverlap) {\r\n    (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.projectDiscToClosestDisc)(discs, disc, targetOverlap);\r\n    const closestDisc = (0,app_utils_disc__WEBPACK_IMPORTED_MODULE_21__.findClosestDiscToDisc)(disc, [...discs, ...otherDiscs]);\r\n    // Return false if the closest disc does has more overlap than `maxOverlap`.\r\n    return (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_23__.getTargetVector)(disc, closestDisc).distance2 >= (disc.radius + closestDisc.radius - maxOverlap) ** 2;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/overworld.ts?");

/***/ }),

/***/ "./app/utils/rollWithMissBonus.ts":
/*!****************************************!*\
  !*** ./app/utils/rollWithMissBonus.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rollWithMissBonus: () => (/* binding */ rollWithMissBonus)\n/* harmony export */ });\nfunction rollWithMissBonus(state, key, baseChance) {\r\n    var _a;\r\n    if (baseChance <= 0) {\r\n        return false;\r\n    }\r\n    const missBonus = ((_a = state.missedRolls[key]) !== null && _a !== void 0 ? _a : 0);\r\n    const roll = Math.random();\r\n    // console.log('rolled', roll, ' against ', baseChance, '+', missBonus, ' for ', key);\r\n    if (roll < baseChance) {\r\n        return true;\r\n    }\r\n    if (roll < baseChance + missBonus) {\r\n        state.missedRolls[key] = Math.max(0, missBonus - (roll - baseChance));\r\n        return true;\r\n    }\r\n    state.missedRolls[key] = missBonus + baseChance / 10;\r\n    return false;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/rollWithMissBonus.ts?");

/***/ }),

/***/ "./app/utils/userInput.ts":
/*!********************************!*\
  !*** ./app/utils/userInput.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ANALOG_THRESHOLD: () => (/* binding */ ANALOG_THRESHOLD),\n/* harmony export */   KEY: () => (/* binding */ KEY),\n/* harmony export */   addKeyboardListeners: () => (/* binding */ addKeyboardListeners),\n/* harmony export */   clearKeyboardState: () => (/* binding */ clearKeyboardState),\n/* harmony export */   getMovementDeltas: () => (/* binding */ getMovementDeltas),\n/* harmony export */   getRightAnalogDeltas: () => (/* binding */ getRightAnalogDeltas),\n/* harmony export */   isGameKeyDown: () => (/* binding */ isGameKeyDown),\n/* harmony export */   isKeyboardKeyDown: () => (/* binding */ isKeyboardKeyDown),\n/* harmony export */   updateKeyboardState: () => (/* binding */ updateKeyboardState),\n/* harmony export */   wasGameKeyPressed: () => (/* binding */ wasGameKeyPressed),\n/* harmony export */   wasGameKeyPressedAndReleased: () => (/* binding */ wasGameKeyPressedAndReleased)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* global navigator */\r\n\r\nconst KEY = {\r\n    ESCAPE: 27,\r\n    LEFT: 37,\r\n    RIGHT: 39,\r\n    UP: 38,\r\n    DOWN: 40,\r\n    SPACE: 32,\r\n    SHIFT: 16,\r\n    ENTER: 13,\r\n    BACK_SPACE: 8,\r\n    COMMAND: 91,\r\n    CONTROL: 17,\r\n    LEFT_BRACKET: 219,\r\n    BACK_SLASH: 220,\r\n    RIGHT_BRACKET: 221,\r\n    A: 'A'.charCodeAt(0),\r\n    B: 'B'.charCodeAt(0),\r\n    C: 'C'.charCodeAt(0),\r\n    D: 'D'.charCodeAt(0),\r\n    E: 'E'.charCodeAt(0),\r\n    F: 'F'.charCodeAt(0),\r\n    G: 'G'.charCodeAt(0),\r\n    H: 'H'.charCodeAt(0),\r\n    I: 'I'.charCodeAt(0),\r\n    J: 'J'.charCodeAt(0),\r\n    K: 'K'.charCodeAt(0),\r\n    L: 'L'.charCodeAt(0),\r\n    M: 'M'.charCodeAt(0),\r\n    O: 'O'.charCodeAt(0),\r\n    P: 'P'.charCodeAt(0),\r\n    Q: 'Q'.charCodeAt(0),\r\n    R: 'R'.charCodeAt(0),\r\n    S: 'S'.charCodeAt(0),\r\n    T: 'T'.charCodeAt(0),\r\n    U: 'U'.charCodeAt(0),\r\n    V: 'V'.charCodeAt(0),\r\n    W: 'W'.charCodeAt(0),\r\n    X: 'X'.charCodeAt(0),\r\n    Y: 'Y'.charCodeAt(0),\r\n    Z: 'Z'.charCodeAt(0),\r\n};\r\nconst KEYBOARD_MAPPINGS = {\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MENU]: [KEY.ENTER],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: [KEY.UP, KEY.W],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: [KEY.DOWN, KEY.S],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: [KEY.LEFT, KEY.A],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: [KEY.RIGHT, KEY.D],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE]: [KEY.F],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL]: [KEY.X],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.POTION]: [KEY.SPACE],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MUTE]: [KEY.M],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.GUARD_SKILL]: [KEY.SHIFT, KEY.C, KEY.V, KEY.B],\r\n};\r\n// Under this threshold, the analog buttons are considered \"released\" for the sake of\r\n// actions that are only taken once per button push (like moving a menu cursor).\r\nconst ANALOG_THRESHOLD = 0.3;\r\n// This mapping assumes a canonical gamepad setup as seen in:\r\n// https://w3c.github.io/gamepad/#remapping\r\n// Which seems to work well with my xbox 360 controller.\r\n// I based this code on examples from:\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API\r\n// Easy to find mappings at: http://html5gamepad.com/\r\nconst GAME_PAD_MAPPINGS = {\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MENU]: 9,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: 12,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: 13,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: 14,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: 15,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE]: [\r\n        0,\r\n        1, // B (right button)\r\n    ],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL]: 3,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.POTION]: 4,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SHOOT]: 5,\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SPECIAL_ATTACK]: 6, // L Back Bumper\r\n    // 2, // X (left button)\r\n    // 7, // R Back bumper\r\n    // 8, // BACK\r\n    // 10 ??\r\n    // 11 ??\r\n};\r\nconst LEFT_ANALOG_Y_AXIS = 1;\r\nconst LEFT_ANALOG_X_AXIS = 0;\r\nconst RIGHT_ANALOG_Y_AXIS = 3;\r\nconst RIGHT_ANALOG_X_AXIS = 2;\r\n// These two are currently unused, but would be used for aiming instead of the mouse.\r\n//const RIGHT_ANALOG_Y_AXIS = 3; // eslint-disable-line no-unused-vars\r\n//const RIGHT_ANALOG_X_AXIS = 2; // eslint-disable-line no-unused-vars\r\nconst GAME_PAD_AXIS_MAPPINGS = {\r\n    // Map the negative y axis of the left stick to the up key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: [LEFT_ANALOG_Y_AXIS, -1],\r\n    // Map the positive y axis of the left stick to the down key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: [LEFT_ANALOG_Y_AXIS, 1],\r\n    // Map the negative x axis of the left stick to the up key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: [LEFT_ANALOG_X_AXIS, -1],\r\n    // Map the positive x axis of the left stick to the down key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: [LEFT_ANALOG_X_AXIS, 1],\r\n    // Map the negative y axis of the right stick to the aim up key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_UP]: [RIGHT_ANALOG_Y_AXIS, -1],\r\n    // Map the positive y axis of the right stick to the aim down key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_DOWN]: [RIGHT_ANALOG_Y_AXIS, 1],\r\n    // Map the negative x axis of the right stick to the aim up key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_LEFT]: [RIGHT_ANALOG_X_AXIS, -1],\r\n    // Map the positive x axis of the right stick to the aim down key.\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_RIGHT]: [RIGHT_ANALOG_X_AXIS, 1],\r\n};\r\n// Apparently, depending on the button type, either button.pressed or button == 1.0 indicates the button is pressed.\r\nfunction buttonIsPressed(button) {\r\n    if (typeof (button) == \"object\")\r\n        return button.pressed;\r\n    return button == 1.0;\r\n}\r\nconst keysDown = [];\r\nlet lastInput;\r\nfunction isKeyboardKeyDown(keyCode) {\r\n    if (keysDown[keyCode]) {\r\n        lastInput = 'keyboard';\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction isGamepadGamekeyPressed(gameKey) {\r\n    // If a mapping exists for the current key code to a gamepad button,\r\n    // check if that gamepad button is pressed.\r\n    const buttonIndexArrayOrNumber = GAME_PAD_MAPPINGS[gameKey], axisIndex = GAME_PAD_AXIS_MAPPINGS[gameKey];\r\n    const buttonIndexArray = Array.isArray(buttonIndexArrayOrNumber) ? buttonIndexArrayOrNumber : [buttonIndexArrayOrNumber];\r\n    for (const buttonIndex of buttonIndexArray) {\r\n        if (typeof (buttonIndex) !== 'undefined' || typeof (axisIndex) !== 'undefined') {\r\n            // There can be multiple game pads connected. For now, let's just check all of them for the button.\r\n            const gamepads = navigator.getGamepads();\r\n            for (const gamepad of gamepads) {\r\n                if (!gamepad)\r\n                    continue;\r\n                let value = 0;\r\n                if (typeof (buttonIndex) !== 'undefined' && buttonIsPressed(gamepad.buttons[buttonIndex])) {\r\n                    value = 1;\r\n                }\r\n                else if (typeof (axisIndex) !== 'undefined' && gamepad.axes[axisIndex[0]] * axisIndex[1] > 0) {\r\n                    value = gamepad.axes[axisIndex[0]] * axisIndex[1];\r\n                }\r\n                if (value) {\r\n                    if (value >= ANALOG_THRESHOLD) {\r\n                        lastInput = 'gamepad';\r\n                    }\r\n                    return value;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\nfunction addKeyboardListeners() {\r\n    addEventListener('blur', (event) => {\r\n        for (let i = 0; i < keysDown.length; i++) {\r\n            keysDown[i] = 0;\r\n        }\r\n    });\r\n    document.addEventListener('keyup', function (event) {\r\n        const keyCode = event.which;\r\n        keysDown[keyCode] = 0;\r\n    });\r\n    document.addEventListener('keydown', function (event) {\r\n        if (event.repeat) {\r\n            return;\r\n        }\r\n        // Don't process keys if an input is targeted, otherwise we prevent typing in\r\n        // the input.\r\n        if (event.target.closest('input')\r\n            || event.target.closest('textarea')\r\n            || event.target.closest('select')) {\r\n            return;\r\n        }\r\n        const commandIsDown = (keysDown[KEY.CONTROL] || keysDown[KEY.COMMAND]);\r\n        const keyCode = event.which;\r\n        //console.log(keyCode);\r\n        // Don't override the refresh page command.\r\n        if (keyCode === KEY.R && commandIsDown) {\r\n            return;\r\n        }\r\n        keysDown[keyCode] = 1;\r\n    });\r\n}\r\nfunction updateKeyboardState(state) {\r\n    const previousGameKeysDown = state.keyboard.gameKeysDown;\r\n    // This set is persisted until a new set of keys is pressed.\r\n    let mostRecentKeysPressed = state.keyboard.mostRecentKeysPressed;\r\n    const gameKeyValues = [];\r\n    const gameKeysDown = new Set();\r\n    const gameKeysPressed = new Set();\r\n    const gameKeysReleased = new Set();\r\n    /*for (const gameKey of GAME_PAD_AXIS_MAPPINGS) {\r\n\r\n    }*/\r\n    for (let gameKey of Object.values(app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY)) {\r\n        gameKeyValues[gameKey] = 0;\r\n        for (const keyboardCode of (KEYBOARD_MAPPINGS[gameKey] || [])) {\r\n            gameKeyValues[gameKey] = isKeyboardKeyDown(keyboardCode);\r\n            if (gameKeyValues[gameKey]) {\r\n                break;\r\n            }\r\n        }\r\n        if (!gameKeyValues[gameKey]) {\r\n            gameKeyValues[gameKey] = isGamepadGamekeyPressed(gameKey);\r\n        }\r\n        if (gameKeyValues[gameKey] >= ANALOG_THRESHOLD) {\r\n            gameKeysDown.add(gameKey);\r\n        }\r\n    }\r\n    for (const oldKeyDown of [...previousGameKeysDown]) {\r\n        if (!gameKeysDown.has(oldKeyDown)) {\r\n            gameKeysReleased.add(oldKeyDown);\r\n        }\r\n    }\r\n    for (const newKeyDown of [...gameKeysDown]) {\r\n        if (!previousGameKeysDown.has(newKeyDown)) {\r\n            gameKeysPressed.add(newKeyDown);\r\n        }\r\n    }\r\n    if (gameKeysPressed.size > 0) {\r\n        mostRecentKeysPressed = gameKeysPressed;\r\n    }\r\n    state.keyboard = { gameKeyValues, gameKeysDown, gameKeysPressed, gameKeysReleased, mostRecentKeysPressed };\r\n    if (lastInput === 'gamepad') {\r\n        state.isUsingKeyboard = false;\r\n        state.isUsingXbox = true;\r\n    }\r\n    else if (lastInput === 'keyboard') {\r\n        state.isUsingKeyboard = true;\r\n        state.isUsingXbox = false;\r\n    }\r\n}\r\nfunction clearKeyboardState(state) {\r\n    const gameKeyValues = [];\r\n    for (let gameKey of Object.values(app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY)) {\r\n        gameKeyValues[gameKey] = 0;\r\n    }\r\n    state.keyboard = {\r\n        gameKeyValues,\r\n        gameKeysDown: new Set(),\r\n        gameKeysPressed: new Set(),\r\n        gameKeysReleased: new Set(),\r\n        mostRecentKeysPressed: new Set(),\r\n    };\r\n}\r\nfunction wasGameKeyPressed(state, keyCode) {\r\n    return state.keyboard.gameKeysPressed.has(keyCode);\r\n}\r\n// Only returns true if a key was pressed and released without any other keys having been pressed in between.\r\n// Specifically this is used to determined whether to switch clones, which should only happen if the user presses\r\n// the clone tool button without pressing any other buttons before releasing it. Note that it is okay if they\r\n// continue holding buttons that were already down when pressing the clone button.\r\nfunction wasGameKeyPressedAndReleased(state, keyCode) {\r\n    return state.keyboard.mostRecentKeysPressed.has(keyCode) && state.keyboard.gameKeysReleased.has(keyCode);\r\n}\r\nfunction isGameKeyDown(state, keyCode) {\r\n    return state.keyboard.gameKeysDown.has(keyCode);\r\n}\r\nfunction getMovementDeltas(state) {\r\n    const { gameKeyValues } = state.keyboard;\r\n    let dy = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP];\r\n    if (Math.abs(dy) < ANALOG_THRESHOLD)\r\n        dy = 0;\r\n    let dx = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT];\r\n    if (Math.abs(dx) < ANALOG_THRESHOLD)\r\n        dx = 0;\r\n    if (isNaN(dx) || isNaN(dy)) {\r\n        debugger;\r\n    }\r\n    return [dx, dy];\r\n}\r\nfunction getRightAnalogDeltas(state) {\r\n    const { gameKeyValues } = state.keyboard;\r\n    let dy = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_DOWN] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_UP];\r\n    let dx = gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_RIGHT] - gameKeyValues[app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.AIM_LEFT];\r\n    if (Math.abs(dx) < ANALOG_THRESHOLD && Math.abs(dy) < ANALOG_THRESHOLD) {\r\n        return [0, 0];\r\n    }\r\n    if (isNaN(dx) || isNaN(dy)) {\r\n        debugger;\r\n    }\r\n    return [dx, dy];\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/userInput.ts?");

/***/ }),

/***/ "./app/weapons.ts":
/*!************************!*\
  !*** ./app/weapons.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allWeapons: () => (/* binding */ allWeapons),\n/* harmony export */   basicBullet: () => (/* binding */ basicBullet),\n/* harmony export */   bows: () => (/* binding */ bows),\n/* harmony export */   daggers: () => (/* binding */ daggers),\n/* harmony export */   katanas: () => (/* binding */ katanas),\n/* harmony export */   morningStars: () => (/* binding */ morningStars),\n/* harmony export */   swords: () => (/* binding */ swords),\n/* harmony export */   wands: () => (/* binding */ wands),\n/* harmony export */   weaponTypeLabels: () => (/* binding */ weaponTypeLabels),\n/* harmony export */   weaponTypes: () => (/* binding */ weaponTypes),\n/* harmony export */   weaponsByType: () => (/* binding */ weaponsByType)\n/* harmony export */ });\n/* harmony import */ var app_utils_bullet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/bullet */ \"./app/utils/bullet.ts\");\n/* harmony import */ var app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/coreCalculations */ \"./app/utils/coreCalculations.ts\");\n\r\n\r\nfunction getArmorShred(state, chargeLevel) {\r\n    return state.hero.armorShredEffect * (0.01 + 0.02 * chargeLevel);\r\n}\r\nfunction getChargeDamage(state, chargeLevel) {\r\n    if (chargeLevel <= 1) {\r\n        return 1;\r\n    }\r\n    return chargeLevel + state.hero.chargeDamage;\r\n}\r\nfunction getNormalizedTargetVector(source, target) {\r\n    const dx = target.x - source.x, dy = target.y - source.y;\r\n    const mag = Math.sqrt(dx * dx + dy * dy);\r\n    if (mag) {\r\n        return { x: dx / mag, y: dy / mag };\r\n    }\r\n    return { x: 1, y: 0 };\r\n}\r\nfunction basicBullet(state, source, weapon, target) {\r\n    const { x, y } = getNormalizedTargetVector(source, target);\r\n    const critDamage = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.rollForCritDamage)(state);\r\n    return {\r\n        time: 0,\r\n        baseX: source.x,\r\n        baseY: source.y,\r\n        x: source.x,\r\n        y: source.y,\r\n        radius: weapon.radius * (1.2 ** (source.attackChargeLevel - 1)),\r\n        vx: weapon.speed * x,\r\n        vy: weapon.speed * y,\r\n        damage: Math.ceil(weapon.damage * getChargeDamage(state, source.attackChargeLevel) * source.damage * critDamage),\r\n        chargeGain: 0.1,\r\n        isCrit: critDamage > 1,\r\n        isEnemyPiercing: (source.attackChargeLevel >= 2),\r\n        source,\r\n        duration: 1000 * weapon.range / weapon.speed,\r\n        update: app_utils_bullet__WEBPACK_IMPORTED_MODULE_0__.updateSimpleBullet,\r\n        hitTargets: new Set(),\r\n        armorShred: getArmorShred(state, source.attackChargeLevel),\r\n        warningTime: 0,\r\n    };\r\n}\r\nconst bowShots = [\r\n    {\r\n        generateBullet(state, source, weapon, target) {\r\n            const speed = weapon.speed * (0.8 + 0.2 * (source.attackChargeLevel));\r\n            const critDamage = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.rollForCritDamage)(state, 0.1 * (source.attackChargeLevel - 1));\r\n            const range = weapon.range + 50 * (source.attackChargeLevel - 1);\r\n            return {\r\n                ...basicBullet(state, source, weapon, target),\r\n                duration: 1000 * range / speed,\r\n                radius: weapon.radius + (source.attackChargeLevel - 1),\r\n                vx: speed * Math.cos(source.theta),\r\n                vy: speed * Math.sin(source.theta),\r\n                damage: Math.ceil(weapon.damage * getChargeDamage(state, source.attackChargeLevel) * source.damage * critDamage),\r\n                // Bow gains charge very fast relative to its rate of fire.\r\n                chargeGain: 0.4,\r\n                isCrit: critDamage > 1,\r\n                isEnemyPiercing: true,\r\n            };\r\n        },\r\n    }\r\n];\r\nfunction createBow(level, name) {\r\n    const attacksPerSecond = window.BASE_ATTACKS_PER_SECOND * 0.8;\r\n    return {\r\n        type: 'weapon',\r\n        weaponType: 'bow',\r\n        level: Math.floor(level),\r\n        name,\r\n        getShots: () => bowShots,\r\n        getAttacksPerSecond: () => attacksPerSecond,\r\n        critChance: 0.2,\r\n        critDamage: 0.5,\r\n        damage: Math.ceil(0.6 * (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.getBaseWeaponDpsForLevel)(level) / attacksPerSecond),\r\n        damageOverTimeStackSize: 5,\r\n        chargeLevel: 3,\r\n        range: 400,\r\n        speed: 1.5 * window.BASE_BULLET_SPEED,\r\n        radius: window.BASE_BULLET_RADIUS,\r\n        duration: window.BASE_BULLET_DURATION,\r\n        enchantmentSlots: [],\r\n        bonusEnchantmentSlots: [],\r\n    };\r\n}\r\nconst bows = [\r\n    createBow(1, 'Primitive Bow'),\r\n    createBow(3, 'Short Bow'),\r\n    createBow(5, 'Recurve Bow'),\r\n    createBow(8, 'Long Bow'),\r\n    createBow(11, 'Crossbow'),\r\n    createBow(15, 'Composite Bow'),\r\n    createBow(21, 'Repeating Crossbow'),\r\n    createBow(32, 'Recurve Crossbow'),\r\n    createBow(44, 'Arbalest'),\r\n    createBow(57, 'Compound Bow'),\r\n    createBow(71, 'Compound Crossbow'),\r\n    createBow(86, 'Adamantine Crossbow'),\r\n    createBow(95, 'Dragonbone Greabow'),\r\n];\r\nconst swordShots = [\r\n    {\r\n        generateBullet(state, source, weapon, target) {\r\n            return {\r\n                ...basicBullet(state, source, weapon, target),\r\n            };\r\n        },\r\n    }\r\n];\r\nfunction createSword(level, name) {\r\n    return {\r\n        type: 'weapon',\r\n        weaponType: 'sword',\r\n        level,\r\n        name,\r\n        getShots: () => swordShots,\r\n        getAttacksPerSecond: () => window.BASE_ATTACKS_PER_SECOND,\r\n        critChance: 0.05,\r\n        critDamage: 0.5,\r\n        damage: Math.ceil((0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.getBaseWeaponDpsForLevel)(level) / window.BASE_ATTACKS_PER_SECOND),\r\n        damageOverTimeStackSize: 5,\r\n        chargeLevel: 2,\r\n        range: 350,\r\n        speed: window.BASE_BULLET_SPEED,\r\n        radius: Math.ceil(1.2 * window.BASE_BULLET_RADIUS),\r\n        duration: window.BASE_BULLET_DURATION,\r\n        enchantmentSlots: [],\r\n        bonusEnchantmentSlots: [],\r\n    };\r\n}\r\nconst swords = [\r\n    createSword(1, 'Gladius'),\r\n    createSword(2, 'Short Sword'),\r\n    createSword(5, 'Falchion'),\r\n    createSword(8, 'Scimitar'),\r\n    createSword(12, 'Wakizashi'),\r\n    createSword(17, 'Longsword'),\r\n    createSword(27, 'Estoic'),\r\n    createSword(38, 'Broadsword'),\r\n    createSword(50, 'Bastardsword'),\r\n    createSword(63, 'Meteoric Saber'),\r\n    createSword(77, 'Runed Saber'),\r\n    createSword(92, 'Etched Dragon Horn'),\r\n    createSword(95, 'Precursor Blade'),\r\n];\r\nfunction generateDaggerShot(timingOffset, thetaOffset) {\r\n    return {\r\n        timingOffset,\r\n        generateBullet(state, source, weapon, target) {\r\n            const critDamage = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.rollForCritDamage)(state);\r\n            return {\r\n                ...basicBullet(state, source, weapon, target),\r\n                vx: weapon.speed * Math.cos(source.theta + thetaOffset / source.attackChargeLevel / source.attackChargeLevel),\r\n                vy: weapon.speed * Math.sin(source.theta + thetaOffset / source.attackChargeLevel / source.attackChargeLevel),\r\n                damage: Math.ceil(weapon.damage * getChargeDamage(state, source.attackChargeLevel) * source.damage * critDamage),\r\n                // Dagger gains charge 40% faster than average if every bullet hits.\r\n                chargeGain: 0.02,\r\n                isCrit: critDamage > 1,\r\n                radius: weapon.radius + (source.attackChargeLevel - 1),\r\n            };\r\n        },\r\n    };\r\n}\r\nconst daggerShots = [\r\n    generateDaggerShot(0 / 7, 0),\r\n    generateDaggerShot(1 / 7, Math.PI / 18),\r\n    generateDaggerShot(2 / 7, -Math.PI / 18),\r\n    generateDaggerShot(3 / 7, 2 * Math.PI / 18),\r\n    generateDaggerShot(4 / 7, -2 * Math.PI / 18),\r\n    generateDaggerShot(5 / 7, 3 * Math.PI / 18),\r\n    generateDaggerShot(6 / 7, -3 * Math.PI / 18),\r\n];\r\nfunction createDagger(level, name) {\r\n    return {\r\n        type: 'weapon',\r\n        weaponType: 'dagger',\r\n        level: Math.floor(level),\r\n        name,\r\n        getShots: () => daggerShots,\r\n        getAttacksPerSecond: () => window.BASE_ATTACKS_PER_SECOND,\r\n        critChance: 0.05,\r\n        critDamage: 0.5,\r\n        damage: Math.ceil(0.3 * (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.getBaseWeaponDpsForLevel)(level) / window.BASE_ATTACKS_PER_SECOND),\r\n        damageOverTimeStackSize: 16,\r\n        chargeLevel: 2,\r\n        range: 250,\r\n        speed: Math.ceil(window.BASE_BULLET_SPEED * 1.2),\r\n        radius: window.BASE_BULLET_RADIUS,\r\n        duration: window.BASE_BULLET_DURATION,\r\n        enchantmentSlots: [],\r\n        bonusEnchantmentSlots: [],\r\n    };\r\n}\r\nconst daggers = [\r\n    createDagger(1.5, 'Pugio'),\r\n    createDagger(3, 'Hewing Knife'),\r\n    createDagger(6, 'Cross-hilt Dagger'),\r\n    createDagger(11, 'Tanto'),\r\n    createDagger(17, 'Stiletto'),\r\n    createDagger(23, 'Steel Dirk'),\r\n    createDagger(34, 'Stainless Dirk'),\r\n    createDagger(46, 'Serrated Dirk'),\r\n    createDagger(59, 'Masterful Dirk'),\r\n    createDagger(73, 'Meteoric Dirk'),\r\n    createDagger(88, 'Runed Dirk'),\r\n    createDagger(95, 'Etched Dragon Fang'),\r\n];\r\nfunction generateKatanaShot(timingOffset, offset) {\r\n    return {\r\n        timingOffset,\r\n        generateBullet(state, source, weapon, target) {\r\n            const speed = weapon.speed * (0.8 + 0.2 * source.attackChargeLevel);\r\n            const critDamage = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.rollForCritDamage)(state);\r\n            const x = source.x + offset * Math.cos(source.theta + Math.PI / 2);\r\n            const y = source.y + offset * Math.sin(source.theta + Math.PI / 2);\r\n            return {\r\n                ...basicBullet(state, source, weapon, target),\r\n                baseX: x,\r\n                baseY: y,\r\n                x,\r\n                y,\r\n                vx: speed * Math.cos(source.theta),\r\n                vy: speed * Math.sin(source.theta),\r\n                damage: Math.ceil(weapon.damage * getChargeDamage(state, source.attackChargeLevel) * source.damage * critDamage),\r\n                // Katana can gain charge almost 2x faster when piercing several enemies.\r\n                chargeGain: 0.05,\r\n                isCrit: critDamage > 1,\r\n                isEnemyPiercing: true,\r\n                radius: weapon.radius + (source.attackChargeLevel - 1),\r\n                duration: 1000 * weapon.range / speed,\r\n            };\r\n        },\r\n    };\r\n}\r\nconst katanaShots = [\r\n    generateKatanaShot(0 / 2, 10),\r\n    generateKatanaShot(1 / 2, -10),\r\n];\r\nfunction createKatana(level, name) {\r\n    return {\r\n        type: 'weapon',\r\n        weaponType: 'katana',\r\n        level: Math.floor(level),\r\n        name,\r\n        getShots: () => katanaShots,\r\n        getAttacksPerSecond: () => window.BASE_ATTACKS_PER_SECOND,\r\n        critChance: 0.05,\r\n        critDamage: 1,\r\n        damage: Math.ceil(0.5 * (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.getBaseWeaponDpsForLevel)(level) / window.BASE_ATTACKS_PER_SECOND),\r\n        damageOverTimeStackSize: 10,\r\n        chargeLevel: 2,\r\n        range: 300,\r\n        speed: window.BASE_BULLET_SPEED,\r\n        radius: window.BASE_BULLET_RADIUS,\r\n        duration: window.BASE_BULLET_DURATION,\r\n        enchantmentSlots: [],\r\n        bonusEnchantmentSlots: [],\r\n    };\r\n}\r\nconst katanas = [\r\n    createKatana(1.5, 'Kitetsu I'),\r\n    createKatana(4, 'Yubashiri'),\r\n    createKatana(7, 'Kitetsu II'),\r\n    createKatana(11, 'Shusui'),\r\n    createKatana(16, 'Ichimonji'),\r\n    createKatana(22, 'Soto Muso'),\r\n    createKatana(30, 'Sukesan'),\r\n    createKatana(40, 'Shigure'),\r\n    createKatana(51, 'Kitetsu III'),\r\n    createKatana(64, 'Ame no Habakiri'),\r\n    createKatana(76, 'Wado Ichimonji'),\r\n    createKatana(90, 'Enma'),\r\n    createKatana(95, 'Masamune'),\r\n];\r\nfunction generateMorningStarShot(timingOffset, theta, attacksPerSecond) {\r\n    return {\r\n        timingOffset,\r\n        generateBullet(state, source, weapon, target) {\r\n            const radius = weapon.radius * (1.2 ** (source.attackChargeLevel - 1)); //weapon.radius + 5 * (source.attackChargeLevel - 1);\r\n            const orbitRadius = weapon.range + radius / 2;\r\n            const critDamage = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.rollForCritDamage)(state);\r\n            const y = source.y, x = source.x + orbitRadius;\r\n            // duration in ms\r\n            const duration = 1000 / attacksPerSecond;\r\n            return {\r\n                ...basicBullet(state, source, weapon, target),\r\n                baseX: x,\r\n                baseY: y,\r\n                x,\r\n                y,\r\n                vx: 0,\r\n                vy: 0,\r\n                orbitRadius,\r\n                theta,\r\n                vTheta: 2 * Math.PI * 1000 / duration,\r\n                damage: Math.ceil(weapon.damage * getChargeDamage(state, source.attackChargeLevel) * source.damage * critDamage),\r\n                chargeGain: 0.1,\r\n                isCrit: critDamage > 1,\r\n                isEnemyPiercing: true,\r\n                radius,\r\n                // Only the first shot is used for normal attacks.\r\n                duration,\r\n                update: app_utils_bullet__WEBPACK_IMPORTED_MODULE_0__.updateCirclingBullet,\r\n            };\r\n        },\r\n    };\r\n}\r\nfunction getMorningStarAttacksPerSecond(state, weapon) {\r\n    const charged = state.hero.attackChargeLevel > 1;\r\n    const baseAttacksPerSecond = 3 * state.hero.attacksPerSecond * (charged ? 1.5 : 1);\r\n    const shotCount = Math.max(1, Math.ceil(baseAttacksPerSecond));\r\n    // This is supposed to just be the attacks per second for the weapon without\r\n    // adding any bonuses, so we need to remove the hero bonus so it doesn't\r\n    // count twice.\r\n    return baseAttacksPerSecond / shotCount / state.hero.attacksPerSecond;\r\n}\r\nfunction getMorningStarShots(state, weapon) {\r\n    const charged = state.hero.attackChargeLevel > 1;\r\n    const baseAttacksPerSecond = 3 * state.hero.attacksPerSecond * (charged ? 1.5 : 1);\r\n    const shotCount = Math.max(1, Math.ceil(baseAttacksPerSecond));\r\n    const actualAttacksPerSecond = baseAttacksPerSecond / shotCount;\r\n    const shots = [];\r\n    for (let i = 0; i < shotCount; i++) {\r\n        shots.push(generateMorningStarShot(0, 2 * Math.PI * i / shotCount, actualAttacksPerSecond));\r\n    }\r\n    return shots;\r\n}\r\nfunction createMorningStar(level, name) {\r\n    const attacksPerSecond = window.BASE_ATTACKS_PER_SECOND / 3;\r\n    return {\r\n        type: 'weapon',\r\n        weaponType: 'morningStar',\r\n        level: Math.floor(level),\r\n        name,\r\n        getShots: getMorningStarShots,\r\n        getAttacksPerSecond: getMorningStarAttacksPerSecond,\r\n        critChance: 0.05,\r\n        critDamage: 0.5,\r\n        // This results in 1.2x normal damage if all attacks hit.\r\n        damage: Math.ceil(0.4 * (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.getBaseWeaponDpsForLevel)(level) / attacksPerSecond),\r\n        damageOverTimeStackSize: 2,\r\n        chargeLevel: 2,\r\n        range: 150,\r\n        speed: window.BASE_BULLET_SPEED,\r\n        radius: 1.5 * window.BASE_BULLET_RADIUS,\r\n        duration: window.BASE_BULLET_DURATION,\r\n        enchantmentSlots: [],\r\n        bonusEnchantmentSlots: [],\r\n    };\r\n}\r\nconst morningStars = [\r\n    createMorningStar(1, 'Heavy Vine'),\r\n    createMorningStar(5, 'Leather Whip'),\r\n    createMorningStar(8, 'Chain Whip'),\r\n    createMorningStar(14, 'Ball and Chain'),\r\n    createMorningStar(20, 'Steel Flail'),\r\n    createMorningStar(27, 'Ninetails'),\r\n    createMorningStar(36, 'Morning Star'),\r\n    createMorningStar(46, 'Flaming Whip'),\r\n    createMorningStar(58, 'Orichalcum Whip'),\r\n    createMorningStar(72, 'Adamantine Morning Star'),\r\n    createMorningStar(85, 'Vampire Slayer'),\r\n    createMorningStar(95, 'Dragontail Flail'),\r\n];\r\nconst wandShots = [{\r\n        generateBullet(state, source, weapon, target) {\r\n            let dx = target.x - source.x, dy = target.y - source.y;\r\n            const mag = Math.sqrt(dx * dx + dy * dy) - 75;\r\n            const minRadius = 100;\r\n            const maxRadius = 300;\r\n            const targetX = source.x + dx, targetY = source.y + dy;\r\n            const radius = source.attackChargeLevel > 1 ? minRadius : Math.max(minRadius, Math.min(maxRadius, mag));\r\n            const speed = weapon.speed * (source.attackChargeLevel > 1 ? 1.5 : 1);\r\n            const critDamage = (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.rollForCritDamage)(state);\r\n            const theta = 2 * Math.PI * Math.random();\r\n            const x = targetX + radius * Math.cos(theta);\r\n            const y = targetY + radius * Math.sin(theta);\r\n            // This gets smaller faster the lower weapon range is.\r\n            const damageP = Math.max(0.2, Math.min(1, 1 - 0.5 * (mag - minRadius) / weapon.range));\r\n            return {\r\n                ...basicBullet(state, source, weapon, target),\r\n                baseX: x,\r\n                baseY: y,\r\n                x,\r\n                y,\r\n                vx: speed * Math.cos(theta + Math.PI),\r\n                vy: speed * Math.sin(theta + Math.PI),\r\n                damage: Math.ceil(weapon.damage * getChargeDamage(state, source.attackChargeLevel) * source.damage * critDamage) * damageP,\r\n                chargeGain: 0.2,\r\n                isCrit: critDamage > 1,\r\n                isEnemyPiercing: radius <= minRadius,\r\n                radius: weapon.radius + (source.attackChargeLevel - 1) - 5 + 10 * damageP,\r\n                duration: 1000 * radius / speed,\r\n                // Double armor shred effect\r\n                armorShred: 2 * getArmorShred(state, source.attackChargeLevel),\r\n            };\r\n        },\r\n    }];\r\nfunction createWand(level, name) {\r\n    const attacksPerSecond = 5 * window.BASE_ATTACKS_PER_SECOND;\r\n    return {\r\n        type: 'weapon',\r\n        weaponType: 'wand',\r\n        level: Math.floor(level),\r\n        name,\r\n        getShots: () => wandShots,\r\n        getAttacksPerSecond: () => attacksPerSecond,\r\n        critChance: 0.05,\r\n        critDamage: 0.5,\r\n        damage: Math.ceil(1.5 * (0,app_utils_coreCalculations__WEBPACK_IMPORTED_MODULE_1__.getBaseWeaponDpsForLevel)(level) / attacksPerSecond),\r\n        damageOverTimeStackSize: 5,\r\n        chargeLevel: 4,\r\n        range: 300,\r\n        speed: window.BASE_BULLET_SPEED,\r\n        radius: window.BASE_BULLET_RADIUS,\r\n        duration: window.BASE_BULLET_DURATION,\r\n        enchantmentSlots: [],\r\n        bonusEnchantmentSlots: [],\r\n    };\r\n}\r\nconst wands = [\r\n    createWand(1, 'Potent Stick'),\r\n    createWand(4, 'Balsa Wand'),\r\n    createWand(6, 'Juniper Wand'),\r\n    createWand(10, 'Pine Wand'),\r\n    createWand(15, 'Rosewood Wand'),\r\n    createWand(21, 'Rowan Wand'),\r\n    createWand(29, 'Oak Wand'),\r\n    createWand(39, 'Ebony Wand'),\r\n    createWand(50, 'Ironwood Wand'),\r\n    createWand(63, 'Intricate Wand'),\r\n    createWand(75, 'Runed Wand'),\r\n    createWand(89, 'Orichalcum Wand'),\r\n    createWand(95, 'Precursor Wand'),\r\n];\r\nconst weaponTypes = [\r\n    'bow',\r\n    'dagger',\r\n    'katana',\r\n    'morningStar',\r\n    'sword',\r\n    'wand',\r\n];\r\nconst weaponTypeLabels = {\r\n    bow: 'Bow',\r\n    dagger: 'Dagger',\r\n    katana: 'Katana',\r\n    morningStar: 'Morning Star',\r\n    wand: 'Wand',\r\n    sword: 'Sword',\r\n};\r\nconst weaponsByType = {\r\n    bow: bows,\r\n    dagger: daggers,\r\n    katana: katanas,\r\n    sword: swords,\r\n    morningStar: morningStars,\r\n    wand: wands,\r\n};\r\nconst allWeapons = Object.values(weaponsByType);\r\n\n\n//# sourceURL=webpack://alttp/./app/weapons.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app/client.ts");
/******/ 	
/******/ })()
;